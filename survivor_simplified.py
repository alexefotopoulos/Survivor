import random
import time
import sys
from typing import List, Dict, Optional, Tuple

class Contestant:
    def __init__(self, name: str, tribe: str, gender: str, is_player: bool = False, nickname: str = None, 
                 challenge_skill: int = 0, social_skill: int = 1, persuasive_skill: int = 1, 
                 perception_skill: int = 1, strategic_skill: int = 1, resistance_to_persuasion: int = 1,
                 survival_skill: int = 1, hero_or_villain: str = "Hero", positive_attribute: str = "Loyal",
                 neutral_attribute: str = "Competitive", negative_attribute: str = "Gullible"):
        self.full_name = name
        self.nickname = nickname if nickname else name
        self.name = self.nickname  # Default to nickname for display
        self.tribe = tribe
        self.gender = gender  # "Male" or "Female"
        self.is_player = is_player
        
        # Skills (all range from -1 to 3)
        self.challenge_skill = challenge_skill
        self.social_skill = social_skill
        self.persuasive_skill = persuasive_skill
        self.perception_skill = perception_skill
        self.strategic_skill = strategic_skill
        self.resistance_to_persuasion = resistance_to_persuasion
        self.survival_skill = survival_skill
        
        # Character attributes
        self.hero_or_villain = hero_or_villain
        self.positive_attribute = positive_attribute
        self.neutral_attribute = neutral_attribute
        self.negative_attribute = negative_attribute
        
        # Game state
        self.idol_count = 0  # Number of idols held (can have multiple) - DEPRECATED, use idols list
        self.idols = []  # List of idol objects: [{'tribe_beach': str, 'found_day': int}, ...]
        self.vote_protection = 0  # Percentage less likely to be voted for
        self.alliance_members = []  # DEPRECATED - kept for backward compatibility
        self.alliance_roster = []  # List of contestants in real alliances with this contestant
        self.fake_alliance_roster = []  # List of contestants who think they have alliance but don't
        self.group_alliances = []  # List of group alliance IDs this contestant is part of
        self.fake_group_alliances = []  # List of group alliance IDs where contestant thinks they're part but aren't
        self.eliminated = False
        self.immune = False  # For immunity challenges
        self.vote_target = None  # Who this contestant will target (influenced by player)
        self.target_roster = []  # List of contestants they want to eliminate long-term
        self.relationships = {}  # Dict mapping contestant to relationship value (-1 to 3)
        self.locked_relationships = set()  # Set of contestants whose relationships are locked (for jury voting)
        self.information_bank = []  # List of information known by this contestant
        self.threat_level = 5  # Threat level (1-10) - how threatening this contestant is perceived
        self.base_game_security = 5  # Base game security (0-10) - how safe this contestant feels (NPCs only)
        self.consecutive_correct_votes = 0  # Track consecutive correct votes for game security bonus
        self.consecutive_incorrect_votes = 0  # Track consecutive incorrect votes for game security penalty
        self.was_pitched_to_today = False  # Track if NPC was pitched to today
        self.daily_security_start = 5  # Game security at start of day (for tracking daily swings)
        self.recovery_modifier_tomorrow = 0  # Recovery modifier to apply tomorrow (+1 or -1), 0 = none
        self.immunity_wins = 0  # Number of immunity challenges won (post-merge)
        self.busted_penalties = {}  # Dict mapping contestant to (penalty_level, day_expires) for pitch penalties
        self.final_2_deal = None  # Contestant they have a final 2 deal with
        self.fake_final_2_deals = []  # List of contestants who think they have final 2 deal but don't
        self.final_2_betrayal_penalties = {}  # Dict mapping contestant to (penalty_level, day_expires) for final 2 betrayal penalties
        self.priority_vote_pitch_target = None  # Contestant to prioritize pitching against (e.g., someone targeting them)
        self.vote_pitch_agreements = {}  # Dict mapping contestant to target they agreed to vote for
        self.vote_pitch_confrontations = []  # List of (pitcher, agreed_target) tuples for next day confrontations
        self.broken_alliances = set()  # Set of contestants with whom this contestant has broken alliances
        self.immunity_displaced_vote_target = None  # Original vote target that was displaced due to immunity
        self.temporary_vote_target = None  # Temporary vote target used when original is immune
        self.consecutive_vote_pitch_days = 0  # Track consecutive days of vote pitching for threat level
        self.last_vote_pitch_day = 0  # Track the last day a vote pitch was made
        self.has_consecutive_pitch_threat_bonus = False  # Track if contestant currently has the +2 threat bonus
        self.orchestrated_eliminations = 0  # Track total eliminations orchestrated for threat level
        self.survival_status = 1  # Survival status (-1 to 3) - affects rolls and challenges
        self.game_move_bank = []  # Track significant game moves: [{move_type: str, level: int, day: int, description: str, details: dict}, ...]
        self.relationships_dropped_to_minus_one = set()  # Track contestants whose relationship with this person ever dropped to -1
        self.tribal_councils_survived_as_major_threat = 0  # Track tribal councils survived with threat 7+
        self.early_alliances = {}  # Track alliances formed in first 6 days: {partner: day_formed}
        self.consecutive_work_days = 0  # Track consecutive days of working around camp
        self.consecutive_no_work_days = 0  # Track consecutive days of NOT working around camp
        self.work_bonus_tomorrow = 0  # Survival roll bonus to apply tomorrow from camp work
        self.npc_actions_taken_today = 0  # Track NPC actions taken today (max 2)
        self.focused_on_survival_today = False  # Track if focused on survival today
        self.temporary_persuasion_modifiers = {}  # Dict mapping contestant to (modifier, day_expires) for temporary persuasion bonuses/penalties
        self.sat_out_last_challenge = False  # Track if contestant sat out the last challenge (prevents consecutive sit-outs)
        self.work_penalty_warning_due = False  # Track if player should receive work penalty warning at start of day
        self.consecutive_failed_idol_hunts = 0  # Track consecutive failed idol hunt attempts for Resourceful bonus
        self.perceptive_uses = {"pre_merge": 0, "post_swap": 0, "post_merge": 0}  # Track Perceptive ability usage by phase
        self.small_talk_received_days = []  # Track days when small talk was received (for Paranoid attribute)
        self.vengeful_vote_count = {}  # Track how many times each contestant has voted for this vengeful player
        self.lost_challenge_today = False  # Track if competitive player lost a challenge today (for social penalty)
        
        # Apply human player attribute replacements if this is a player
        if self.is_player:
            self._apply_human_player_attribute_replacements()
        
    def __str__(self) -> str:
        return self.name
    
    def get_full_name(self) -> str:
        """Get the full name for introductions."""
        return self.full_name if not self.is_player else self.name
    
    def _apply_human_player_attribute_replacements(self):
        """Replace non-applicable attributes for human players with suitable alternatives.
        
        Threat Hunter -> Competitive (human controls targeting)
        Vengeful -> Secretive (human controls targeting) 
        Gullible -> Complainer (human controls belief decisions)
        """
        replacements = {
            "Threat Hunter": "Competitive",
            "Vengeful": "Secretive", 
            "Gullible": "Complainer"
        }
        
        # Check and replace positive attribute
        if self.positive_attribute in replacements:
            self.positive_attribute = replacements[self.positive_attribute]
            
        # Check and replace neutral attribute
        if self.neutral_attribute in replacements:
            self.neutral_attribute = replacements[self.neutral_attribute]
            
        # Check and replace negative attribute
        if self.negative_attribute in replacements:
            self.negative_attribute = replacements[self.negative_attribute]
    
    def get_character_instructions(self) -> Dict[str, str]:
        """Get behavioral instructions based on character attributes."""
        instructions = {}
        
        # Hero/Villain instructions
        hero_villain_instructions = {
            "Hero": "Act with honor and integrity. Prioritize loyalty and fairness. Avoid betraying allies unless absolutely necessary for survival.",
            "Villain": "Play ruthlessly and strategically. Prioritize winning over relationships. Use deception and manipulation when beneficial.",
            "Anti-Hero": "Balance moral choices with strategic needs. Show complexity in decision-making between right and strategic.",
            "Neutral": "Focus on pragmatic gameplay. Make decisions based on what's most advantageous without strong moral constraints."
        }
        instructions["archetype"] = hero_villain_instructions.get(self.hero_or_villain, "Play according to your nature.")
        
        # Positive attribute instructions
        positive_instructions = {
            "Loyal": "Honor your alliances and commitments. Be reluctant to betray trusted allies.",
            "Charismatic": "Naturally connect with others and build relationships easily. People are drawn to your personality.",
            "Hardworking": "Consistently contribute to camp life and tribe welfare. Take pride in effort and productivity.",
            "Resilient": "Bounce back stronger from setbacks. Use defeats as motivation to improve.",
            "Resourceful": "Find creative solutions to problems. Excel at discovering hidden advantages.",
            "Perceptive": "Notice subtle social cues and danger signals. Have heightened awareness of threats."
        }
        instructions["positive"] = positive_instructions.get(self.positive_attribute, "Express your positive qualities.")
        
        # Neutral attribute instructions  
        neutral_instructions = {
            "Competitive": "Strive to win challenges and outperform others. Take competition seriously.",
            "Secretive": "Keep information close to the vest. Excel at hidden activities but struggle when questioned.",
            "Introverted": "Prefer intimate conversations over group settings. Excel one-on-one but struggle in groups.",
            "Threat Hunter": "Automatically identify and target high-threat players. Focus on eliminating dangerous competitors.",
            "Under the Radar": "Maintain a low profile and avoid attention. Fly under the radar but miss alliance opportunities.",
            "Big Personality": "Thrive in group settings and social gatherings. Command attention and entertain others.",
            "Vengeful": "Never forget betrayals. Systematically target those who vote against you."
        }
        instructions["neutral"] = neutral_instructions.get(self.neutral_attribute, "Show your characteristic traits.")
        
        # Negative attribute instructions
        negative_instructions = {
            "Gullible": "Be more likely to believe what others tell you. Struggle to detect deception.",
            "Paranoid": "Suspect others' motives frequently. Worry about betrayal and hidden agendas.",
            "Arrogant": "Overestimate your abilities and importance. Underestimate threats from others.",
            "Lazy": "Avoid work when possible. Prefer to let others handle responsibilities.",
            "Complainer": "Vocalize dissatisfaction when struggling. Let physical discomfort affect social interactions.",
            "High Strung": "Display nervous energy and tension. Make others uncomfortable with anxious behavior."
        }
        instructions["negative"] = negative_instructions.get(self.negative_attribute, "Show your character flaws.")
        
        return instructions
    
    def get_decision_guidance(self, situation: str) -> str:
        """Get specific guidance for common game situations based on attributes."""
        instructions = self.get_character_instructions()
        
        situation_guidance = {
            "alliance_formation": f"{instructions['positive']} {instructions['archetype']}",
            "betrayal_opportunity": f"{instructions['archetype']} {instructions['negative']}",
            "challenge_participation": f"{instructions['neutral']} {instructions['positive']}",
            "vote_decision": f"{instructions['archetype']} {instructions['negative']}",
            "information_sharing": f"{instructions['positive']} {instructions['negative']}",
            "conflict_resolution": f"{instructions['archetype']} {instructions['neutral']}"
        }
        
        return situation_guidance.get(situation, f"Act according to your character: {instructions['archetype']}")
    
    def should_prioritize_loyalty(self) -> bool:
        """Determine if this contestant should prioritize loyalty based on attributes."""
        loyalty_positive = self.positive_attribute in ["Loyal", "Honest", "Protective", "Compassionate"]
        loyalty_hero = self.hero_or_villain == "Hero"
        loyalty_negative = self.negative_attribute not in ["Selfish", "Vindictive", "Arrogant"]
        
        return loyalty_positive or (loyalty_hero and loyalty_negative)
    
    def get_deception_tendency(self) -> float:
        """Get likelihood to use deception (0.0 to 1.0) based on attributes."""
        base_tendency = 0.3  # Base deception tendency
        
        # Hero/Villain modifiers
        if self.hero_or_villain == "Villain":
            base_tendency += 0.4
        elif self.hero_or_villain == "Hero":
            base_tendency -= 0.3
        elif self.hero_or_villain == "Anti-Hero":
            base_tendency += 0.1
            
        # Positive attribute modifiers
        if self.positive_attribute in ["Honest", "Loyal"]:
            base_tendency -= 0.2
        elif self.positive_attribute in ["Determined", "Courageous"]:
            base_tendency += 0.1
            
        # Negative attribute modifiers  
        if self.negative_attribute in ["Selfish", "Vindictive", "Arrogant"]:
            base_tendency += 0.2
        elif self.negative_attribute == "Gullible":
            base_tendency -= 0.1
            
        return max(0.0, min(1.0, base_tendency))
    
    def is_charismatic(self) -> bool:
        """Check if this contestant has the Charismatic attribute."""
        return (self.positive_attribute == "Charismatic" or 
                self.neutral_attribute == "Charismatic" or 
                self.negative_attribute == "Charismatic")
    
    def apply_charismatic_relationships(self, all_contestants: List['Contestant']) -> None:
        """Apply the Charismatic attribute relationship bonus with other contestants."""
        if not self.is_charismatic():
            return
            
        for other in all_contestants:
            if other != self and not other.eliminated:
                # Charismatic contestants start with relationship of 1 with others
                # This doesn't stack if both contestants are charismatic
                if self.name not in other.relationships:
                    other.relationships[self.name] = 1
                if other.name not in self.relationships:
                    self.relationships[other.name] = 1
    
    def is_hardworking(self) -> bool:
        """Check if this contestant has the Hardworking attribute."""
        return (self.positive_attribute == "Hardworking" or 
                self.neutral_attribute == "Hardworking" or 
                self.negative_attribute == "Hardworking")
    
    def is_lazy(self) -> bool:
        """Check if this contestant has the Lazy attribute."""
        return (self.positive_attribute == "Lazy" or 
                self.neutral_attribute == "Lazy" or 
                self.negative_attribute == "Lazy")
    
    def get_work_penalty_threshold(self) -> int:
        """Get the number of days without work before penalty applies.
        Lazy contestants: 2 days (penalty on day 3)
        Normal contestants: 3 days (penalty on day 4)
        Hardworking contestants: 4 days (penalty on day 5)
        """
        if self.is_hardworking():
            return 4
        elif self.is_lazy():
            return 2
        else:
            return 3
    
    def is_loyal(self) -> bool:
        """Check if this contestant has the Loyal attribute."""
        return (self.positive_attribute == "Loyal" or 
                self.neutral_attribute == "Loyal" or 
                self.negative_attribute == "Loyal")
    
    def get_alliance_pitch_bonus(self) -> int:
        """Get the bonus for alliance pitch rolls.
        Loyal contestants get +2 bonus when pitching new alliances.
        """
        if self.is_loyal():
            return 2
        else:
            return 0
    
    def is_resilient(self) -> bool:
        """Check if this contestant has the Resilient attribute."""
        return (self.positive_attribute == "Resilient" or 
                self.neutral_attribute == "Resilient" or 
                self.negative_attribute == "Resilient")
    
    def get_resilient_challenge_bonus(self, tribe_lost_last_immunity: bool = False, 
                                     individual_lost_last_immunity: bool = False) -> int:
        """Get the challenge bonus for resilient contestants after losing immunity.
        Resilient contestants get +1 if their tribe lost the previous immunity challenge
        OR if they lost the previous individual immunity challenge.
        This does not stack - maximum bonus is +1.
        """
        if not self.is_resilient():
            return 0
            
        if tribe_lost_last_immunity or individual_lost_last_immunity:
            return 1
        else:
            return 0
    
    def is_resourceful(self) -> bool:
        """Check if this contestant has the Resourceful attribute."""
        return (self.positive_attribute == "Resourceful" or 
                self.neutral_attribute == "Resourceful" or 
                self.negative_attribute == "Resourceful")
    
    def get_resourceful_idol_bonus(self) -> int:
        """Get the idol hunt bonus for resourceful contestants based on consecutive failures.
        Resourceful contestants get +2 for each consecutive failed idol hunt.
        This bonus DOES stack: 1 failure = +2, 2 failures = +4, etc.
        """
        if not self.is_resourceful():
            return 0
            
        return self.consecutive_failed_idol_hunts * 2
    
    def reset_idol_hunt_streak(self):
        """Reset the consecutive failed idol hunt counter (call when idol is found)."""
        self.consecutive_failed_idol_hunts = 0
    
    def increment_failed_idol_hunts(self):
        """Increment the consecutive failed idol hunt counter."""
        self.consecutive_failed_idol_hunts += 1
    
    def is_perceptive(self) -> bool:
        """Check if this contestant has the Perceptive attribute."""
        return (self.positive_attribute == "Perceptive" or 
                self.neutral_attribute == "Perceptive" or 
                self.negative_attribute == "Perceptive")
    
    def can_use_perceptive_ability(self, game_phase: str) -> bool:
        """Check if the Perceptive ability can be used in the current game phase.
        Limited to once per phase: pre_merge, post_swap, post_merge.
        """
        if not self.is_perceptive():
            return False
            
        if game_phase not in self.perceptive_uses:
            return False
            
        return self.perceptive_uses[game_phase] == 0
    
    def check_perceptive_consensus_detection(self, game_phase: str) -> Tuple[bool, str]:
        """Check if perceptive contestant detects being the consensus vote.
        Returns (detected, message).
        Rolls d20: 1-10 = no detection, 11-20 = detection.
        """
        if not self.can_use_perceptive_ability(game_phase):
            return False, ""
            
        roll = random.randint(1, 20)
        
        if roll >= 11:
            # Detected being consensus vote
            self.perceptive_uses[game_phase] += 1
            message = f"You have a bad feeling that you're going to be voted out."
            return True, message
        else:
            # Did not detect (but still uses the ability for this phase)
            self.perceptive_uses[game_phase] += 1
            return False, ""
    
    def add_perceptive_consensus_info(self, message: str):
        """Add perceptive consensus detection to info bank, overwriting existing consensus info."""
        # Remove any existing consensus vote information
        self.information_bank = [info for info in self.information_bank 
                                if "consensus vote" not in info.lower()]
        
        # Add new perceptive information
        self.information_bank.append(f"Perceptive Sense: {message}")
    
    def is_paranoid(self) -> bool:
        """Check if this contestant has the Paranoid attribute."""
        return (self.positive_attribute == "Paranoid" or 
                self.neutral_attribute == "Paranoid" or 
                self.negative_attribute == "Paranoid")
    
    def record_small_talk_received(self, current_day: int):
        """Record that small talk was received on the given day."""
        if current_day not in self.small_talk_received_days:
            self.small_talk_received_days.append(current_day)
    
    def get_paranoid_vote_pitch_penalty(self, current_day: int) -> int:
        """Get the vote pitch penalty for paranoid contestants.
        Paranoid contestants get -1 if nobody has initiated small talk in past 2 days (including today).
        """
        if not self.is_paranoid():
            return 0
            
        # Check if small talk received in past 2 days (including today)
        recent_days = [current_day, current_day - 1]
        
        for day in recent_days:
            if day in self.small_talk_received_days:
                return 0  # No penalty - received small talk recently
                
        return -1  # Apply penalty - no recent small talk
    
    def is_arrogant(self) -> bool:
        """Check if this contestant has the Arrogant attribute."""
        return (self.positive_attribute == "Arrogant" or 
                self.neutral_attribute == "Arrogant" or 
                self.negative_attribute == "Arrogant")
    
    def get_arrogant_social_penalty(self, target_contestant: 'Contestant') -> int:
        """Get the social skill penalty for arrogant contestants.
        Arrogant contestants get -1 on social skill rolls with non-alliance members.
        """
        if not self.is_arrogant():
            return 0
            
        # Check if target is in any form of alliance with this contestant
        in_alliance = (target_contestant in self.alliance_roster or 
                      target_contestant in self.fake_alliance_roster or
                      target_contestant.name in [c.name for c in self.alliance_roster] or
                      target_contestant.name in [c.name for c in self.fake_alliance_roster])
        
        # Also check group alliances
        if not in_alliance:
            for group_id in self.group_alliances + self.fake_group_alliances:
                # Would need access to group alliance rosters to check membership
                # For now, we'll assume the game logic handles this check
                pass
                
        if in_alliance:
            return 0  # No penalty for alliance members
        else:
            return -1  # Penalty for non-alliance members
    
    def is_gullible(self) -> bool:
        """Check if this contestant has the Gullible attribute."""
        return (self.positive_attribute == "Gullible" or 
                self.neutral_attribute == "Gullible" or 
                self.negative_attribute == "Gullible")
    
    def get_gullible_resistance_penalty(self, persuader: 'Contestant') -> int:
        """Get the resistance to persuasion penalty for gullible contestants.
        Gullible contestants get -1 resistance when being persuaded by villains.
        """
        if not self.is_gullible():
            return 0
            
        # Check if the persuader is a villain
        if persuader.hero_or_villain == "Villain":
            return -1  # Penalty against villains
        else:
            return 0  # No penalty against non-villains
    
    def is_complainer(self) -> bool:
        """Check if this contestant has the Complainer attribute."""
        return (self.positive_attribute == "Complainer" or 
                self.neutral_attribute == "Complainer" or 
                self.negative_attribute == "Complainer")
    
    def get_complainer_social_penalty(self) -> int:
        """Get the social skill penalty for complainer contestants.
        Complainers get -1 to social skill rolls when survival status is 0 or -1.
        """
        if not self.is_complainer():
            return 0
            
        # Check survival status
        if self.survival_status <= 0:
            return -1  # Penalty when struggling with survival
        else:
            return 0  # No penalty when survival status is positive
    
    def is_high_strung(self) -> bool:
        """Check if this contestant has the High Strung attribute."""
        return (self.positive_attribute == "High Strung" or 
                self.neutral_attribute == "High Strung" or 
                self.negative_attribute == "High Strung")
    
    def get_high_strung_alliance_slip(self) -> int:
        """Get the alliance pitch slip penalty for high strung contestants.
        High strung contestants have -1 slip when other NPCs choose pitch alliance option.
        This makes them slightly less likely to be chosen for alliance pitches.
        """
        if self.is_high_strung():
            return -1
        else:
            return 0
    
    def is_vengeful(self) -> bool:
        """Check if this contestant has the Vengeful attribute."""
        return (self.positive_attribute == "Vengeful" or 
                self.neutral_attribute == "Vengeful" or 
                self.negative_attribute == "Vengeful")
    
    def record_vote_against_vengeful(self, voter: 'Contestant'):
        """Record that a contestant voted against this vengeful player.
        Adds voter to target roster and tracks vote count for potential vote target assignment.
        """
        if not self.is_vengeful():
            return
            
        # Add voter to target roster if not already there
        if voter not in self.target_roster:
            self.target_roster.append(voter)
            
        # Track vote count
        voter_name = voter.name
        if voter_name not in self.vengeful_vote_count:
            self.vengeful_vote_count[voter_name] = 0
        self.vengeful_vote_count[voter_name] += 1
        
        # Check if this voter has reached 3 votes - becomes new vote target
        if self.vengeful_vote_count[voter_name] == 3:
            # Prevent self-targeting
            if voter != self:
                self.vote_target = voter
    
    def handle_multiple_third_votes(self, voters_at_three: List['Contestant']):
        """Handle case where multiple voters simultaneously reach 3 votes.
        Randomly selects one as the vote target.
        """
        if not self.is_vengeful() or not voters_at_three:
            return
        
        # Filter out self from potential targets
        valid_voters = [voter for voter in voters_at_three if voter != self]
        if valid_voters:
            self.vote_target = random.choice(valid_voters)
    
    def get_vengeful_vote_counts(self) -> Dict[str, int]:
        """Get the current vote counts for each contestant who has voted against this vengeful player."""
        if not self.is_vengeful():
            return {}
        return self.vengeful_vote_count.copy()
    
    def is_competitive(self) -> bool:
        """Check if this contestant has the Competitive attribute."""
        return (self.positive_attribute == "Competitive" or 
                self.neutral_attribute == "Competitive" or 
                self.negative_attribute == "Competitive")
    
    def get_competitive_challenge_bonus(self) -> int:
        """Get the challenge roll bonus for competitive contestants.
        Competitive contestants always get +1 to challenge rolls.
        """
        if self.is_competitive():
            return 1
        else:
            return 0
    
    def record_competitive_challenge_loss(self):
        """Record that this competitive contestant lost a challenge today.
        This triggers social skill penalties for the remainder of the day.
        """
        if self.is_competitive():
            self.lost_challenge_today = True
    
    def get_competitive_social_penalty(self) -> int:
        """Get the social skill penalty for competitive contestants.
        Competitive contestants get -1 to social skill rolls for remainder of day after losing a challenge.
        """
        if self.is_competitive() and self.lost_challenge_today:
            return -1
        else:
            return 0
    
    def reset_competitive_challenge_status(self):
        """Reset the challenge loss status at the start of a new day."""
        self.lost_challenge_today = False
    
    def is_secretive(self) -> bool:
        """Check if this contestant has the Secretive attribute."""
        return (self.positive_attribute == "Secretive" or 
                self.neutral_attribute == "Secretive" or 
                self.negative_attribute == "Secretive")
    
    def get_secretive_idol_bonus(self) -> int:
        """Get the idol search bonus for secretive contestants.
        Secretive contestants get +1 to idol hunt rolls.
        """
        if self.is_secretive():
            return 1
        else:
            return 0
    
    def get_probe_bonus_against_secretive(self, target: 'Contestant') -> int:
        """Get the probe bonus when targeting a secretive contestant.
        Players get +1 to probe rolls against secretive contestants.
        """
        if target.is_secretive():
            return 1
        else:
            return 0
    
    def is_introverted(self) -> bool:
        """Check if this contestant has the Introverted attribute."""
        return (self.positive_attribute == "Introverted" or 
                self.neutral_attribute == "Introverted" or 
                self.negative_attribute == "Introverted")
    
    def get_introverted_conversation_modifier(self, is_one_on_one: bool) -> int:
        """Get the conversation modifier for introverted contestants.
        Introverted contestants get +2 in one-on-one conversations, -1 in group conversations.
        """
        if not self.is_introverted():
            return 0
            
        if is_one_on_one:
            return 2  # Bonus for one-on-one conversations
        else:
            return -1  # Penalty for group conversations
    
    def is_threat_hunter(self) -> bool:
        """Check if this contestant has the Threat Hunter attribute."""
        return (self.positive_attribute == "Threat Hunter" or 
                self.neutral_attribute == "Threat Hunter" or 
                self.negative_attribute == "Threat Hunter")
    
    def update_threat_hunter_targets(self, all_contestants: List['Contestant']):
        """Update target roster for threat hunter based on high-threat contestants.
        Automatically adds contestants with threat level 8+ to target roster.
        """
        if not self.is_threat_hunter():
            return
            
        for contestant in all_contestants:
            if (contestant != self and 
                not contestant.eliminated and 
                contestant.threat_level >= 8 and 
                contestant not in self.target_roster):
                self.target_roster.append(contestant)
    
    def remove_eliminated_from_threat_targets(self, eliminated_contestant: 'Contestant'):
        """Remove eliminated contestant from threat hunter's target roster."""
        if self.is_threat_hunter() and eliminated_contestant in self.target_roster:
            self.target_roster.remove(eliminated_contestant)
    
    def is_big_personality(self) -> bool:
        """Check if this contestant has the Big Personality attribute."""
        return (self.positive_attribute == "Big Personality" or 
                self.neutral_attribute == "Big Personality" or 
                self.negative_attribute == "Big Personality")
    
    def get_big_personality_social_modifier(self, is_one_on_one: bool) -> int:
        """Get the social skill modifier for big personality contestants.
        Big Personality contestants get +3 in group conversations, -2 in one-on-one conversations.
        """
        if not self.is_big_personality():
            return 0
            
        if is_one_on_one:
            return -2  # Penalty for one-on-one conversations
        else:
            return 3  # Bonus for group conversations
    
    def is_under_the_radar(self) -> bool:
        """Check if this contestant has the Under the Radar attribute."""
        return (self.positive_attribute == "Under the Radar" or 
                self.neutral_attribute == "Under the Radar" or 
                self.negative_attribute == "Under the Radar")
    
    def get_under_the_radar_threat_modifier(self) -> int:
        """Get the threat level modifier for under the radar contestants.
        Under the Radar contestants get -1 to their threat level.
        """
        if self.is_under_the_radar():
            return -1
        else:
            return 0
    
    def get_under_the_radar_alliance_slip(self) -> int:
        """Get the alliance pitch slip penalty for under the radar contestants.
        Under the Radar contestants have -1 slip when others choose them for alliance pitches.
        This makes them less likely to be chosen for alliance approaches.
        """
        if self.is_under_the_radar():
            return -1
        else:
            return 0
    
    def get_pronoun(self, case: str = "subject") -> str:
        """Get the appropriate pronoun for this contestant."""
        if self.gender == "Male":
            if case == "subject":
                return "he"
            elif case == "object":
                return "him"
            elif case == "possessive":
                return "his"
        else:  # Female
            if case == "subject":
                return "she"
            elif case == "object":
                return "her"
            elif case == "possessive":
                return "her"
        return "they"  # fallback
    
    def get_relationship(self, other_contestant: 'Contestant') -> int:
        """Get the relationship value with another contestant. Returns 0 if not set."""
        return self.relationships.get(other_contestant, 0)
    
    def get_survival_status_modifier(self, roll_type: str = "general") -> int:
        """Get the survival status modifier for different types of rolls.
        roll_type can be 'general', 'challenge', or 'all'"""
        if self.survival_status == -1:  # On the Brink
            return -1  # Affects all rolls
        elif self.survival_status == 0:  # Struggling
            return -1 if roll_type in ["challenge", "all"] else 0  # Only affects challenge rolls
        elif self.survival_status == 1:  # Stable
            return 0  # No modifier
        elif self.survival_status == 2:  # Feeling Good
            return 1 if roll_type in ["challenge", "all"] else 0  # Only affects challenge rolls
        elif self.survival_status == 3:  # Thriving
            return 1  # Affects all rolls
        else:
            return 0  # Fallback
    
    def add_game_move(self, move_type: str, level: int, day: int, description: str, **details) -> None:
        """Add a game move to this contestant's Game Move Bank.
        
        Args:
            move_type: Type of move (e.g., 'idol_play', 'alliance_betrayal', 'vote_flip')
            level: Significance level (1=least, 2=medium, 3=most significant)
            day: Day the move occurred
            description: Human-readable description of the move
            **details: Additional details specific to the move type
        """
        game_move = {
            'move_type': move_type,
            'level': level,
            'day': day,
            'description': description,
            'details': details
        }
        self.game_move_bank.append(game_move)
    
    def get_game_moves_by_level(self, level: int) -> list:
        """Get all game moves of a specific level."""
        return [move for move in self.game_move_bank if move['level'] == level]
    
    def get_total_game_move_score(self) -> int:
        """Calculate total game move score (Level 3 = 3 points, Level 2 = 2 points, Level 1 = 1 point)."""
        return sum(move['level'] for move in self.game_move_bank)
    
    def remove_game_move(self, move_type: str) -> bool:
        """Remove a game move from the bank. Returns True if move was found and removed."""
        for i, move in enumerate(self.game_move_bank):
            if move['move_type'] == move_type:
                del self.game_move_bank[i]
                return True
        return False
    
    def set_relationship(self, other_contestant: 'Contestant', value: int, game=None) -> None:
        """Set the relationship value with another contestant. Clamps between -1 and 3."""
        # Don't modify if relationship is locked
        if other_contestant in self.locked_relationships:
            return
        value = max(-1, min(3, value))  # Clamp between -1 and 3
        
        # Track if relationship drops to -1
        if value == -1:
            self.relationships_dropped_to_minus_one.add(other_contestant)
            
            # If post-merge, immediately remove good jury relationships move
            if game and game.merged:
                self.remove_game_move('good_jury_relationships')
        
        self.relationships[other_contestant] = value
    
    def modify_relationship(self, other_contestant: 'Contestant', change: int, game=None) -> None:
        """Modify the relationship value by a certain amount. Result is clamped between -1 and 3."""
        # Don't modify if relationship is locked
        if other_contestant in self.locked_relationships:
            return
        
        current_value = self.get_relationship(other_contestant)
        new_value = current_value + change
        
        # Final 2 Alliance Benefit 2: Relationship cannot fall below 2 for Final 2 partners
        if (self.has_real_final_2_with(other_contestant) or 
            self.has_fake_final_2_with(other_contestant)) and new_value < 2:
            new_value = 2
        
        self.set_relationship(other_contestant, new_value, game)
    
    def get_game_security(self, game_merged: bool = False) -> int:
        """Get the current game security with modifiers applied. Only applies to NPCs."""
        # Player doesn't have game security
        if self.is_player:
            return 0
        
        # Start with base game security
        security = self.base_game_security
        
        # Apply challenge skill modifier based on game phase
        if game_merged:
            # Post-merge: subtract challenge skill (strong players are bigger targets)
            security -= self.challenge_skill
        else:
            # Pre-merge: add challenge skill (strong players feel safer in tribal challenges)
            security += self.challenge_skill
        
        # Clamp result between 0 and 10
        return max(0, min(10, security))
    
    def modify_base_game_security(self, change: int, reason: str = "", silent: bool = False) -> None:
        """Modify the base game security value. Only applies to NPCs."""
        if self.is_player:
            return  # Player doesn't have game security
        
        # Skip changes if this NPC is in recovery mode (had big swing yesterday)
        if self.recovery_modifier_tomorrow != 0:
            # if change != 0 and not silent:
            #     print(f"[Game Security] {self.name}: Change blocked during recovery day - {reason}")
            return
        
        old_value = self.base_game_security
        self.base_game_security = max(0, min(10, self.base_game_security + change))
        
        # Debug output (can be removed later if desired)
        # if change != 0 and not silent:
        #     print(f"[Game Security] {self.name}: {old_value} → {self.base_game_security} ({change:+d}) - {reason}")
    
    def record_correct_vote(self) -> None:
        """Record that this NPC voted correctly (for the eliminated contestant)."""
        if self.is_player:
            return  # Player doesn't have game security
        
        self.consecutive_correct_votes += 1
        self.consecutive_incorrect_votes = 0  # Reset incorrect streak
        
        # Game Security: Check for the most severe applicable bonus
        if self.consecutive_correct_votes == 4:
            # 4 consecutive correct votes (+3) - more severe than individual vote (+1)
            self.modify_base_game_security(3, "4 consecutive correct votes")
        else:
            # Individual correct vote (+1)
            self.modify_base_game_security(1, "Correctly voted for eliminated contestant")
    
    def record_incorrect_vote(self) -> None:
        """Record that this NPC voted incorrectly (not for the eliminated contestant)."""
        if self.is_player:
            return  # Player doesn't have game security
        
        # Reset consecutive correct votes
        self.consecutive_correct_votes = 0
        self.consecutive_incorrect_votes += 1
        
        # Game Security: Check for the most severe applicable penalty
        if self.consecutive_incorrect_votes == 4:
            # 4 consecutive incorrect votes (-3) - more severe than individual vote (-1)
            self.modify_base_game_security(-3, "4 consecutive incorrect votes")
        else:
            # Individual incorrect vote (-1)
            self.modify_base_game_security(-1, "Voted incorrectly at tribal council")
    
    def learn_being_targeted(self, targeter_name: str = "someone") -> None:
        """Record that this NPC learned someone is targeting them."""
        if self.is_player:
            return  # Player doesn't have game security
        
        # Game Security: NPC learns that someone is targeting them (-2)
        self.modify_base_game_security(-2, f"Learned {targeter_name} is targeting them", silent=True)
    
    def receive_vote_at_tribal(self) -> None:
        """Record that this NPC received at least one vote at tribal council.
        Should only be called once per tribal council, regardless of vote count."""
        if self.is_player:
            return  # Player doesn't have game security
        
        # Game Security: NPC receives a vote at tribal council (-2)
        self.modify_base_game_security(-2, "Received vote at tribal council")
    
    def ally_voted_out(self, ally_name: str, voted_for_ally: bool = False) -> None:
        """Record that an alliance member was voted out."""
        if self.is_player:
            return  # Player doesn't have game security
        
        # Game Security: Alliance member voted out (-3), unless NPC voted out their ally
        if not voted_for_ally:
            self.modify_base_game_security(-3, f"Alliance member {ally_name} voted out")
    
    def mark_pitched_to_today(self) -> None:
        """Mark that this NPC was pitched to today."""
        if self.is_player:
            return  # Player doesn't have game security
        
        self.was_pitched_to_today = True
    
    def check_daily_pitch_penalty(self) -> None:
        """Check if NPC was not pitched to today and apply penalty."""
        if self.is_player:
            return  # Player doesn't have game security
        
        # Game Security: If a day goes by and nobody pitches to an NPC (-1)
        if not self.was_pitched_to_today:
            self.modify_base_game_security(-1, "No one pitched to them today", silent=True)
        
        # Reset for next day
        self.was_pitched_to_today = False
    
    def start_day_game_security_processing(self) -> None:
        """Process game security at the start of each day."""
        if self.is_player:
            return  # Player doesn't have game security
        
        # Apply recovery modifier if set from previous day's big swing
        if self.recovery_modifier_tomorrow != 0:
            old_value = self.base_game_security
            self.base_game_security = max(0, min(10, self.base_game_security + self.recovery_modifier_tomorrow))
            recovery_direction = "positive" if self.recovery_modifier_tomorrow > 0 else "negative"
            # Silent - don't reveal game security changes to player
            # print(f"[Game Security] {self.name}: {old_value} → {self.base_game_security} ({self.recovery_modifier_tomorrow:+d}) - Recovery from yesterday's big {recovery_direction} swing")
            
            # Clear the recovery modifier
            self.recovery_modifier_tomorrow = 0
        
        # Record the starting game security for today (to track daily swings)
        self.daily_security_start = self.base_game_security
    
    def end_day_game_security_processing(self) -> None:
        """Process game security at the end of each day to check for big swings."""
        if self.is_player:
            return  # Player doesn't have game security
        
        # Calculate the daily swing
        daily_change = self.base_game_security - self.daily_security_start
        
        # Check if there was a big swing (5+ points in either direction)
        if abs(daily_change) >= 5:
            # Set recovery modifier for tomorrow (opposite direction)
            self.recovery_modifier_tomorrow = -1 if daily_change > 0 else 1
            swing_direction = "positive" if daily_change > 0 else "negative"
            recovery_direction = "negative" if daily_change > 0 else "positive"
            print(f"[Game Security] {self.name}: Big {swing_direction} swing today ({daily_change:+d}), will get {recovery_direction} recovery tomorrow")
    
    def get_relationship_description(self, other_contestant: 'Contestant') -> str:
        """Get a text description of the relationship level."""
        value = self.get_relationship(other_contestant)
        if value == -1:
            return "dislike each other"
        elif value == 0:
            return "are neutral with each other"
        elif value == 1:
            return "are friendly"
        elif value == 2:
            return "are good friends in the game"
        elif value == 3:
            return "are best friends"
        return "have an unknown relationship"
    
    def has_real_alliance_with(self, other: 'Contestant', game=None) -> bool:
        """Check if this contestant has a real alliance with another contestant (including final 2 deals and group alliances)."""
        # Check for 2-person alliance or final 2 deal
        if other in self.alliance_roster or self.final_2_deal == other:
            return True
        # Check for group alliance if game instance is provided
        if game is not None:
            return self.has_real_group_alliance_with(other, game)
        return False
    
    def has_fake_alliance_with(self, other: 'Contestant') -> bool:
        """Check if this contestant has a fake alliance with another contestant (they think it's real but it's not)."""
        return other in self.fake_alliance_roster
    
    def believes_has_alliance_with(self, other: 'Contestant', game=None) -> bool:
        """Check if this contestant believes they have an alliance (real or fake) with another contestant."""
        # Check for 2-person alliances (real or fake)
        if other in self.alliance_roster or other in self.fake_alliance_roster:
            return True
        # Check for group alliances if game instance is provided
        if game is not None:
            return self.believes_has_group_alliance_with(other, game)
        return False
    
    def has_real_group_alliance_with(self, other: 'Contestant', game) -> bool:
        """Check if this contestant has a real group alliance with another contestant."""
        for alliance_id in self.group_alliances:
            if alliance_id in game.group_alliances:
                alliance_members = game.group_alliances[alliance_id]['members']
                if other in alliance_members:
                    return True
        return False
    
    def has_fake_group_alliance_with(self, other: 'Contestant', game) -> bool:
        """Check if this contestant believes they have a group alliance with another contestant but it's fake."""
        # For fake group alliances, the player believes they're in the alliance but they're not actually part of it
        # Check if other is in fake_alliance_roster (this covers the fake group alliance case)
        return other in self.fake_alliance_roster
    
    def believes_has_group_alliance_with(self, other: 'Contestant', game) -> bool:
        """Check if this contestant believes they have a group alliance (real or fake) with another contestant."""
        return self.has_real_group_alliance_with(other, game) or self.has_fake_group_alliance_with(other, game)
    
    def can_rebuild_alliance_with(self, other: 'Contestant') -> bool:
        """Check if this contestant can rebuild an alliance with another after a previous break."""
        # If they never had a broken alliance, they can form new alliances
        if other not in self.broken_alliances:
            return True
        
        # If they have a broken alliance history, both must have relationship 3+ to rebuild
        return self.get_relationship(other) >= 3 and other.get_relationship(self) >= 3
    
    def has_real_final_2_with(self, other: 'Contestant') -> bool:
        """Check if this contestant has a real final 2 deal with another contestant."""
        return self.final_2_deal == other and other.final_2_deal == self
    
    def has_fake_final_2_with(self, other: 'Contestant') -> bool:
        """Check if this contestant has a fake final 2 deal with another contestant (they think it's real but it's not)."""
        return other in self.fake_final_2_deals
    
    def believes_has_final_2_with(self, other: 'Contestant') -> bool:
        """Check if this contestant believes they have a final 2 deal (real or fake) with another contestant."""
        return self.final_2_deal == other or other in self.fake_final_2_deals
    
    @property
    def has_idol(self) -> bool:
        """Returns True if contestant has any idols."""
        return len(self.idols) > 0
    
    @has_idol.setter
    def has_idol(self, value: bool) -> None:
        """Backward compatibility setter - sets idol count and list based on boolean."""
        if value and len(self.idols) == 0:
            # Add a generic idol for backward compatibility
            self.idols.append({'tribe_beach': getattr(self, 'tribe', 'Unknown'), 'found_day': 1})
            self.idol_count = 1
        elif not value:
            self.idols = []
            self.idol_count = 0
    
    def add_information(self, info_type: str, subject: 'Contestant', target: Optional['Contestant'] = None, source: Optional['Contestant'] = None) -> None:
        """Add a piece of information to the information bank.
        
        info_type can be: 'has_idol', 'alliance', 'vote_target', 'target_roster', 'vote_pitch', 'previous_vote', 'final_2', 'final_2_pitch', 'has_final_2'
        """
        # NPCs should not add false information about their own targets/votes
        if not self.is_player and subject == self:
            if info_type in ['target_roster', 'vote_target']:
                return  # NPCs know their own targets, don't accept false info about them
        
        # Check for contradictory information before adding
        if info_type == 'has_idol' and subject != self:
            # Need to check if this contradicts what we know about idol availability
            # For now, we need access to game state to determine this properly
            # This will be enhanced when we have access to the Game object
            pass
        
        # Check if this information already exists
        for info in self.information_bank:
            if info['type'] == info_type and info.get('subject') == subject:
                if info_type == 'has_idol':
                    return  # Already know this
                elif info_type in ['alliance', 'vote_target', 'vote_pitch', 'previous_vote'] and info.get('target') == target:
                    return  # Already know this
        
        # Add new information with timestamp
        info_entry = {
            'type': info_type,
            'subject': subject,
            'day': None  # Will be set by the game
        }
        
        if target:
            info_entry['target'] = target
            
        self.information_bank.append(info_entry)
        
        # Check if adding this vote_target information reveals a consensus vote
        if info_type == 'vote_target':
            self.check_for_consensus_vote_discovery()
        
        # React to learning about consensus votes
        if not self.is_player and info_type == 'consensus_vote':
            self.react_to_consensus_vote_discovery(source=source)
        
        # Counter-targeting: If an NPC learns someone is voting for them or pitched them, they should react
        if not self.is_player and (info_type == 'vote_target' or info_type == 'vote_pitch') and target == self:
            # This NPC just learned that 'subject' is planning to vote for them or pitched them as a target
            self.react_to_being_targeted(subject)
        
        # Check for Final 2 betrayal detection (this will need game context)
        # For now, we'll handle this in the Game class methods that add information
    
    def react_to_consensus_vote_discovery(self, source: Optional['Contestant'] = None) -> None:
        """React to learning about a consensus vote by deciding whether to join it.
        
        Args:
            source: The contestant who shared this information (if known)
        """
        # Find the most recent consensus vote information
        latest_consensus = None
        for info in reversed(self.information_bank):
            if info['type'] == 'consensus_vote' and 'targets' in info:
                latest_consensus = info
                break
        
        if not latest_consensus or not latest_consensus.get('targets'):
            return
        
        # Check if any of the consensus targets are already our vote target
        consensus_targets = latest_consensus['targets']
        if self.vote_target in consensus_targets:
            return  # Already voting for consensus target
        
        # Get the primary consensus target (first in list)
        consensus_target = consensus_targets[0]
        
        # Decide whether to join the consensus
        # Base: 4 YES slips, 2 NO slips
        yes_slips = 4
        no_slips = 2
        
        # Apply modifiers for YES slips
        # +1 if they learned the consensus vote from an ally
        if source and source in self.alliance_roster:
            yes_slips += 1
        
        # +1 if they have a relationship ranking of -1 with the consensus vote
        if self.get_relationship(consensus_target) == -1:
            yes_slips += 1
        
        # +1 if they know consensus vote has idol AND they have game security 7+
        knows_consensus_has_idol = False
        for info in self.information_bank:
            if info['type'] == 'has_idol' and info.get('subject') == consensus_target:
                knows_consensus_has_idol = True
                break
        
        current_game_security = getattr(self, 'base_game_security', 5)  # Default to 5 if not set
        if knows_consensus_has_idol and current_game_security >= 7:
            yes_slips += 1
        
        # -1 if they have relationship ranking of 2 or higher with consensus vote
        if self.get_relationship(consensus_target) >= 2:
            yes_slips = max(0, yes_slips - 1)
        
        # -2 if they are in an alliance with the consensus vote
        if consensus_target in self.alliance_roster:
            yes_slips = max(0, yes_slips - 2)
        
        # -3 if they are in a final 2 with the consensus vote
        if self.final_2_deal == consensus_target:
            yes_slips = max(0, yes_slips - 3)
        
        # Apply modifiers for NO slips
        # Remove all NO slips if they have game security of 3 or lower
        if current_game_security <= 3:
            no_slips = 0
        
        # Draw from hat
        total_slips = yes_slips + no_slips
        draw = random.randint(1, total_slips)
        
        if draw <= yes_slips:
            # Join the consensus - change vote target to first consensus target
            # Prevent self-targeting
            if consensus_target != self:
                self.vote_target = consensus_target
            # Note: This reaction happens silently behind the scenes
        # If NO, keep current vote target unchanged
        
    
    def react_to_being_targeted(self, attacker: 'Contestant') -> None:
        """React when an NPC learns someone is planning to vote for them."""
        # Move current vote target to target roster (if any)
        if self.vote_target and self.vote_target != attacker:
            if self.vote_target not in self.target_roster:
                self.target_roster.append(self.vote_target)
        
        # Set the attacker as new vote target (prevent self-targeting)
        if attacker != self:
            self.vote_target = attacker
            
            # Add attacker to target roster if not already there
            if attacker not in self.target_roster:
                self.target_roster.append(attacker)
        
        # Set a flag to prioritize pitching this target to others
        if not hasattr(self, 'priority_vote_pitch_target'):
            self.priority_vote_pitch_target = None
        self.priority_vote_pitch_target = attacker
    
    def check_for_consensus_vote_discovery(self) -> None:
        """Check if this contestant has learned about a majority consensus vote and add consensus info if so.
        This method will be called by the Game class with proper context."""
        # The actual implementation will be in the Game class method that has access to tribe info
        pass
    
    def clean_duplicate_group_alliances(self) -> None:
        """Remove duplicate group alliance entries from information bank and convert 2-person group alliances to regular alliances."""
        if not self.is_player:
            return  # Only clean player's information bank
        
        seen_alliances = []
        seen_two_person_alliances = {}  # Track 2-person alliances: {target: (day, index)}
        indices_to_remove = []
        alliances_to_add = []
        
        # First pass: identify all 2-person alliances
        for i, info in enumerate(self.information_bank):
            if info['type'] == 'alliance' and info.get('subject') == self and 'target' in info:
                target = info['target']
                if target in seen_two_person_alliances:
                    # Keep the earlier one
                    existing_day, existing_idx = seen_two_person_alliances[target]
                    if (info['day'] or 0) < existing_day:
                        # This one is earlier, remove the existing one
                        indices_to_remove.append(existing_idx)
                        seen_two_person_alliances[target] = (info['day'] or 0, i)
                    else:
                        # Existing one is earlier, remove this one
                        indices_to_remove.append(i)
                else:
                    seen_two_person_alliances[target] = (info['day'] or 0, i)
        
        # Second pass: handle group alliances
        for i, info in enumerate(self.information_bank):
            if info['type'] == 'group_alliance' and 'members' in info:
                active_members = [m for m in info['members'] if hasattr(m, 'name') and not m.eliminated]
                
                # If only 1 member remains (2 people total including player), convert to regular alliance
                if len(active_members) == 1:
                    member = active_members[0]
                    
                    # Check if we already have this alliance
                    if member in seen_two_person_alliances:
                        # Already have a 2-person alliance with this person, just remove the group alliance
                        indices_to_remove.append(i)
                    else:
                        # Convert to regular alliance
                        alliances_to_add.append({
                            'type': 'alliance',
                            'subject': self,
                            'target': member,
                            'day': info['day']
                        })
                        # Mark this group alliance for removal
                        indices_to_remove.append(i)
                    continue
                
                # For group alliances with 2+ members, check for duplicates
                member_set = frozenset([m.name for m in active_members])
                
                # Check if we've seen this exact alliance before
                found_duplicate = False
                for j, (seen_set, seen_day, seen_idx) in enumerate(seen_alliances):
                    if member_set == seen_set:
                        # Keep the earlier entry, remove this one
                        if (info['day'] or 0) > seen_day:
                            indices_to_remove.append(i)
                        else:
                            # This entry is earlier, remove the previous one
                            indices_to_remove.append(seen_idx)
                            seen_alliances[j] = (member_set, info['day'] or 0, i)
                        found_duplicate = True
                        break
                
                if not found_duplicate:
                    seen_alliances.append((member_set, info['day'] or 0, i))
        
        # Remove marked entries in reverse order to maintain indices
        for idx in sorted(set(indices_to_remove), reverse=True):
            if idx < len(self.information_bank):
                self.information_bank.pop(idx)
        
        # Add converted alliances
        for alliance in alliances_to_add:
            self.information_bank.append(alliance)

    def should_search_for_idol(self, game) -> bool:
        """Determine if this NPC should search for an idol today based on strategic factors."""
        # Check if there's even an idol to find
        if game.merged:
            if game.idol_found_merge:
                return False  # No idol available
        else:
            if (self.tribe == game.tribe1_name and game.idol_found_tribe1) or \
               (self.tribe == game.tribe2_name and game.idol_found_tribe2):
                return False  # No idol available for this tribe
        
        # Strategic factors that increase search likelihood
        search_chance = 10  # Base 10% chance
        
        # Increase chance if vulnerable (low vote protection, on target rosters)
        if self.vote_protection < 10:
            search_chance += 15
        
        # Increase chance if threatened (high threat level or negative relationships)
        if self.threat_level >= 7:
            search_chance += 10
        
        # Increase chance if approaching tribal council
        if game.player_tribe_has_tribal and self.tribe == game.get_player_tribe_name():
            search_chance += 20
        
        # Increase chance if few allies
        real_allies = len([c for c in self.alliance_roster if not c.eliminated])
        if real_allies == 0:
            search_chance += 15
        elif real_allies == 1:
            search_chance += 10
        
        # Personality-based modifiers
        if "Resourceful" in [self.positive_attribute, self.neutral_attribute]:
            search_chance += 5
        
        # Cap at 80% maximum
        search_chance = min(search_chance, 80)
        
        # Roll for decision
        roll = random.randint(1, 100)
        return roll <= search_chance
    
    def get_information_text(self, info: Dict) -> str:
        """Convert an information entry to readable text."""
        if info['type'] == 'has_idol':
            if info.get('subject') == self:
                if self.idol_count > 1:
                    return f"You have {self.idol_count} idols"
                else:
                    return "You have an idol"
            # For other contestants, we don't know exact count from info
            return f"{info.get('subject').name} has an idol"
        elif info['type'] == 'alliance':
            # Safety check for corrupted alliance info where target might be a list
            if hasattr(info['target'], 'name'):
                if info.get('subject') == self:
                    return f"You are in an alliance with {info['target'].name}"
                return f"{info.get('subject').name} is in an alliance with {info['target'].name}"
            else:
                # Handle corrupted alliance info (likely from old group alliances)
                if isinstance(info['target'], list):
                    if len(info['target']) > 1:
                        names = [t.name for t in info['target'] if hasattr(t, 'name')]
                        if info.get('subject') == self:
                            return f"You are in a group alliance with {', '.join(names)}"
                        return f"{info.get('subject').name} is in a group alliance with {', '.join(names)}"
                # Fallback for other corrupted data
                return "Alliance information (corrupted)"
        elif info['type'] == 'vote_target':
            if info.get('subject') == self:
                return f"You are planning on voting for {info['target'].name} at the next tribal council"
            return f"{info.get('subject').name} is planning on voting for {info['target'].name} at the next tribal council"
        elif info['type'] == 'vote_pitch':
            if info.get('subject') == self:
                return f"You pitched {info['target'].name} as a vote target"
            return f"{info.get('subject').name} pitched {info['target'].name} as a vote target"
        elif info['type'] == 'previous_vote':
            if info.get('subject') == self:
                return f"You voted for {info['target'].name} at the last tribal council"
            return f"{info.get('subject').name} voted for {info['target'].name} at the last tribal council"
        elif info['type'] == 'target_roster':
            # Handle target roster information - 'targets' is a list
            if 'targets' in info and info['targets']:
                target_names = [t.name for t in info['targets']]
                if info.get('subject') == self:
                    return f"You want to eliminate {' and '.join(target_names)}"
                return f"{info.get('subject').name} wants to eliminate {' and '.join(target_names)}"
            else:
                # Fallback for empty target roster
                if info.get('subject') == self:
                    return "You don't have anyone specific you want to eliminate"
                return f"{info.get('subject').name} doesn't have specific elimination targets"
        elif info['type'] == 'final_2':
            if info.get('subject') == self:
                return f"You have a final 2 deal with {info['target'].name}"
            return f"{info.get('subject').name} has a final 2 deal with {info['target'].name}"
        elif info['type'] == 'final_2_pitch':
            if info.get('subject') == self:
                return f"You pitched a final 2 deal to {info['target'].name}"
            return f"{info.get('subject').name} pitched a final 2 deal to {info['target'].name}"
        elif info['type'] == 'has_final_2':
            return f"{info.get('subject').name} has a final 2 deal with someone"
        elif info['type'] == 'consensus_vote':
            if 'targets' in info and info['targets']:
                if len(info['targets']) == 1:
                    return f"{info['targets'][0].name} is getting voted out next"
                else:
                    target_names = [t.name for t in info['targets']]
                    return f"{' and '.join(target_names)} are tied for getting voted out next"
            return "Someone is getting voted out next"  # Fallback
        elif info['type'] == 'group_alliance':
            # Handle group alliance information
            if 'members' in info and info['members']:
                active_members = [m for m in info['members'] if hasattr(m, 'name') and not m.eliminated]
                if active_members:
                    member_names = ', '.join([m.name for m in active_members])
                    if info.get('subject') == self:
                        return f"You are in a group alliance with {member_names}"
                    return f"{info.get('subject').name} is in a group alliance with {member_names}"
            # Return generic message for corrupted/empty group alliance entries
            return "Group alliance information (no active members)"
        elif info['type'] == 'alliance_departure':
            if info.get('subject') == self:
                return f"You left a group alliance"
            return f"{info.get('subject').name} left a group alliance"
        else:
            # For debugging - this shouldn't happen in normal gameplay
            info_type = info.get('type', 'MISSING_TYPE')
            return f"Unknown information type: {info_type}"
    
    def get_information_text_for_speaking(self, info: Dict, listener=None) -> str:
        """Get formatted text for a piece of information when speaking to another contestant.
        
        Args:
            info: The information dictionary to convert to text
            listener: The contestant who will hear this information (used for filtering)
        """
        if info['type'] == 'has_idol':
            if info.get('subject') == self:
                if self.idol_count > 1:
                    return f"I have {self.idol_count} idols"
                else:
                    return "I have an idol"
            # For other contestants, we don't know exact count from info
            return f"{info.get('subject').name} has an idol"
        elif info['type'] == 'alliance':
            if info.get('subject') == self:
                return f"I am in an alliance with {info['target'].name}"
            return f"{info.get('subject').name} is in an alliance with {info['target'].name}"
        elif info['type'] == 'vote_target':
            if info.get('subject') == self:
                return f"I am planning on voting for {info['target'].name} at the next tribal council"
            # Check if the target is the listener (player)
            if listener and info['target'] == listener:
                return f"{info.get('subject').name} is planning on voting for you at the next tribal council"
            return f"{info.get('subject').name} is planning on voting for {info['target'].name} at the next tribal council"
        elif info['type'] == 'vote_pitch':
            if info.get('subject') == self:
                return f"I pitched {info['target'].name} as a vote target"
            # Check if the target is the listener (player)
            if listener and info['target'] == listener:
                return f"{info.get('subject').name} pitched you as a vote target"
            return f"{info.get('subject').name} pitched {info['target'].name} as a vote target"
        elif info['type'] == 'previous_vote':
            if info.get('subject') == self:
                return f"I voted for {info['target'].name} at the last tribal council"
            elif info['target'] == self:
                return f"{info.get('subject').name} voted for me at the last tribal council"
            return f"{info.get('subject').name} voted for {info['target'].name} at the last tribal council"
        elif info['type'] == 'target_roster':
            # Handle target roster information - 'targets' is a list
            if 'targets' in info and info['targets']:
                # Filter out the listener from targets - NPCs shouldn't reveal they want to eliminate the player they're talking to
                filtered_targets = info['targets']
                if listener is not None:
                    filtered_targets = [t for t in info['targets'] if t != listener]
                
                if filtered_targets:
                    target_names = [t.name for t in filtered_targets]
                    if info.get('subject') == self:
                        return f"I want to eliminate {' and '.join(target_names)}"
                    return f"{info.get('subject').name} wants to eliminate {' and '.join(target_names)}"
                else:
                    # All targets were filtered out (listener was the only target)
                    if info.get('subject') == self:
                        return "I don't have anyone specific I want to eliminate"
                    return f"{info.get('subject').name} doesn't have specific elimination targets"
            else:
                # Fallback for empty target roster
                if info.get('subject') == self:
                    return "I don't have anyone specific I want to eliminate"
                return f"{info.get('subject').name} doesn't have specific elimination targets"
        elif info['type'] == 'final_2':
            if info.get('subject') == self:
                return f"I have a final 2 deal with {info['target'].name}"
            # Check if either subject or target is the listener (player)
            if listener and info.get('subject') == listener:
                return f"You have a final 2 deal with {info['target'].name}"
            elif listener and info['target'] == listener:
                return f"{info.get('subject').name} has a final 2 deal with you"
            return f"{info.get('subject').name} has a final 2 deal with {info['target'].name}"
        elif info['type'] == 'final_2_pitch':
            if info.get('subject') == self:
                return f"I pitched a final 2 deal to {info['target'].name}"
            # Check if the target is the listener (player)
            if listener and info['target'] == listener:
                return f"{info.get('subject').name} pitched a final 2 deal to you"
            return f"{info.get('subject').name} pitched a final 2 deal to {info['target'].name}"
        elif info['type'] == 'has_final_2':
            return f"{info.get('subject').name} has a final 2 deal with someone"
        elif info['type'] == 'consensus_vote':
            if 'targets' in info and info['targets']:
                if len(info['targets']) == 1:
                    return f"{info['targets'][0].name} is getting voted out next"
                else:
                    target_names = [t.name for t in info['targets']]
                    return f"{' and '.join(target_names)} are tied for getting voted out next"
            elif 'target' in info and info['target']:
                # Handle legacy single target format
                return f"{info['target'].name} is getting voted out next"
            return "Someone is getting voted out next"
        elif info['type'] == 'alliance_departure':
            if info.get('subject') == self:
                return f"I left our group alliance"
            return f"{info.get('subject').name} left our group alliance"
        elif info['type'] == 'alliance_dissolved':
            return f"Our group alliance was dissolved"
        elif info['type'] == 'alliance_broken':
            if info.get('subject') == self:
                return f"My alliance with {info['target'].name} was broken"
            return f"My alliance with {info.get('subject').name} was broken"
        elif info['type'] == 'group_alliance':
            # Handle group alliance information
            if 'members' in info and info['members']:
                active_members = [m for m in info['members'] if hasattr(m, 'name')]
                if active_members:
                    member_names = ', '.join([m.name for m in active_members])
                    if info.get('subject') == self:
                        return f"I am in a group alliance with {member_names}"
                    return f"{info.get('subject').name} is in a group alliance with {member_names}"
            return "Group alliance information"
        else:
            # For debugging - this shouldn't happen in normal gameplay
            info_type = info.get('type', 'MISSING_TYPE')
            return f"Unknown information type: {info_type}"
    
    def determine_leaning_jury_vote(self, finalists: List['Contestant'], game: 'Game') -> 'Contestant':
        """
        Determine this juror's initial leaning vote for final tribal council.
        
        Each juror rolls a d20 for each finalist with various modifiers.
        The finalist with the highest total becomes the leaning jury vote.
        
        Args:
            finalists: List of contestants in the final tribal council
            game: Game instance for accessing voting history and other data
            
        Returns:
            The contestant this juror is leaning towards voting for
        """
        if not finalists:
            raise ValueError("No finalists provided")
            
        results = {}
        
        for finalist in finalists:
            # Base d20 roll
            base_roll = random.randint(1, 20)
            
            # Handle critical success/failure (natural 20/1 ignore modifiers)
            if base_roll == 20:
                roll = 20  # Critical success
                modifiers = 0
                modifier_details = ["Critical Success (Natural 20)"]
            elif base_roll == 1:
                roll = 1   # Critical failure
                modifiers = 0
                modifier_details = ["Critical Failure (Natural 1)"]
            else:
                # Normal roll with modifiers
                roll = base_roll
                modifiers = 0
                modifier_details = []
                
                # Add survival status modifiers
                if self.survival_status == 3:
                    modifiers += 1
                    modifier_details.append("Survival Status 3 (+1)")
                elif self.survival_status == -1:
                    modifiers -= 1
                    modifier_details.append("Survival Status -1 (-1)")
                
                # +1 if juror was in alliance with finalist
                if self.believes_has_alliance_with(finalist, game):
                    modifiers += 1
                    modifier_details.append("Alliance (+1)")
                
                # Relationship modifiers
                relationship = self.get_relationship(finalist)
                if relationship == 2:
                    modifiers += 1
                    modifier_details.append("Relationship 2 (+1)")
                elif relationship == 3:
                    modifiers += 2
                    modifier_details.append("Relationship 3 (+2)")
                elif relationship == -1:
                    modifiers -= 1
                    modifier_details.append("Relationship -1 (-1)")
                
                # -1 if juror was voted out by finalist
                if self._was_voted_out_by(finalist, game):
                    modifiers -= 1
                    modifier_details.append("Voted out by finalist (-1)")
                    
                    # Additional -1 if juror has Vengeful attribute
                    if self._has_vengeful_attribute():
                        modifiers -= 1
                        modifier_details.append("Vengeful attribute (-1)")
                
                # +1 if juror was on same starting tribe with finalist
                if self._was_same_starting_tribe(finalist, game):
                    modifiers += 1
                    modifier_details.append("Same starting tribe (+1)")
                
                # +2 if juror and finalist were in final 2 alliance AND finalist didn't vote out juror
                if (self.believes_has_final_2_with(finalist) and 
                    not self._was_voted_out_by(finalist, game)):
                    modifiers += 2
                    modifier_details.append("Final 2 alliance (+2)")
                
                # -1 if either contestant got "Busted Lvl 3" by the other
                if self._had_busted_lvl_3_interaction(finalist, game):
                    modifiers -= 1
                    modifier_details.append("Busted Lvl 3 interaction (-1)")
            
            total = roll + modifiers
            results[finalist] = {
                'roll': roll,
                'modifiers': modifiers,
                'total': total,
                'details': modifier_details
            }
            
            # Optional debugging output
            if hasattr(game, 'debug_jury_voting') and game.debug_jury_voting:
                print(f"  {finalist.name}: Roll={roll}, Modifiers={modifiers} ({', '.join(modifier_details)}), Total={total}")
        
        # Find finalist(s) with highest total
        max_total = max(result['total'] for result in results.values())
        tied_finalists = [f for f, r in results.items() if r['total'] == max_total]
        
        if len(tied_finalists) == 1:
            return tied_finalists[0]
        
        # Tie-breaking: highest relationship value
        max_relationship = max(self.get_relationship(f) for f in tied_finalists)
        tied_after_relationship = [f for f in tied_finalists 
                                 if self.get_relationship(f) == max_relationship]
        
        if len(tied_after_relationship) == 1:
            return tied_after_relationship[0]
        
        # Final tie-breaking: random choice
        return random.choice(tied_after_relationship)
    
    def _was_voted_out_by(self, contestant: 'Contestant', game: 'Game') -> bool:
        """Check if this juror was voted out by the given contestant."""
        if not hasattr(game, 'vote_history') or contestant not in game.vote_history:
            return False
        
        # Check if the contestant voted for this juror when this juror was eliminated
        votes_cast = game.vote_history[contestant]
        return self in votes_cast
    
    def _has_vengeful_attribute(self) -> bool:
        """Check if this contestant has the Vengeful attribute."""
        return (self.positive_attribute == "Vengeful" or 
                self.neutral_attribute == "Vengeful" or 
                self.negative_attribute == "Vengeful")
    
    def _was_same_starting_tribe(self, contestant: 'Contestant', game: 'Game') -> bool:
        """Check if this juror and contestant were on the same starting tribe."""
        # This assumes the original tribe assignment is preserved in contestant.tribe
        # and that merge tribe name is different from starting tribe names
        if not hasattr(game, 'merge_tribe_name'):
            return False
            
        # Both should have non-merge tribe names and they should match
        return (self.tribe != game.merge_tribe_name and 
                contestant.tribe != game.merge_tribe_name and
                self.tribe == contestant.tribe)
    
    def _had_busted_lvl_3_interaction(self, contestant: 'Contestant', game: 'Game') -> bool:
        """Check if either contestant got 'Busted Lvl 3' by the other."""
        # This would need to be implemented based on how confrontation/busting
        # mechanics are tracked in the game. For now, returning False as placeholder.
        # TODO: Implement based on actual busting mechanics in the game
        return False

class Game:
    def __init__(self):
        self.day = 1
        self.contestants = []
        self.eliminated_contestants = []
        self.revealed_eliminations = []  # Track which eliminations have been revealed by Jeff
        self.jury = []
        self.merged = False
        self.merge_day = 23
        self.player = None
        self.player_vote_target_eliminated = False  # Track when player's vote target is eliminated
        
        # Tribe names pool
        self.tribe_names_pool = [
            "Tagi", "Samburu", "Rotu", "Jaburu", "Lopevi", "Casaya", 
            "Dabu", "Timbira", "Zapatera", "Savaii", "Matsing", "Tambaqui",
            "Saboga", "Forza", "Foa Foa", "Tandang", "Pagong", "Kucha",
            "Ogakor", "Barramundi", "Rattana", "Maraamu", "Chapera", "Mogo Mogo",
            "Yasur", "Ulong", "Koror", "La Mina", "Jalapao", "Galu",
            "Ometepe", "Upolu", "Kalabaw", "Hunahpu", "Coyopa"
        ]
        
        # Randomly select tribe names
        selected_names = random.sample(self.tribe_names_pool, 3)  # 2 starting tribes + 1 merge
        self.tribe1_name = selected_names[0]
        self.tribe2_name = selected_names[1]
        self.merge_tribe_name = selected_names[2]
        
        # Initialize tribe lists
        self.tribe1 = []
        self.tribe2 = []
        self.merged_tribe = []
        
        # Track idol status by tribe
        self.idol_found_tribe1 = False
        self.idol_found_tribe2 = False
        self.idol_found_merge = False  # Track post-merge idols
        
        self.final_day = 39
        self.idol_finder_history = {}  # Track who found idols and when
        self.npcs_wanting_to_search = []  # Track which NPCs want to search for idols today
        self.player_searched_today = False  # Track if player searched for idol today
        self.npc_action_history = {}  # Track NPC actions by day: {day: [(contestant, action, outcome), ...]
        self.most_recent_votes = {}  # Track most recent vote by each contestant: {contestant: (target, day)}
        self.vote_history = {}  # Track all votes by each contestant: {contestant: [targets]}
        self.today_npc_actions = {}  # Track today's NPC actions for snooping: {contestant: (action_type, target, outcome)}
        self.today_idol_searches = {}  # Track today's idol searches separately: {contestant: outcome}
        self.contestants_who_interacted_with_player = []  # Track who interacted with player today
        self.vote_pitch_history = {}  # Track successful vote pitches: {recipient: [(pitcher, target, roll, day), ...]}
        self.npcs_needing_betrayal_confrontation = []  # Track NPCs who need to confront player about Final 2 betrayal
        self.last_tribal_vote_counts = {}  # Track votes received at last tribal: {contestant: vote_count}
        self.group_alliances = {}  # Track group alliances: {alliance_id: {'members': [contestants], 'formed_day': day, 'pitcher': contestant}}
        self.next_group_alliance_id = 1  # Counter for unique group alliance IDs
        
        # Action tracking
        self.max_actions_per_day = 3
        self.actions_taken_today = 0
        self.npc_action_round = 0  # Track which NPC action round we're in (1 or 2)
        self.max_npc_actions_per_day = 2  # NPCs get 2 actions per day
        
        # Elimination orchestration tracking
        self.cycle_first_pitch_tracker = {}  # Track first person to pitch each target this cycle: {target: pitcher}
        self.cycle_successful_pitch_counts = {}  # Track successful pitches per pitcher this cycle: {pitcher: {target: count}}
        self.cycle_start_day = 1  # Track when current cycle started
        
        # Immunity challenge tracking
        self.immunity_challenges_held = 0  # Track total number of immunity challenges
        self.individual_immunity_challenges_held = 0  # Track number of individual immunity challenges
        self.previous_immunity_winner = None  # Track which tribe/contestant won the previous challenge
        self.used_individual_challenge_indices = []  # Track which individual challenge descriptions have been used
        self.used_premerge_challenge_indices = []  # Track which pre-merge challenge descriptions have been used
        
        # Jury spectator mode
        self.player_is_jury_spectator = False  # Track if eliminated player continues as jury spectator
        
    def roll_d20(self, contestant: Contestant = None, modifier: int = 0) -> int:
        """Roll a d20 with critical success/failure and survival status modifiers.
        
        Args:
            contestant: The contestant making the roll (for survival status modifiers)
            modifier: Additional modifier to apply
            
        Returns:
            The total roll result
        """
        base_roll = random.randint(1, 20)
        
        # Handle critical success/failure (natural 20/1 ignore modifiers)
        if base_roll == 20:
            return 20  # Critical success
        elif base_roll == 1:
            return 1   # Critical failure
        else:
            # Normal roll with modifiers
            total = base_roll + modifier
            
            # Add survival status modifiers if contestant provided
            if contestant:
                if contestant.survival_status == 3:
                    total += 1
                elif contestant.survival_status == -1:
                    total -= 1
            
            return total
    
    def get_roll_outcome(self, roll_total: int) -> str:
        """Determine the outcome category based on roll total.
        
        Returns one of: 'critical_failure', 'failure', 'neutral', 'success', 'critical_success'
        """
        if roll_total <= 1:
            return "critical_failure"
        elif 2 <= roll_total <= 7:
            return "failure"
        elif 8 <= roll_total <= 13:
            return "neutral"
        elif 14 <= roll_total <= 19:
            return "success"
        else:  # roll_total >= 20
            return "critical_success"
    
    def roll_with_skill(self, skill_value: int = 0, description: str = "", show_details: bool = False) -> Tuple[int, int, str]:
        """Roll a d20 with skill modifier and return (base_roll, total, outcome).
        
        Skills are not added if the base roll is 1 or 20 (to ensure critical failures/successes are always possible).
        
        Args:
            skill_value: The skill modifier to add to the roll
            description: Optional description of what the roll is for
            show_details: Whether to print roll details (default: False)
            
        Returns:
            Tuple of (base_roll, total, outcome_category)
        """
        base_roll = random.randint(1, 20)
        
        # Don't add skill modifier on natural 1 or 20
        if base_roll == 1 or base_roll == 20:
            total = base_roll
            skill_applied = 0
        else:
            total = base_roll + skill_value
            skill_applied = skill_value
        
        outcome = self.get_roll_outcome(total)
        
        # Optional: Print roll details for debugging/transparency
        if description and show_details:
            if skill_applied != skill_value:
                print(f"\n[{description}] Roll: {base_roll} (natural {base_roll}, no skill modifier) = {total} ({outcome})")
            else:
                print(f"\n[{description}] Roll: {base_roll} + {skill_applied} skill = {total} ({outcome})")
        
        return base_roll, total, outcome
    
    def record_npc_action(self, npc: Contestant, action: str, outcome: str) -> None:
        """Record an NPC action in the history."""
        if self.day not in self.npc_action_history:
            self.npc_action_history[self.day] = []
        self.npc_action_history[self.day].append((npc, action, outcome))
        
        # Also store in today's actions for snooping
        # Parse the action to get action type and target
        action_type = None
        target = None
        
        if "Small Talk with" in action:
            action_type = "small_talk"
            if "Small Talk with player" in action:
                target = self.player
            else:
                target_name = action.split("Small Talk with ")[-1]
                target = next((c for c in self.contestants if c.name == target_name), None)
        elif "Pitch Alliance to" in action:
            action_type = "pitch_alliance"
            if "Pitch Alliance to player" in action:
                target = self.player
            else:
                target_name = action.split("Pitch Alliance to ")[-1]
                target = next((c for c in self.contestants if c.name == target_name), None)
        elif "Pitch Vote Target" in action:
            action_type = "pitch_vote"
            # Extract target from the parentheses
            import re
            if "to player" in action:
                target = self.player
            else:
                match = re.search(r'to ([A-Za-z ]+)$', action)
                if match:
                    target_name = match.group(1).strip()
                    target = next((c for c in self.contestants if c.name == target_name), None)
        elif "Bluff to" in action:
            action_type = "bluff"
            if "Bluff to player" in action:
                target = self.player
            else:
                target_name = action.split("Bluff to ")[-1]
                target = next((c for c in self.contestants if c.name == target_name), None)
        elif "Work Around Camp" in action:
            action_type = "work"
            target = None
        elif "Reveal to" in action:
            action_type = "reveal"
            if "Reveal to player" in action:
                target = self.player
            else:
                target_name = action.split("Reveal to ")[-1]
                target = next((c for c in self.contestants if c.name == target_name), None)
        elif "Probe" in action:
            action_type = "probe"
            if "Probe player" in action:
                target = self.player
            else:
                # Try to extract target name after "Probe "
                if "Probe " in action:
                    target_name = action.split("Probe ")[-1]
                    target = next((c for c in self.contestants if c.name == target_name), None)
        
        if action_type:
            self.today_npc_actions[npc] = (action_type, target, outcome)
    
    def roll_resistance_to_persuasion(self, defender: Contestant, show_details: bool = False) -> int:
        """Roll resistance to persuasion for a contestant and return the modifier to apply to the pitch roll.
        
        Returns:
            int: The modifier to apply to the opposing pitch roll (-2, -1, 0, +1, or +2)
        """
        # Roll d20 + resistance_to_persuasion skill
        base_roll, total, outcome = self.roll_with_skill(
            defender.resistance_to_persuasion, 
            f"{defender.name}'s resistance roll",
            show_details
        )
        
        # Apply outcomes based on the resistance roll
        if outcome == "critical_failure":
            return 2  # +2 to opposing pitch roll
        elif outcome == "failure":
            return 1  # +1 to opposing pitch roll
        elif outcome == "neutral":
            return 0  # No change to opposing pitch roll
        elif outcome == "success":
            return -1  # -1 to opposing pitch roll
        else:  # critical_success
            return -2  # -2 to opposing pitch roll
    
    def add_player_information(self, info_type: str, subject: Contestant, target: Optional[Contestant] = None) -> None:
        """Add information to the player's information bank with current day."""
        # Check for contradictory idol information before adding
        if info_type == 'has_idol' and subject != self.player:
            # Player should be smart enough to know if someone else can't have an idol
            if self.merged:
                # Post-merge: Only one merge idol exists
                if self.player.idol_count > 0 and self.idol_found_merge:
                    return  # Player knows they have the only post-merge idol
            else:
                # Pre-merge: One idol per tribe
                if self.player.tribe == subject.tribe and self.player.idol_count > 0:
                    # Same tribe and player has idol - subject can't have one too
                    if (self.player.tribe == self.tribe1_name and self.idol_found_tribe1) or \
                       (self.player.tribe == self.tribe2_name and self.idol_found_tribe2):
                        return  # Player knows they have their tribe's idol
        
        # Add the information
        self.player.add_information(info_type, subject, target)
        
        # Update the day for the most recent information
        if self.player.information_bank:
            self.player.information_bank[-1]['day'] = self.day
        
        # Check for various information conflicts
        if info_type == 'has_idol':
            self.resolve_idol_conflicts(self.player)
        elif info_type == 'vote_target':
            self.resolve_vote_target_conflicts(self.player)
            self.check_consensus_vote_discovery(self.player)
        elif info_type == 'previous_vote':
            self.resolve_previous_vote_conflicts(self.player)
        elif info_type == 'consensus_vote':
            self.resolve_consensus_vote_conflicts(self.player)
        
        # Check for Final 2 betrayal detection
        if info_type == 'final_2':
            self.check_for_final_2_betrayal(self.player, subject, target)
    
    def check_for_final_2_betrayal(self, learner: Contestant, subject: Contestant, target: Contestant) -> None:
        """Check if learning about a Final 2 deal reveals betrayal and apply consequences."""
        # Only proceed if the learner has a Final 2 deal themselves
        if not learner.final_2_deal and not learner.fake_final_2_deals:
            return
        
        # Check if the learner is in a Final 2 deal with either subject or target
        betrayer = None
        if learner.has_real_final_2_with(subject) or learner.has_fake_final_2_with(subject):
            # Learner has a Final 2 with subject, and just learned subject also has one with target
            betrayer = subject
        elif learner.has_real_final_2_with(target) or learner.has_fake_final_2_with(target):
            # Learner has a Final 2 with target, and just learned target also has one with subject  
            betrayer = target
        
        if betrayer:
            # Betrayal detected! Apply consequences
            self.apply_final_2_betrayal_consequences(betrayer, learner)
    
    def apply_final_2_betrayal_consequences(self, betrayer: Contestant, discoverer: Contestant) -> None:
        """Apply consequences when a Final 2 betrayal is discovered."""
        # Get all contestants who had Final 2 deals with the betrayer
        betrayed_contestants = []
        
        # Check real Final 2 deals
        if betrayer.final_2_deal:
            betrayed_contestants.append(betrayer.final_2_deal)
        
        # Check fake Final 2 deals (people who think they have deals with betrayer)
        for contestant in self.contestants:
            if betrayer in contestant.fake_final_2_deals:
                betrayed_contestants.append(contestant)
        
        # Only proceed if there are multiple deals to break
        if len(betrayed_contestants) < 2:
            return
        
        # Apply consequences
        self.narrate_final_2_betrayal_discovery(betrayer, discoverer, betrayed_contestants)
        
        # 1. Break all Final 2 deals
        betrayer.final_2_deal = None
        for contestant in betrayed_contestants:
            if contestant.final_2_deal == betrayer:
                contestant.final_2_deal = None
            if betrayer in contestant.fake_final_2_deals:
                contestant.fake_final_2_deals.remove(betrayer)
        
        # 2. Add betrayer to all former partners' target rosters
        for contestant in betrayed_contestants:
            if betrayer not in contestant.target_roster:
                contestant.target_roster.append(betrayer)
        
        # 3. Increase betrayer's threat level
        betrayer.threat_level = min(10, betrayer.threat_level + 1)
        
        # 4. Apply -2 persuasion penalty with all former Final 2 partners for 3 days
        for contestant in betrayed_contestants:
            betrayer.final_2_betrayal_penalties[contestant] = (-2, self.day + 3)
    
    def narrate_final_2_betrayal_discovery(self, betrayer: Contestant, discoverer: Contestant, betrayed_contestants: List[Contestant]) -> None:
        """Narrate the discovery of Final 2 betrayal."""
        if discoverer.is_player:
            self.narration(f"You realize that {betrayer.name} has been playing multiple people with Final 2 deals!")
            partners_text = ", ".join([c.name for c in betrayed_contestants if c != discoverer])
            if len(betrayed_contestants) > 2:
                self.narration(f"Besides your deal with {betrayer.name}, {betrayer.get_pronoun('subject')} also has deals with {partners_text}.")
            else:
                other_partner = next(c for c in betrayed_contestants if c != discoverer)
                self.narration(f"You had a Final 2 deal with {betrayer.name}, but {betrayer.get_pronoun('subject')} also has one with {other_partner.name}!")
            self.narration(f"This betrayal will have serious consequences for {betrayer.name}.")
        else:
            # NPC discovered it - no narration to player unless they're involved
            if self.player in betrayed_contestants:
                self.narration(f"{discoverer.name} has discovered that {betrayer.name} was playing multiple Final 2 deals.")
                self.narration(f"Your Final 2 deal with {betrayer.name} has been exposed and broken!")
    
    def get_final_2_betrayal_penalty(self, pitcher: Contestant, target: Contestant) -> int:
        """Get the Final 2 betrayal penalty for a pitch."""
        if target in pitcher.final_2_betrayal_penalties:
            penalty_level, day_expires = pitcher.final_2_betrayal_penalties[target]
            if day_expires >= self.day:
                return penalty_level  # Still active
            else:
                # Penalty expired, remove it
                del pitcher.final_2_betrayal_penalties[target]
        return 0
    
    def clean_expired_final_2_betrayal_penalties(self) -> None:
        """Remove expired Final 2 betrayal penalties."""
        for contestant in self.contestants:
            expired_targets = []
            for target, (penalty_level, day_expires) in contestant.final_2_betrayal_penalties.items():
                if day_expires < self.day:
                    expired_targets.append(target)
            for target in expired_targets:
                del contestant.final_2_betrayal_penalties[target]
        
    def slow_print(self, text: str, delay: float = 0.03, width: int = 80) -> None:
        """Print text with a slight delay to simulate typing, with proper word wrapping.
        Press Enter during typing to skip to the end."""
        import textwrap
        import select
        import sys
        
        # Wrap the text to the specified width
        wrapped_lines = textwrap.wrap(text, width=width)
        
        # Track if we should skip the typing animation
        skip_animation = False
        
        # Print each wrapped line with delay
        for i, line in enumerate(wrapped_lines):
            if skip_animation:
                # If skipping, just print the rest immediately
                print(line)
            else:
                for char_index, char in enumerate(line):
                    print(char, end='', flush=True)
                    
                    # Check if Enter was pressed (non-blocking on Unix-like systems)
                    if sys.platform != 'win32':
                        # Unix/Linux/Mac
                        if select.select([sys.stdin], [], [], 0) == ([sys.stdin], [], []):
                            input()  # Consume the input
                            skip_animation = True
                            # Print the rest of the current line immediately
                            remaining_chars = line[char_index+1:]
                            print(remaining_chars, end='')
                            break
                    else:
                        # Windows - use a simpler approach with try/except
                        try:
                            import msvcrt
                            if msvcrt.kbhit():
                                key = msvcrt.getch()
                                if key == b'\r':  # Enter key
                                    skip_animation = True
                                    # Print the rest of the current line immediately
                                    remaining_chars = line[char_index+1:]
                                    print(remaining_chars, end='')
                                    break
                        except ImportError:
                            pass  # Fall back to normal behavior if msvcrt not available
                    
                    if not skip_animation:
                        time.sleep(delay)
            
            # Add newline after each line except potentially the last
            if i < len(wrapped_lines) - 1:
                print()  # New line between wrapped lines
        
        print()  # Final newline
        
    def get_player_name(self) -> str:
        """Get the player's name."""
        self.slow_print("Enter your name: ", 0.02)
        player_input = input()
        if self.check_for_cheat_code(player_input):
            return self.get_player_name()  # Ask again after cheat menu
        return player_input
    
        
    def get_player_character_choice(self):
        """Get player's choice between playing as themselves or an existing contestant."""
        print("\nWould you like to play as yourself or a former Survivor contestant?")
        print("1. Myself")
        print("2. Another Survivor Contestant")
        
        while True:
            choice = input("Enter your choice (1 or 2): ").strip()
            if choice in ['1', '2']:
                return int(choice)
            print("Please enter 1 or 2.")
    
    def get_player_archetype_choice(self):
        """Get player's choice of Hero or Villain archetype."""
        print("\nWhat type of player are you? Are you a Hero or a Villain?")
        print("1. Hero")
        print("2. Villain")
        
        while True:
            choice = input("Enter your choice (1 or 2): ").strip()
            if choice == '1':
                return "Hero"
            elif choice == '2':
                return "Villain"
            print("Please enter 1 or 2.")
    
    def select_survivor_contestant(self, all_npcs):
        """Allow player to select from available Survivor contestants."""
        print("\nAvailable Survivor contestants:")
        print("=" * 50)
        
        # Sort contestants by name for easier browsing
        sorted_contestants = sorted(all_npcs, key=lambda x: x[0])
        
        for i, contestant in enumerate(sorted_contestants, 1):
            name, gender, nickname, *stats = contestant
            print(f"{i:2d}. {name}")
        
        print("=" * 50)
        
        while True:
            try:
                choice = input(f"Select a contestant (1-{len(sorted_contestants)}): ").strip()
                choice_num = int(choice)
                if 1 <= choice_num <= len(sorted_contestants):
                    selected = sorted_contestants[choice_num - 1]
                    name = selected[0]
                    nickname = selected[2]
                    display_name = f"{name} ({nickname})" if nickname != name else name
                    
                    confirm = input(f"You selected {display_name}. Confirm? (y/n): ").strip().lower()
                    if confirm in ['y', 'yes']:
                        return selected
                    # If not confirmed, continue the loop to select again
                else:
                    print(f"Please enter a number between 1 and {len(sorted_contestants)}.")
            except ValueError:
                print("Please enter a valid number.")
    
    def select_contestant_likeness(self, all_npcs):
        """Allow player to select which former Survivor contestant they're most like."""
        print("\nWhich former Survivor contestant do you think you are the most like?")
        print("=" * 60)
        
        # Sort contestants by name for easier browsing
        sorted_contestants = sorted(all_npcs, key=lambda x: x[0])
        
        for i, contestant in enumerate(sorted_contestants, 1):
            name, gender, nickname, *stats = contestant
            print(f"{i:2d}. {name}")
        
        print("=" * 60)
        
        while True:
            try:
                choice = input(f"Select a contestant (1-{len(sorted_contestants)}): ").strip()
                choice_num = int(choice)
                if 1 <= choice_num <= len(sorted_contestants):
                    selected = sorted_contestants[choice_num - 1]
                    name = selected[0]
                    nickname = selected[2]
                    display_name = f"{name} ({nickname})" if nickname != name else name
                    
                    confirm = input(f"You selected {display_name}. Confirm? (y/n): ").strip().lower()
                    if confirm in ['y', 'yes']:
                        return selected
                    # If not confirmed, continue the loop to select again
                else:
                    print(f"Please enter a number between 1 and {len(sorted_contestants)}.")
            except ValueError:
                print("Please enter a valid number.")
    
    def get_opponent_selection_choice(self):
        """Get player's choice between random or hand-selected opponents."""
        print("\nWould you like to play against random contestants or hand select your chosen opponents?")
        print("1. Random Contestants")
        print("2. Hand Choose")
        
        while True:
            choice = input("Enter your choice (1 or 2): ").strip()
            if choice in ['1', '2']:
                return int(choice)
            print("Please enter 1 or 2.")
    
    def hand_select_opponents(self, all_npcs, player_contestant):
        """Allow player to hand-select their opponents and build tribes."""
        available_contestants = all_npcs.copy()
        
        # Tribe 1 - Player's tribe
        print(f"\n{'='*60}")
        print("TRIBE 1")
        print(f"{'='*60}")
        print(f"1. {player_contestant.name} (YOU)")
        
        tribe1_contestants = [player_contestant]
        
        # Player needs to select 9 more contestants for their tribe (10 total)
        for slot in range(2, 11):  # slots 2-10
            print(f"\nAvailable contestants for Tribe 1 (Slot {slot}):")
            print("-" * 50)
            
            # Sort available contestants by name
            sorted_available = sorted(available_contestants, key=lambda x: x[0])
            
            for i, contestant in enumerate(sorted_available, 1):
                name, gender, nickname, *stats = contestant
                print(f"{i:2d}. {name}")
            
            while True:
                try:
                    choice = input(f"Select contestant for slot {slot} (1-{len(sorted_available)}): ").strip()
                    choice_num = int(choice)
                    if 1 <= choice_num <= len(sorted_available):
                        selected = sorted_available[choice_num - 1]
                        name = selected[0]
                        nickname = selected[2]
                        display_name = f"{name} ({nickname})" if nickname != name else name
                        
                        # Create contestant object
                        contestant_data = selected
                        name, gender, nickname, challenge_skill, social_skill, persuasive_skill, perception_skill, strategic_skill, resistance_to_persuasion, survival_skill, hero_or_villain, positive_attribute, neutral_attribute, negative_attribute = contestant_data
                        contestant_obj = Contestant(name, "", gender, False, nickname, challenge_skill, social_skill, persuasive_skill, perception_skill, strategic_skill, resistance_to_persuasion, survival_skill, hero_or_villain, positive_attribute, neutral_attribute, negative_attribute)
                        
                        tribe1_contestants.append(contestant_obj)
                        available_contestants.remove(selected)
                        
                        print(f"Added {display_name} to Tribe 1")
                        break
                    else:
                        print(f"Please enter a number between 1 and {len(sorted_available)}.")
                except ValueError:
                    print("Please enter a valid number.")
        
        # Show Tribe 1 final roster
        print(f"\n{'='*60}")
        print("TRIBE 1 FINAL ROSTER:")
        for i, contestant in enumerate(tribe1_contestants, 1):
            marker = " (YOU)" if contestant.is_player else ""
            print(f"{i:2d}. {contestant.name}{marker}")
        print(f"{'='*60}")
        
        # Tribe 2
        print(f"\n{'='*60}")
        print("TRIBE 2")
        print(f"{'='*60}")
        
        tribe2_contestants = []
        
        # Player selects 10 contestants for tribe 2
        for slot in range(1, 11):  # slots 1-10
            print(f"\nAvailable contestants for Tribe 2 (Slot {slot}):")
            print("-" * 50)
            
            # Sort available contestants by name
            sorted_available = sorted(available_contestants, key=lambda x: x[0])
            
            for i, contestant in enumerate(sorted_available, 1):
                name, gender, nickname, *stats = contestant
                print(f"{i:2d}. {name}")
            
            while True:
                try:
                    choice = input(f"Select contestant for slot {slot} (1-{len(sorted_available)}): ").strip()
                    choice_num = int(choice)
                    if 1 <= choice_num <= len(sorted_available):
                        selected = sorted_available[choice_num - 1]
                        name = selected[0]
                        nickname = selected[2]
                        display_name = f"{name} ({nickname})" if nickname != name else name
                        
                        # Create contestant object
                        contestant_data = selected
                        name, gender, nickname, challenge_skill, social_skill, persuasive_skill, perception_skill, strategic_skill, resistance_to_persuasion, survival_skill, hero_or_villain, positive_attribute, neutral_attribute, negative_attribute = contestant_data
                        contestant_obj = Contestant(name, "", gender, False, nickname, challenge_skill, social_skill, persuasive_skill, perception_skill, strategic_skill, resistance_to_persuasion, survival_skill, hero_or_villain, positive_attribute, neutral_attribute, negative_attribute)
                        
                        tribe2_contestants.append(contestant_obj)
                        available_contestants.remove(selected)
                        
                        print(f"Added {display_name} to Tribe 2")
                        break
                    else:
                        print(f"Please enter a number between 1 and {len(sorted_available)}.")
                except ValueError:
                    print("Please enter a valid number.")
        
        # Show Tribe 2 final roster
        print(f"\n{'='*60}")
        print("TRIBE 2 FINAL ROSTER:")
        for i, contestant in enumerate(tribe2_contestants, 1):
            print(f"{i:2d}. {contestant.name}")
        print(f"{'='*60}")
        
        return tribe1_contestants + tribe2_contestants

    def initialize_game(self) -> None:
        """Initialize the game with contestants and tribes."""
        choice = self.get_player_character_choice()
        
        # All possible contestants with their full data
        # Format: (name, gender, nickname, challenge_skill, social_skill, persuasive_skill, perception_skill, strategic_skill, resistance_to_persuasion, survival_skill, hero_or_villain, positive_attribute, neutral_attribute, negative_attribute)
        all_npcs = [
            ("Richard Hatch", "Male", "Rich", 1, 1, 2, 2, 3, 3, -1, "Villain", "Perceptive", "Big Personality", "Arrogant"),
            ("Malcolm Freberg", "Male", "Malcolm", 2, 3, 1, 2, 2, 2, 2, "Hero", "Charismatic", "Competitive", "Paranoid"),
            ("Stephen Fishbach", "Male", "Stephen", -1, 2, 2, 2, 3, 2, 1, "Villain", "Perceptive", "Secretive", "High Strung"),
            ("Colby Donaldson", "Male", "Colby", 3, 2, 1, -1, 0, 1, 2, "Hero", "Loyal", "Introverted", "Heat-Averse"),
            ("Cirie Fields", "Female", "Cirie", -1, 3, 3, 2, 3, 2, 0, "Villain", "Perceptive", "Secretive", "Paranoid"),
            ("Jenna Morasca", "Female", "Jenna", 2, 2, 1, 1, -1, 0, 1, "Hero", "Hardworking", "Under-the-Radar", "High Strung"),
            ("Denise Stapley", "Female", "Denise", 1, 3, 1, 2, 2, 2, 1, "Hero", "Resilient", "Secretive", "Paranoid"),
            ("Jerri Manthey", "Female", "Jerri", 1, 2, -1, 2, 0, 1, 2, "Villain", "Hardworking", "Vengeful", "High Strung"),
            ("Andrea Boehlke", "Female", "Andrea", 2, 3, 2, 1, 2, 1, 1, "Hero", "Perceptive", "Competitive", "Paranoid"),
            ("Ozzy Lusth", "Male", "Ozzy", 3, 2, 1, -1, 0, 1, 2, "Hero", "Resilient", "Competitive", "Gullible"),
            ("Rupert Boneham", "Male", "Rupert", 2, 2, 1, 1, -1, 1, 2, "Hero", "Hardworking", "Competitive", "High Strung"),
            ("Russell Hantz", "Male", "Russell", 1, 1, 3, 3, 3, 2, 1, "Villain", "Resourceful", "Big Personality", "Arrogant"),
            ("Boston Rob Mariano", "Male", "Boston Rob", 2, 3, 3, 2, 3, 2, 2, "Villain", "Perceptive", "Threat Hunter", "Complainer"),
            ("John Cochran", "Male", "Cochran", -1, 3, 3, 2, 3, 1, 1, "Villain", "Perceptive", "Secretive", "Paranoid"),
            ("Taj George", "Female", "Taj", 0, 3, -1, 2, 1, 2, 1, "Hero", "Loyal", "Introverted", "Gullible"),
            ("Natalie Anderson", "Female", "Natalie A", 2, 2, 3, 2, 2, 2, 2, "Hero", "Hardworking", "Competitive", "Lazy"),
            ("Kim Spradlin", "Female", "Kim", 2, 3, 3, 2, 3, 2, 1, "Hero", "Charismatic", "Secretive", "Paranoid"),
            ("Sophie Clarke", "Female", "Sophie", 2, 2, 2, 3, 2, 2, 0, "Villain", "Resilient", "Introverted", "Complainer"),
            ("Amanda Kimmel", "Female", "Amanda", 1, 2, 1, 1, 1, 0, 2, "Hero", "Hardworking", "Competitive", "Gullible"),
            ("Gervase Peterson", "Male", "Gervase", 1, 2, 1, -1, 1, 1, 2, "Hero", "Charismatic", "Competitive", "Lazy"),
            ("Rob Cesternino", "Male", "Rob C", 0, 3, 3, 2, 3, 2, -1, "Villain", "Perceptive", "Secretive", "High Strung"),
            ("Jonny Fairplay", "Male", "Fairplay", 1, 1, 3, 2, 3, 2, -1, "Villain", "Perceptive", "Big Personality", "Arrogant"),
            ("Ken Hoang", "Male", "Kenny", -1, 2, 1, 2, 3, 2, -1, "Villain", "Resilient", "Secretive", "Paranoid"),
            ("Tyson Apostol", "Male", "Tyson", 2, 3, 2, 2, 3, 2, 2, "Villain", "Charismatic", "Big Personality", "Arrogant"),
            ("Coach Wade", "Male", "Coach", 2, 1, 2, 1, 2, 1, 2, "Villain", "Hardworking", "Big Personality", "High Strung"),
            ("Jonathan Penner", "Male", "Penner", 1, 3, 3, 2, 2, 2, 0, "Villain", "Perceptive", "Big Personality", "Arrogant"),
            ("Spencer Bledsoe", "Male", "Spencer", 2, 2, 2, 2, 3, 2, 1, "Hero", "Perceptive", "Introverted", "Arrogant"),
            ("Tony Vlachos", "Male", "Tony", 1, 2, 3, 3, 3, 2, 1, "Villain", "Resourceful", "Threat Hunter", "Paranoid"),
            ("Jeremy Collins", "Male", "Jeremy", 2, 3, 3, 1, 2, 2, 1, "Hero", "Perceptive", "Competitive", "Lazy"),
            ("Joe Anglim", "Male", "Joe", 3, 2, 1, 1, -1, 0, 2, "Hero", "Resilient", "Competitive", "Gullible"),
            ("Amber Brkich", "Female", "Amber", 1, 2, 1, 1, 0, 1, 1, "Hero", "Loyal", "Under-the-Radar", "Gullible"),
            ("Sue Hawk", "Female", "Sue", 0, 2, 1, 1, -1, 2, 2, "Villain", "Hardworking", "Vengeful", "Complainer"),
            ("Elisabeth Filarski", "Female", "Elisabeth", 1, 3, 1, 2, -1, 2, 2, "Hero", "Charismatic", "Introverted", "Lazy"),
            ("Tina Wesson", "Female", "Tina", 1, 2, 1, 2, -1, 1, 2, "Hero", "Loyal", "Introverted", "Gullible"),
            ("Sandra Diaz-Twine", "Female", "Sandra", -1, 3, 3, 2, 2, 2, 1, "Villain", "Perceptive", "Vengeful", "Arrogant"),
            ("Stephenie LaGrossa", "Female", "Stephenie", 3, 2, 2, 1, -1, 2, 3, "Hero", "Resilient", "Competitive", "Paranoid"),
            ("Parvati Shallow", "Female", "Parvati", 2, 3, 3, 2, 3, 2, 2, "Villain", "Perceptive", "Threat Hunter", "Arrogant"),
            ("Ciera Eastin", "Female", "Ciera", 0, 2, 2, 2, 2, 2, -1, "Villain", "Perceptive", "Under-the-Radar", "Arrogant"),
            ("Sarah Lacina", "Female", "Sarah", 2, 1, 2, 2, 2, 1, 1, "Villain", "Perceptive", "Big Personality", "Arrogant"),
            ("Candice Woodcock", "Female", "Candice", 1, 2, 1, 1, -1, 1, 2, "Hero", "Hardworking", "Competitive", "Lazy"),
            # New Male Contestants
            ("Lex van den Berghe", "Male", "Lex", 2, 1, 1, 0, 2, -1, 2, "Villain", "Loyal", "Vengeful", "Arrogant"),
            ("Ethan Zohn", "Male", "Ethan", 2, 3, 2, -1, 1, 1, 1, "Hero", "Charismatic", "Competitive", "Gullible"),
            ("Brian Heidik", "Male", "Brian", 1, 0, 2, 2, 3, 1, 1, "Villain", "Perceptive", "Big Personality", "Lazy"),
            ("Tom Westman", "Male", "Tom", 2, 2, 0, 0, 1, 1, 3, "Hero", "Hardworking", "Secretive", "High Strung"),
            ("Aras Baskauskas", "Male", "Aras", 1, 2, 1, 1, 1, 1, 2, "Villain", "Resilient", "Competitive", "Arrogant"),
            ("Terry Deitz", "Male", "Terry", 3, 1, -1, 1, 0, 2, 2, "Hero", "Hardworking", "Secretive", "Gullible"),
            ("Shane Powers", "Male", "Shane", 1, -1, 0, 1, 0, 1, 1, "Villain", "Resourceful", "Big Personality", "High Strung"),
            ("Yul Kwon", "Male", "Yul", 1, 2, 2, 2, 3, 2, 1, "Hero", "Perceptive", "Secretive", "Paranoid"),
            ("Todd Herzog", "Male", "Todd", 0, 2, 3, 2, 3, 2, 0, "Villain", "Resourceful", "Under the Radar", "Complainer"),
            ("James Clement", "Male", "James", 2, 2, 1, 0, -1, 0, 3, "Hero", "Charismatic", "Competitive", "Lazy"),
            ("Erik Reichenbach", "Male", "Erik", 2, 2, 0, -1, 0, -1, 1, "Hero", "Resilient", "Introverted", "Gullible"),
            ("JT Thomas", "Male", "JT", 2, 3, 2, -1, 0, 1, 3, "Hero", "Hardworking", "Vengeful", "Arrogant"),
            ("Troy Robertson", "Male", "Troyzan", 2, 0, 0, -1, -1, 1, 2, "Hero", "Resilient", "Threat Hunter", "Arrogant"),
            ("Colton Cumbie", "Male", "Colton", -1, -1, 1, 0, 0, 2, -1, "Villain", "Perceptive", "Threat Hunter", "Lazy"),
            ("Mike Holloway", "Male", "Mike", 3, 1, -1, 2, 0, 2, 2, "Hero", "Hardworking", "Competitive", "Complainer"),
            # New Female Contestants
            ("Colleen Haskell", "Female", "Colleen", 0, 3, -1, 1, 0, 1, 0, "Hero", "Charismatic", "Under the Radar", "Complainer"),
            ("Kelly Wigglesworth", "Female", "Kelly", 2, 1, 0, 1, 1, 0, 1, "Hero", "Loyal", "Secretive", "Gullible"),
            ("Alicia Calaway", "Female", "Alicia", 2, -1, 1, 1, 0, 2, 1, "Villain", "Resilient", "Big Personality", "High Strung"),
            ("Vecepia Towery", "Female", "Vecepia", 0, 2, 2, 1, 2, 2, 1, "Hero", "Resourceful", "Introverted", "Gullible"),
            ("Kathy Vavrick-O'Brien", "Female", "Kathy", 0, 2, 1, 2, 2, 1, 2, "Hero", "Loyal", "Secretive", "Paranoid"),
            ("Eliza Orlins", "Female", "Eliza", 0, -1, 1, 0, 1, 2, 0, "Villain", "Perceptive", "Vengeful", "High Strung"),
            ("Danni Boatwright", "Female", "Danni", 1, 2, 1, 2, 1, 1, 2, "Hero", "Loyal", "Introverted", "Gullible"),
            ("Danielle DiLorenzo", "Female", "Danielle", 1, 1, 1, 0, 1, 0, 1, "Villain", "Resilient", "Under the Radar", "Lazy"),
            ("Natalie Bolton", "Female", "Natalie B", 1, 2, 2, 2, 2, 1, 1, "Villain", "Perceptive", "Threat Hunter", "Complainer"),
            ("Sugar Kiper", "Female", "Sugar", 1, 0, 1, 1, 0, -1, 1, "Hero", "Loyal", "Secretive", "Complainer"),
            ("Dawn Meehan", "Female", "Dawn", 1, 1, 1, 2, 1, -1, 1, "Hero", "Loyal", "Introverted", "Paranoid"),
            ("Kat Edorsson", "Female", "Kat", 1, 2, 0, -1, -1, 0, 0, "Hero", "Resilient", "Vengeful", "Lazy"),
            ("Lisa Whelchel", "Female", "Lisa", 0, 2, 1, 1, 1, 0, 1, "Hero", "Loyal", "Introverted", "Paranoid"),
            ("Brenda Lowe", "Female", "Brenda", 2, 2, 2, 1, 1, 1, 1, "Villain", "Perceptive", "Threat Hunter", "Arrogant"),
            ("Monica Culpepper", "Female", "Monica", 1, 1, -1, 1, 0, 0, 2, "Villain", "Resilient", "Under the Radar", "High Strung"),
            ("Kass McQuillen", "Female", "Kass", 0, -1, 1, 2, 2, 3, 0, "Villain", "Resourceful", "Big Personality", "Arrogant")
        ]
        
        # Handle player character selection
        if choice == 1:
            # Play as yourself with custom name and archetype
            player_name = self.get_player_name()
            player_archetype = self.get_player_archetype_choice()
            
            # Select which contestant they're most like for stats/attributes/gender
            likeness_data = self.select_contestant_likeness(all_npcs)
            player_gender = likeness_data[1]  # Use gender from likeness contestant
            
            # Don't remove likeness contestant from pool - they can still be in the game
            player_data = None
            player_likeness = likeness_data
        else:
            # Play as existing contestant
            player_data = self.select_survivor_contestant(all_npcs)
            player_name = player_data[0]  # Full name
            player_gender = player_data[1]  # Gender
            player_archetype = None  # Will use existing contestant's archetype
            player_likeness = None
            
            # Remove selected contestant from the pool
            all_npcs = [contestant for contestant in all_npcs if contestant != player_data]
        
        
        # Create player contestant
        if player_data is None:
            # Custom player using likeness contestant's stats/attributes but player's name/archetype
            name, gender, nickname, challenge_skill, social_skill, persuasive_skill, perception_skill, strategic_skill, resistance_to_persuasion, survival_skill, hero_or_villain, positive_attribute, neutral_attribute, negative_attribute = player_likeness
            player_contestant = Contestant(player_name, "", player_gender, True, None, challenge_skill, social_skill, persuasive_skill, perception_skill, strategic_skill, resistance_to_persuasion, survival_skill, player_archetype, positive_attribute, neutral_attribute, negative_attribute)
        else:
            # Player using existing contestant data
            name, gender, nickname, challenge_skill, social_skill, persuasive_skill, perception_skill, strategic_skill, resistance_to_persuasion, survival_skill, hero_or_villain, positive_attribute, neutral_attribute, negative_attribute = player_data
            player_contestant = Contestant(name, "", gender, True, nickname, challenge_skill, social_skill, persuasive_skill, perception_skill, strategic_skill, resistance_to_persuasion, survival_skill, hero_or_villain, positive_attribute, neutral_attribute, negative_attribute)
        
        # Get opponent selection choice
        opponent_choice = self.get_opponent_selection_choice()
        
        if opponent_choice == 1:
            # Random contestant selection (existing logic)
            # Separate by gender
            males = [contestant for contestant in all_npcs if contestant[1] == "Male"]
            females = [contestant for contestant in all_npcs if contestant[1] == "Female"]
            
            # Adjust selection based on player gender to maintain balance
            if player_gender == "Male":
                selected_males = random.sample(males, 9)  # 9 males + player = 10 total males
                selected_females = random.sample(females, 10)  # 10 females
            else:  # player_gender == "Female"
                selected_males = random.sample(males, 10)  # 10 males
                selected_females = random.sample(females, 9)  # 9 females + player = 10 total females
            
            # Create all contestants including the player
            all_contestants = [player_contestant]
            
            for contestant_data in selected_males:
                name, gender, nickname, challenge_skill, social_skill, persuasive_skill, perception_skill, strategic_skill, resistance_to_persuasion, survival_skill, hero_or_villain, positive_attribute, neutral_attribute, negative_attribute = contestant_data
                all_contestants.append(Contestant(name, "", gender, False, nickname, challenge_skill, social_skill, persuasive_skill, perception_skill, strategic_skill, resistance_to_persuasion, survival_skill, hero_or_villain, positive_attribute, neutral_attribute, negative_attribute))
            
            for contestant_data in selected_females:
                name, gender, nickname, challenge_skill, social_skill, persuasive_skill, perception_skill, strategic_skill, resistance_to_persuasion, survival_skill, hero_or_villain, positive_attribute, neutral_attribute, negative_attribute = contestant_data
                all_contestants.append(Contestant(name, "", gender, False, nickname, challenge_skill, social_skill, persuasive_skill, perception_skill, strategic_skill, resistance_to_persuasion, survival_skill, hero_or_villain, positive_attribute, neutral_attribute, negative_attribute))
        else:
            # Hand-selected opponents
            all_contestants = self.hand_select_opponents(all_npcs, player_contestant)
        
        if opponent_choice == 2:
            # For hand-selected opponents, preserve the tribe assignments from selection
            # First 10 contestants (including player) are Tribe 1, next 10 are Tribe 2
            self.tribe1 = all_contestants[:10]
            self.tribe2 = all_contestants[10:20]
            
            # Set tribe names for all contestants
            for contestant in self.tribe1:
                contestant.tribe = self.tribe1_name
            for contestant in self.tribe2:
                contestant.tribe = self.tribe2_name
        else:
            # For random selection, use the balanced distribution method
            # Separate contestants by gender for balanced tribe assignment
            male_contestants = [c for c in all_contestants if c.gender == "Male"]
            female_contestants = [c for c in all_contestants if c.gender == "Female"]
            
            # Sort by challenge skill to enable balanced distribution
            male_contestants.sort(key=lambda x: x.challenge_skill, reverse=True)
            female_contestants.sort(key=lambda x: x.challenge_skill, reverse=True)
            
            # Initialize tribes
            self.tribe1 = []
            self.tribe2 = []
            
            # Assign males using snake draft pattern (1-2-2-2-2-1) to balance skills
            # This ensures the tribe that gets the best doesn't get the second best
            self.tribe1.append(male_contestants[0])  # 1st best
            self.tribe2.append(male_contestants[1])  # 2nd best
            self.tribe2.append(male_contestants[2])  # 3rd best
            self.tribe1.append(male_contestants[3])  # 4th best
            self.tribe1.append(male_contestants[4])  # 5th best
            self.tribe2.append(male_contestants[5])  # 6th best
            self.tribe2.append(male_contestants[6])  # 7th best
            self.tribe1.append(male_contestants[7])  # 8th best
            self.tribe1.append(male_contestants[8])  # 9th best
            self.tribe2.append(male_contestants[9])  # 10th best
            
            # Assign females using the same snake draft pattern
            self.tribe1.append(female_contestants[0])  # 1st best
            self.tribe2.append(female_contestants[1])  # 2nd best
            self.tribe2.append(female_contestants[2])  # 3rd best
            self.tribe1.append(female_contestants[3])  # 4th best
            self.tribe1.append(female_contestants[4])  # 5th best
            self.tribe2.append(female_contestants[5])  # 6th best
            self.tribe2.append(female_contestants[6])  # 7th best
            self.tribe1.append(female_contestants[7])  # 8th best
            self.tribe1.append(female_contestants[8])  # 9th best
            self.tribe2.append(female_contestants[9])  # 10th best
            
            # Set tribe names for all contestants
            for contestant in self.tribe1:
                contestant.tribe = self.tribe1_name
            for contestant in self.tribe2:
                contestant.tribe = self.tribe2_name
            
            # Shuffle within each tribe to randomize the order
            random.shuffle(self.tribe1)
            random.shuffle(self.tribe2)
        
        # Set player reference
        self.player = next(c for c in all_contestants if c.is_player)
        
        # All contestants
        self.contestants = self.tribe1 + self.tribe2
        
        # Vote targets and target rosters start blank for dynamic gameplay
        # self.initialize_vote_targets()
        # self.initialize_target_rosters()
        
        # Initialize relationships between all contestants
        self.initialize_relationships()
        
        # Initialize threat levels for all contestants
        self.initialize_threat_levels()
        
        # Add "good jury relationships" move to all contestants by default
        for contestant in self.contestants:
            contestant.add_game_move('good_jury_relationships', 1, self.day, "had a good relationship with all jurors")
    
    def initialize_vote_targets(self) -> None:
        """Initialize random vote targets for all contestants."""
        for contestant in self.contestants:
            if not contestant.is_player:  # Skip the human player
                self.assign_random_vote_target(contestant)
    
    def initialize_target_rosters(self) -> None:
        """Initialize target rosters for all contestants."""
        for contestant in self.contestants:
            if not contestant.is_player:  # Skip the human player
                self.assign_target_roster(contestant)
    
    def initialize_relationships(self) -> None:
        """Initialize all relationships between contestants, applying attribute bonuses."""
        for contestant1 in self.contestants:
            for contestant2 in self.contestants:
                if contestant1 != contestant2:
                    # Initialize both directions to 0 (relationships are not necessarily symmetric)
                    base_relationship = 0
                    
                    # Apply Charismatic attribute bonus
                    # Charismatic contestants start with +1 relationship with everyone
                    if self.has_charismatic_attribute(contestant1):
                        base_relationship = 1
                    
                    contestant1.set_relationship(contestant2, base_relationship)
    
    def has_charismatic_attribute(self, contestant: Contestant) -> bool:
        """Check if a contestant has the Charismatic attribute."""
        return ("charismatic" in contestant.positive_attribute.lower() or 
                "charismatic" in contestant.neutral_attribute.lower())
    
    def initialize_threat_levels(self) -> None:
        """Initialize threat levels for all contestants."""
        for contestant in self.contestants:
            # Set base threat level to 5
            threat = 5
            
            # Pre-merge challenge skill modifiers
            if contestant.challenge_skill >= 2:
                threat -= 1  # Strong in challenges = less threatening pre-merge
            elif contestant.challenge_skill <= 0:
                threat += 1  # Weak in challenges = more threatening pre-merge
            
            # Clamp between 1 and 10
            contestant.threat_level = max(1, min(10, threat))
    
    def update_threat_levels_at_merge(self) -> None:
        """Update threat levels when the game merges."""
        # Simply recalculate all threat levels using the comprehensive method
        self.update_all_threat_levels()
    
    def calculate_threat_level(self, contestant: Contestant) -> int:
        """Calculate the threat level for a contestant based on all factors."""
        # Start with base threat of 5
        threat = 5
        
        # 1. Challenge skill modifiers
        if self.merged:
            # Post-merge: strong = threatening
            if contestant.challenge_skill >= 2:
                threat += 1
            elif contestant.challenge_skill <= 0:
                threat -= 1
        else:
            # Pre-merge: strong = valuable
            if contestant.challenge_skill >= 2:
                threat -= 1
            elif contestant.challenge_skill <= 0:
                threat += 1
        
        # 2. Post-merge immunity wins (2+ wins increases threat)
        if self.merged and contestant.immunity_wins >= 2:
            threat += contestant.immunity_wins - 1
        
        # 3. Good relationships with many people (3+ with relationship >= 2)
        good_relationships = sum(1 for other in self.get_active_contestants() 
                               if other != contestant and contestant.get_relationship(other) >= 2)
        if good_relationships >= 3:
            threat -= 1
        
        # 4. Poor relationships with many people (3+ with relationship <= 0)
        poor_relationships = sum(1 for other in self.get_active_contestants() 
                               if other != contestant and contestant.get_relationship(other) <= 0)
        if poor_relationships >= 3:
            threat += 1
        
        # 5. Alliance with half or more of tribe
        total_alliances = contestant.alliance_roster + contestant.fake_alliance_roster
        if total_alliances:
            tribe_members = self.get_active_contestants(contestant.tribe) if not self.merged else self.get_active_contestants()
            tribe_size = len(tribe_members)
            alliance_size = len([m for m in total_alliances if m in tribe_members])
            if alliance_size >= tribe_size / 2:
                threat -= 1
        
        # 6. Good relationships with jurors (2+ with relationship >= 2)
        if self.jury:
            good_jury_relationships = sum(1 for juror in self.jury 
                                        if juror.get_relationship(contestant) >= 2)
            if good_jury_relationships >= 2:
                threat += good_jury_relationships - 1
        
        # 7. Poor relationships with jurors (2+ with relationship <= 0)
        if self.jury:
            poor_jury_relationships = sum(1 for juror in self.jury 
                                        if juror.get_relationship(contestant) <= 0)
            if poor_jury_relationships >= 2:
                threat -= poor_jury_relationships - 1
        
        # 8. Consecutive vote pitching (3+ consecutive days)
        if hasattr(contestant, 'consecutive_vote_pitch_days') and contestant.consecutive_vote_pitch_days >= 3:
            threat += 2
            # Mark that they currently have the bonus
            if hasattr(contestant, 'has_consecutive_pitch_threat_bonus'):
                contestant.has_consecutive_pitch_threat_bonus = True
        else:
            # Check if they previously had the bonus and should lose it after 3 days without pitching
            if (hasattr(contestant, 'has_consecutive_pitch_threat_bonus') and 
                contestant.has_consecutive_pitch_threat_bonus and
                hasattr(contestant, 'last_vote_pitch_day') and
                self.day - contestant.last_vote_pitch_day >= 3):
                # Remove the bonus - they've gone 3+ days without pitching
                contestant.has_consecutive_pitch_threat_bonus = False
        
        # 9. Elimination orchestration (3+ orchestrated eliminations)
        if hasattr(contestant, 'orchestrated_eliminations') and contestant.orchestrated_eliminations >= 3:
            # +1 for reaching 3 eliminations, then +1 for each additional elimination
            orchestration_bonus = contestant.orchestrated_eliminations - 2
            threat += orchestration_bonus
        
        # 10. Human player bonus (+1 threat level)
        if contestant.is_player:
            threat += 1
        
        # Clamp between 1 and 10
        return max(1, min(10, threat))
    
    def track_first_pitch_for_target(self, pitcher: Contestant, target: Contestant) -> None:
        """Track the first person to pitch a specific target this cycle."""
        if target not in self.cycle_first_pitch_tracker:
            self.cycle_first_pitch_tracker[target] = pitcher
    
    def track_successful_pitch(self, pitcher: Contestant, target: Contestant, recipient: Contestant, previous_vote_target: Contestant) -> None:
        """Track a successful pitch that changed someone's vote target."""
        # Only count as successful if the recipient actually changed their vote target
        if previous_vote_target != target:
            if pitcher not in self.cycle_successful_pitch_counts:
                self.cycle_successful_pitch_counts[pitcher] = {}
            if target not in self.cycle_successful_pitch_counts[pitcher]:
                self.cycle_successful_pitch_counts[pitcher][target] = 0
            self.cycle_successful_pitch_counts[pitcher][target] += 1
    
    def determine_elimination_orchestrator(self, eliminated_contestant: Contestant) -> Optional[Contestant]:
        """Determine who orchestrated the elimination of a contestant."""
        # First check if anyone made the first pitch for this target
        if eliminated_contestant in self.cycle_first_pitch_tracker:
            first_pitcher = self.cycle_first_pitch_tracker[eliminated_contestant]
            
            # Check if multiple people successfully pitched this target
            pitchers_for_target = []
            for pitcher, targets in self.cycle_successful_pitch_counts.items():
                if eliminated_contestant in targets and targets[eliminated_contestant] > 0:
                    pitchers_for_target.append((pitcher, targets[eliminated_contestant]))
            
            if len(pitchers_for_target) <= 1:
                # Only one person (or no one) successfully pitched this target
                return first_pitcher
            else:
                # Multiple people successfully pitched - find who convinced the most people
                max_count = max(count for _, count in pitchers_for_target)
                top_pitchers = [pitcher for pitcher, count in pitchers_for_target if count == max_count]
                
                if len(top_pitchers) == 1:
                    return top_pitchers[0]
                elif first_pitcher in top_pitchers:
                    # Tie-breaker: first pitcher wins if they're tied for most successful pitches
                    return first_pitcher
                else:
                    # First pitcher not in tie, so return the first one in the tie (arbitrary but consistent)
                    return top_pitchers[0]
        
        return None  # No orchestrator found
    
    def reset_orchestration_tracking(self) -> None:
        """Reset orchestration tracking for a new cycle after tribal council."""
        self.cycle_first_pitch_tracker = {}
        self.cycle_successful_pitch_counts = {}
        self.cycle_start_day = self.day + 1
    
    def add_to_target_roster(self, contestant: Contestant, target: Contestant) -> None:
        """Add a target to contestant's roster and auto-assign as vote target if needed."""
        # Skip if this is the human player
        if contestant.is_player:
            return
            
        # Skip if contestant is trying to target themselves
        if contestant == target:
            return
        
        # Skip if trying to add cross-tribe target during pre-merge
        if not self.merged and target.tribe != contestant.tribe:
            return
            
        # Skip if target is already in roster
        if target in contestant.target_roster:
            return
            
        # Add to target roster
        contestant.target_roster.append(target)
        
        # If vote target is blank, assign this target as vote target
        if not contestant.vote_target:
            contestant.vote_target = target
    
    def assign_fallback_vote_targets_day_2(self) -> None:
        """Assign vote targets using hat system for NPCs without targets by end of day 2."""
        for contestant in self.contestants:
            if not contestant.is_player and not contestant.eliminated and not contestant.vote_target:
                self.assign_vote_target_by_hat(contestant)
    
    def assign_vote_target_by_hat(self, contestant: Contestant) -> None:
        """Assign vote target using hat system with base 5 slips per tribemate."""
        # Skip if this is the human player
        if contestant.is_player:
            return
            
        # Get eligible targets (tribemates, excluding self and eliminated)
        if self.merged:
            eligible_targets = [c for c in self.get_active_contestants() 
                              if c != contestant and not c.immune and not c.eliminated]
        else:
            eligible_targets = [c for c in self.get_active_contestants(contestant.tribe) 
                              if c != contestant and not c.immune and not c.eliminated]
        
        # Exclude final 2 partner
        if contestant.final_2_deal:
            eligible_targets = [c for c in eligible_targets if c != contestant.final_2_deal]
        
        if not eligible_targets:
            return
            
        # Create hat with threat level as base slips, plus modifiers
        hat = []
        for target in eligible_targets:
            # Base slips = target's threat level
            base_slips = target.threat_level
            
            # Apply modifiers
            modifiers = 0
            
            # -1 if in alliance with the contestant
            if contestant.has_real_alliance_with(target) or contestant.has_fake_alliance_with(target):
                modifiers -= 1
            
            # -1 if relationship is 2 or higher
            if contestant.get_relationship(target) >= 2:
                modifiers -= 1
            
            # +1 for human player
            if target.is_player:
                modifiers += 1
            
            # Calculate final slip count (minimum 1 to ensure everyone has a chance)
            final_slips = max(1, base_slips + modifiers)
            
            # Add slips to hat (convert to int since threat_level can be float from busted penalties)
            hat.extend([target] * int(final_slips))
        
        if hat:
            selected_target = random.choice(hat)
            contestant.vote_target = selected_target
            # Also add to target roster since they're now targeting them
            self.add_to_target_roster(contestant, selected_target)
    
    def check_threat_level_10_triggers(self) -> None:
        """Check if any contestants have reached threat level 10 and trigger NPC targeting."""
        # Find all contestants with threat level 10
        max_threat_contestants = [c for c in self.get_active_contestants() if c.threat_level >= 10]
        
        if not max_threat_contestants:
            return
            
        # For each max threat contestant, have NPCs consider targeting them
        for threat_target in max_threat_contestants:
            self.narration(f"\n{threat_target.name} has reached maximum threat level! Other contestants take notice...")
            
            # Get all NPCs who don't currently target this contestant
            npcs_to_roll = [c for c in self.get_active_contestants() 
                           if not c.is_player 
                           and not c.eliminated 
                           and c.vote_target != threat_target
                           and c != threat_target]
            
            for npc in npcs_to_roll:
                # Roll d20 to see if they switch targets
                roll = random.randint(1, 20)
                
                if roll >= 11:  # 11-20: Switch to targeting the high threat contestant
                    # Save previous vote target to target roster
                    if npc.vote_target and npc.vote_target not in npc.target_roster:
                        npc.target_roster.append(npc.vote_target)
                    
                    # Switch vote target
                    old_target_name = npc.vote_target.name if npc.vote_target else "no one"
                    npc.vote_target = threat_target
                    
                    # Add threat target to target roster if not already there
                    if threat_target not in npc.target_roster:
                        npc.target_roster.append(threat_target)
                    
                    self.narration(f"{npc.name} switches their vote target from {old_target_name} to {threat_target.name}! (Roll: {roll})")
                # Roll 1-10: Nothing changes (no narration needed)
    
    def check_long_lasting_alliances(self) -> None:
        """Check for long-lasting alliances on day 34 (Level 3 game move)."""
        for contestant in self.get_active_contestants():
            # Check each early alliance to see if it's still intact
            for partner, formation_day in contestant.early_alliances.items():
                # Only check if partner is still active and alliance was formed in first 6 days
                if (not partner.eliminated and 
                    formation_day <= 6 and 
                    partner in contestant.alliance_roster):
                    
                    # Award Level 3 game move for long-lasting alliance
                    contestant.add_game_move('long_lasting_alliance', 3, self.day,
                                           f"maintained alliance with {partner.name} from day {formation_day} through day {self.day}",
                                           partner=partner.name, formation_day=formation_day)
    
    def update_all_threat_levels(self) -> None:
        """Update threat levels for all active contestants."""
        for contestant in self.get_active_contestants():
            contestant.threat_level = self.calculate_threat_level(contestant)
        
        # Check if anyone has reached threat level 10 and trigger responses
        self.check_threat_level_10_triggers()
        
    def assign_opposing_tribe_vote_targets(self) -> None:
        """Assign vote targets to opposing tribe NPCs who don't have them."""
        if self.merged:
            return  # No opposing tribe after merge
            
        other_tribe = self.get_other_tribe()
        if not other_tribe:
            return
            
        for npc in other_tribe:
            if not npc.is_player and not npc.vote_target:
                self.assign_random_vote_target(npc)
    
    def assign_random_vote_target(self, contestant: Contestant) -> None:
        """Assign a random vote target to a contestant, prioritizing their target roster."""
        # Skip if this is the human player
        if contestant.is_player:
            return
            
        if self.merged:
            # Post-merge: can target anyone except themselves and immune players
            eligible_targets = [c for c in self.get_active_contestants() 
                              if c != contestant and not c.immune]
        else:
            # Pre-merge: can only target tribemates
            eligible_targets = [c for c in self.get_active_contestants(contestant.tribe) 
                              if c != contestant and not c.immune]
        
        # Final 2 partners are excluded from targeting
        if contestant.final_2_deal:
            eligible_targets = [c for c in eligible_targets if c != contestant.final_2_deal]
        
        # Prioritize target roster - use targets from their roster if available
        # Also ensure we never select self even if somehow in target roster
        roster_targets = [c for c in contestant.target_roster if c in eligible_targets and c != contestant]
        
        if roster_targets:
            # Choose from target roster first
            contestant.vote_target = random.choice(roster_targets)
        elif eligible_targets:
            # Only use random selection if target roster is empty or has no eligible targets
            contestant.vote_target = random.choice(eligible_targets)
        else:
            contestant.vote_target = None
        
        # Final safety check - ensure contestant never targets themselves
        if contestant.vote_target == contestant:
            contestant.vote_target = None
            
        # Additional safety check - ensure vote target is on same tribe (pre-merge only)
        if not self.merged and contestant.vote_target and contestant.vote_target.tribe != contestant.tribe:
            contestant.vote_target = None
            
        # Add to contestant's info bank
        if contestant.vote_target:
            contestant.add_information('vote_target', contestant, contestant.vote_target)
    
    def handle_immunity_vote_target_displacement(self, contestant: Contestant) -> None:
        """Handle vote target displacement when their current target becomes immune.
        Backs up the original target and assigns a temporary replacement from target roster."""
        # Skip if this is the human player or they don't have a vote target
        if contestant.is_player or not contestant.vote_target:
            return
            
        # Only displace if their current vote target is immune
        if not contestant.vote_target.immune:
            return
            
        # Backup the original vote target
        contestant.immunity_displaced_vote_target = contestant.vote_target
        
        # Find a temporary replacement from their target roster
        if self.merged:
            eligible_targets = [c for c in self.get_active_contestants() 
                              if c != contestant and not c.immune and not c.eliminated]
        else:
            eligible_targets = [c for c in self.get_active_contestants(contestant.tribe) 
                              if c != contestant and not c.immune and not c.eliminated]
        
        # Exclude final 2 partners
        if contestant.final_2_deal:
            eligible_targets = [c for c in eligible_targets if c != contestant.final_2_deal]
        
        # Try to find replacement from target roster first
        # Also ensure we never select self even if somehow in target roster
        roster_targets = [c for c in contestant.target_roster if c in eligible_targets and c != contestant]
        
        if roster_targets:
            # Choose from target roster
            contestant.temporary_vote_target = random.choice(roster_targets)
            contestant.vote_target = contestant.temporary_vote_target
        elif eligible_targets:
            # Fallback to random selection if target roster has no eligible targets
            contestant.temporary_vote_target = random.choice(eligible_targets)
            contestant.vote_target = contestant.temporary_vote_target
        else:
            # No eligible targets at all
            contestant.temporary_vote_target = None
            contestant.vote_target = None
        
        # Final safety check - ensure contestant never targets themselves
        if contestant.vote_target == contestant:
            contestant.temporary_vote_target = None
            contestant.vote_target = None
            
        # Additional safety check - ensure vote target is on same tribe (pre-merge only)
        if not self.merged and contestant.vote_target and contestant.vote_target.tribe != contestant.tribe:
            contestant.temporary_vote_target = None
            contestant.vote_target = None
            
        # Add new vote target to info bank
        if contestant.vote_target:
            contestant.add_information('vote_target', contestant, contestant.vote_target)
    
    def restore_immunity_displaced_vote_targets(self) -> None:
        """Restore original vote targets that were displaced due to immunity after tribal council."""
        for contestant in self.contestants:
            if contestant.immunity_displaced_vote_target and not contestant.eliminated:
                # Move temporary target back to target roster if it exists and isn't already there
                if (contestant.temporary_vote_target and 
                    contestant.temporary_vote_target not in contestant.target_roster and
                    not contestant.temporary_vote_target.eliminated):
                    contestant.target_roster.append(contestant.temporary_vote_target)
                
                # Restore original vote target
                contestant.vote_target = contestant.immunity_displaced_vote_target
                
                # Clear backup fields
                contestant.immunity_displaced_vote_target = None
                contestant.temporary_vote_target = None
                
                # Add restored vote target to info bank
                if contestant.vote_target and not contestant.vote_target.eliminated:
                    contestant.add_information('vote_target', contestant, contestant.vote_target)
    
    
    def assign_target_roster(self, contestant: Contestant, num_targets: int = 2) -> None:
        """Assign a target roster of contestants that this contestant wants to eliminate.
        Initially assigns num_targets contestants (default 2) but the roster can grow over time.
        
        Args:
            contestant: The contestant to assign targets to
            num_targets: Number of targets to initially assign (default 2)
        """
        # Skip if this is the human player
        if contestant.is_player:
            return
            
        if self.merged:
            # Post-merge: can target anyone except themselves and immune players
            eligible_targets = [c for c in self.get_active_contestants() 
                              if c != contestant and not c.immune]
        else:
            # Pre-merge: can only target tribemates
            eligible_targets = [c for c in self.get_active_contestants(contestant.tribe) 
                              if c != contestant and not c.immune]
        
        # Remove real alliance members from potential targets (they won't vote for real allies)
        if contestant.alliance_roster:
            eligible_targets = [c for c in eligible_targets if c not in contestant.alliance_roster]
        
        # Remove final 2 partner from potential targets
        if contestant.final_2_deal:
            eligible_targets = [c for c in eligible_targets if c != contestant.final_2_deal]
        
        # If no eligible targets after removing alliance members, include them back
        if not eligible_targets:
            if self.merged:
                eligible_targets = [c for c in self.get_active_contestants() 
                                  if c != contestant and not c.immune]
            else:
                eligible_targets = [c for c in self.get_active_contestants(contestant.tribe) 
                                  if c != contestant and not c.immune]
        
        # Remove the current vote target from eligible roster targets
        if contestant.vote_target and contestant.vote_target in eligible_targets:
            eligible_targets = [c for c in eligible_targets if c != contestant.vote_target]
        
        # Select targets for the roster based on availability
        if len(eligible_targets) >= num_targets:
            contestant.target_roster = random.sample(eligible_targets, num_targets)
        else:
            # If fewer eligible targets than requested, take all available
            contestant.target_roster = eligible_targets.copy()
        
        # Add to contestant's info bank
        if contestant.target_roster:
            # Store target roster as a special entry with multiple targets
            info_entry = {
                'type': 'target_roster',
                'subject': contestant,
                'targets': contestant.target_roster.copy(),  # Store the list of targets
                'day': None
            }
            # Remove any existing target_roster entries for this contestant
            contestant.information_bank = [info for info in contestant.information_bank 
                                         if not (info['type'] == 'target_roster' and info.get('subject') == contestant)]
            contestant.information_bank.append(info_entry)
    
    def add_target_to_roster(self, contestant: Contestant) -> None:
        """Add a new target to a contestant's roster if there's room."""
        # Skip if this is the human player
        if contestant.is_player:
            return
            
        # Get all contestants in their tribe except themselves and current targets
        if self.merged:
            eligible_targets = [c for c in self.get_active_contestants() 
                              if c != contestant 
                              and c not in contestant.target_roster
                              and c != contestant.vote_target]
        else:
            eligible_targets = [c for c in self.get_active_contestants(contestant.tribe) 
                              if c != contestant 
                              and c not in contestant.target_roster
                              and c != contestant.vote_target]
        
        # Add a random target if available
        if eligible_targets:
            new_target = random.choice(eligible_targets)
            self.add_to_target_roster(contestant, new_target)
            
            # Update the info bank entry
            for info in contestant.information_bank:
                if info['type'] == 'target_roster' and info.get('subject') == contestant:
                    info['targets'] = contestant.target_roster.copy()
                    break
    
    def update_target_roster_after_elimination(self, eliminated_contestant: Contestant) -> None:
        """Update target rosters and vote targets after someone is eliminated."""
        for contestant in self.get_active_contestants():
            # Handle both NPCs and human player
                
            # Check if the eliminated contestant was their vote target
            if contestant.vote_target == eliminated_contestant:
                if contestant.is_player:
                    # For human player: clear vote target and mark for re-selection prompt
                    contestant.vote_target = None
                    self.player_vote_target_eliminated = True
                else:
                    # For NPCs: Set new vote target from target roster
                    if contestant.target_roster:
                        # Remove the eliminated contestant from roster if they're there
                        if eliminated_contestant in contestant.target_roster:
                            contestant.target_roster.remove(eliminated_contestant)
                        
                        # If roster still has targets, pick one as new vote target
                        if contestant.target_roster:
                            contestant.vote_target = random.choice(contestant.target_roster)
                            # Don't remove from roster anymore - they stay on the long-term list
                            
                            # Add a new target to the roster to replace the eliminated one
                            self.add_target_to_roster(contestant)
                        else:
                            # No targets in roster, assign random vote target
                            self.assign_random_vote_target(contestant)
                    else:
                        # No target roster, assign random vote target
                        self.assign_random_vote_target(contestant)
            
            # Remove eliminated contestant from target roster if they're there
            elif eliminated_contestant in contestant.target_roster:
                contestant.target_roster.remove(eliminated_contestant)
                # Add a new target to replace the eliminated one
                self.add_target_to_roster(contestant)
    
    def update_group_alliances_after_elimination(self, eliminated_contestant: Contestant) -> None:
        """Update group alliances after someone is eliminated - remove them and convert/dissolve as needed."""
        # Get a copy of the eliminated contestant's group alliances
        eliminated_alliances = eliminated_contestant.group_alliances.copy()
        
        # Process each group alliance the eliminated contestant was part of
        for alliance_id in eliminated_alliances:
            if alliance_id in self.group_alliances:
                alliance = self.group_alliances[alliance_id]
                
                # Remove the eliminated contestant from the alliance member list
                if eliminated_contestant in alliance['members']:
                    alliance['members'].remove(eliminated_contestant)
                
                # Remove the alliance from the eliminated contestant's tracking
                if alliance_id in eliminated_contestant.group_alliances:
                    eliminated_contestant.group_alliances.remove(alliance_id)
                
                # Remove group alliance info from eliminated contestant's information bank
                self.remove_group_alliance_info_from_bank(eliminated_contestant, alliance_id)
                
                # Check what to do with the remaining alliance
                remaining_members = alliance['members']
                
                if len(remaining_members) < 2:
                    # Alliance has fewer than 2 members - dissolve it
                    self.dissolve_group_alliance(alliance_id, "insufficient members after elimination")
                elif len(remaining_members) == 2:
                    # Alliance has exactly 2 members - check for conversion or dissolution
                    self.check_and_dissolve_redundant_alliance(alliance_id)
                # If 3+ members remain, alliance continues as normal
    
    def lock_relationships_for_elimination(self, eliminated: Contestant) -> None:
        """Lock all relationships between the eliminated contestant and others."""
        # Lock the eliminated contestant's relationships with everyone
        for other in self.contestants:
            if other != eliminated:
                eliminated.locked_relationships.add(other)
                # Also lock the reverse relationship
                other.locked_relationships.add(eliminated)
    
    def reset_targets_at_merge(self, original_tribes: Dict[Contestant, str]) -> None:
        """Reset vote targets at merge - preserve current vote target by moving to roster, assign new vote target."""
        active_contestants = self.get_active_contestants()
        
        for contestant in active_contestants:
            if contestant.is_player:
                continue  # Skip the player, they control their own targets
            
            # Preserve current vote target by moving to target roster
            old_vote_target = contestant.vote_target
            
            # Clear target roster only
            contestant.target_roster = []
            
            # Add old vote target to roster if it exists and is still active
            if old_vote_target and old_vote_target in active_contestants:
                contestant.target_roster.append(old_vote_target)
                
                # Add to info bank
                info_entry = {
                    'type': 'target_roster',
                    'subject': contestant,
                    'targets': [old_vote_target],
                    'day': None
                }
                # Remove any existing target_roster entries
                contestant.information_bank = [info for info in contestant.information_bank 
                                             if not (info['type'] == 'target_roster' and info.get('subject') == contestant)]
                contestant.information_bank.append(info_entry)
            
            # Assign new vote target using existing logic
            self.assign_random_vote_target(contestant)
    
    def add_target_to_roster(self, contestant: Contestant) -> None:
        """Add a new target to a contestant's roster."""
        # Skip if this is the human player
        if contestant.is_player:
            return
        
        if self.merged:
            eligible_targets = [c for c in self.get_active_contestants() 
                              if c != contestant and not c.immune]
        else:
            eligible_targets = [c for c in self.get_active_contestants(contestant.tribe) 
                              if c != contestant and not c.immune]
        
        # Remove real alliance members, current vote target, and existing roster members
        if contestant.alliance_roster:
            eligible_targets = [c for c in eligible_targets if c not in contestant.alliance_roster]
        
        # Remove current vote target - this is the key fix
        if contestant.vote_target:
            eligible_targets = [c for c in eligible_targets if c != contestant.vote_target]
        
        # Remove existing roster members
        eligible_targets = [c for c in eligible_targets if c not in contestant.target_roster]
        
        # Add a random target if available
        if eligible_targets:
            self.add_to_target_roster(contestant, random.choice(eligible_targets))
    
    def handle_busted(self, liar: Contestant, detector: Contestant, busted_level: int) -> None:
        """Handle when a contestant gets caught lying.
        
        Args:
            liar: The contestant who was caught lying
            detector: The contestant who caught the lie
            busted_level: The severity level (1, 2, or 3)
        """
        if busted_level not in [1, 2, 3]:
            return  # Invalid busted level
        
        # Level 1: Threat level increase and pitch penalty
        # Increase threat level by 0.5
        liar.threat_level = min(10, liar.threat_level + 0.5)
        
        # Add pitch penalty for 2 days
        expiry_day = self.day + 2  # Penalty lasts for today and tomorrow
        liar.busted_penalties[detector] = (busted_level, expiry_day)
        
        # Level 2: Also add liar to detector's target roster
        if busted_level >= 2:
            if liar not in detector.target_roster and not detector.is_player:
                detector.target_roster.append(liar)
                
                # Update detector's info bank with new target roster
                for info in detector.information_bank:
                    if info['type'] == 'target_roster' and info.get('subject') == detector:
                        info['targets'] = detector.target_roster.copy()
                        break
        
        # Level 3: Also decrease relationship by 1
        if busted_level >= 3:
            # Decrease relationship both ways
            detector.modify_relationship(liar, -1, self)
            liar.modify_relationship(detector, -1, self)
            
            # Check for alliance breaking due to busted level 3
            self.check_alliance_breaking_conditions(liar, detector, "busted_level_3")
            
            # Also check for alliance breaking due to relationship falling to -1
            self.check_relationship_alliance_breaking(detector, liar)
    
    def get_busted_penalty(self, pitcher: Contestant, target: Contestant) -> int:
        """Get the pitch penalty if the pitcher was busted by the target.
        
        Returns:
            The penalty to apply to pitch rolls (-1 if busted, 0 otherwise)
        """
        if target in pitcher.busted_penalties:
            penalty_level, expiry_day = pitcher.busted_penalties[target]
            if self.day < expiry_day:
                return -1  # Apply -1 penalty to all pitch rolls
            else:
                # Penalty expired, remove it
                del pitcher.busted_penalties[target]
        return 0
    
    def apply_temporary_persuasion_modifier(self, pitcher: Contestant, target: Contestant, modifier: int, duration_days: int = 2) -> None:
        """Apply a temporary persuasion modifier between two contestants.
        
        Args:
            pitcher: The contestant who gets the bonus/penalty when pitching to target
            target: The contestant being pitched to
            modifier: The modifier value (+1 for bonus, -1 for penalty)
            duration_days: How many days the modifier lasts (default 2)
        """
        expiry_day = self.day + duration_days
        pitcher.temporary_persuasion_modifiers[target] = (modifier, expiry_day)
    
    def get_temporary_persuasion_modifier(self, pitcher: Contestant, target: Contestant) -> int:
        """Get the temporary persuasion modifier if the pitcher has one with the target.
        
        Returns:
            The modifier to apply to pitch rolls (+1 for bonus, -1 for penalty, 0 otherwise)
        """
        if target in pitcher.temporary_persuasion_modifiers:
            modifier, expiry_day = pitcher.temporary_persuasion_modifiers[target]
            if self.day < expiry_day:
                return modifier
            else:
                # Modifier expired, remove it
                del pitcher.temporary_persuasion_modifiers[target]
        return 0
    
    def clean_expired_persuasion_modifiers(self) -> None:
        """Remove expired temporary persuasion modifiers from all contestants."""
        for contestant in self.contestants:
            expired_targets = []
            for target, (modifier, expiry_day) in contestant.temporary_persuasion_modifiers.items():
                if self.day >= expiry_day:
                    expired_targets.append(target)
            
            for target in expired_targets:
                del contestant.temporary_persuasion_modifiers[target]
    
    def clean_expired_busted_penalties(self) -> None:
        """Remove expired busted penalties from all contestants."""
        for contestant in self.contestants:
            expired_targets = []
            for target, (level, expiry_day) in contestant.busted_penalties.items():
                if self.day >= expiry_day:
                    expired_targets.append(target)
            
            for target in expired_targets:
                del contestant.busted_penalties[target]
    
    def clean_expired_reveal_bonuses(self) -> None:
        """Remove expired reveal bonuses."""
        if hasattr(self, 'reveal_bonuses'):
            expired_pairs = []
            for (player, target), expiry_day in self.reveal_bonuses.items():
                if self.day > expiry_day:
                    expired_pairs.append((player, target))
            
            for pair in expired_pairs:
                del self.reveal_bonuses[pair]
        
        # Also clean NPC reveal bonuses
        if hasattr(self, 'npc_reveal_bonuses'):
            expired_pairs = []
            for (npc, target), expiry_day in self.npc_reveal_bonuses.items():
                if self.day > expiry_day:
                    expired_pairs.append((npc, target))
            
            for pair in expired_pairs:
                del self.npc_reveal_bonuses[pair]
        
    def get_active_contestants(self, tribe: str = None) -> List[Contestant]:
        """Get all active (non-eliminated) contestants, optionally filtered by tribe."""
        if tribe:
            return [c for c in self.contestants if not c.eliminated and c.tribe == tribe]
        return [c for c in self.contestants if not c.eliminated]
    
    def get_display_contestants(self, tribe: str = None) -> List[Contestant]:
        """Get contestants for display purposes (includes unrevealed eliminations)."""
        if tribe:
            # Show all contestants except those who have been revealed as eliminated
            return [c for c in self.contestants if c.tribe == tribe and not (c.eliminated and c in self.revealed_eliminations)]
        return [c for c in self.contestants if not (c.eliminated and c in self.revealed_eliminations)]
    
    def get_player_tribe(self) -> List[Contestant]:
        """Get the tribe the player is currently on."""
        if self.merged:
            return self.get_active_contestants()
        return self.get_active_contestants(self.player.tribe)
    
    def get_player_tribe_name(self) -> str:
        """Get the name of the player's current tribe."""
        if self.merged:
            return self.merge_tribe_name
        return self.player.tribe
    
    def get_other_tribe(self) -> List[Contestant]:
        """Get the tribe the player is not on (pre-merge only)."""
        if self.merged:
            return []
        other_tribe = self.tribe2_name if self.player.tribe == self.tribe1_name else self.tribe1_name
        return self.get_active_contestants(other_tribe)
    
    def get_other_tribe_name(self) -> str:
        """Get the name of the tribe the player is not on."""
        if self.merged:
            return ""
        return self.tribe2_name if self.player.tribe == self.tribe1_name else self.tribe1_name
    
    def get_contestant_tribe(self, contestant: Contestant) -> List[Contestant]:
        """Get the tribe list that a specific contestant belongs to."""
        if self.merged:
            return self.merged_tribe
        else:
            if contestant.tribe == self.tribe1_name:
                return self.tribe1
            else:
                return self.tribe2
    
    def narration(self, text: str) -> None:
        """Display a narration message with formatting."""
        print("\n" + "-" * 80)
        self.slow_print(text)
        print("-" * 80 + "\n")
        time.sleep(1)
    
    def jeff_speaks(self, text: str) -> None:
        """Display Jeff Probst speaking with formatting."""
        self.slow_print(f"Jeff Probst: \"{text}\"")
        time.sleep(0.5)
    
    def contestant_speaks(self, contestant: Contestant, text: str) -> None:
        """Display a contestant speaking with formatting."""
        self.slow_print(f"{contestant.name}: \"{text}\"")
        self._last_speaker = contestant
        time.sleep(0.5)
    
    def display_tribes_introduction(self) -> None:
        """Display the tribes for the first time with full names."""
        tribe1 = self.get_display_contestants(self.tribe1_name)
        tribe2 = self.get_display_contestants(self.tribe2_name)
        
        print(f"\n{self.tribe1_name} Tribe:")
        for contestant in tribe1:
            status = " (You)" if contestant.is_player else ""
            print(f"- {contestant.get_full_name()}{status}")
            
        print(f"\n{self.tribe2_name} Tribe:")
        for contestant in tribe2:
            status = " (You)" if contestant.is_player else ""
            print(f"- {contestant.get_full_name()}{status}")
            
        print()

    def display_tribes(self) -> None:
        """Display the current tribes and their members."""
        if self.merged:
            # After merge, all eliminations are public so use active contestants only
            active = self.get_active_contestants()
            print(f"\n{self.merge_tribe_name} Tribe (Merged):")
            for contestant in active:
                status = " (You)" if contestant.is_player else ""
                status += " (Immune)" if contestant.immune else ""
                status += " (Has Idol)" if contestant.has_idol and contestant.is_player else ""
                print(f"- {contestant.name}{status}")
        else:
            tribe1 = self.get_display_contestants(self.tribe1_name)
            tribe2 = self.get_display_contestants(self.tribe2_name)
            
            print(f"\n{self.tribe1_name} Tribe:")
            for contestant in tribe1:
                status = " (You)" if contestant.is_player else ""
                status += " (Immune)" if contestant.immune else ""
                status += " (Has Idol)" if contestant.has_idol and contestant.is_player else ""
                print(f"- {contestant.name}{status}")
                
            print(f"\n{self.tribe2_name} Tribe:")
            for contestant in tribe2:
                status = " (You)" if contestant.is_player else ""
                status += " (Immune)" if contestant.immune else ""
                status += " (Has Idol)" if contestant.has_idol and contestant.is_player else ""
                print(f"- {contestant.name}{status}")
                
        print("\nEliminated:")
        for i, contestant in enumerate(self.revealed_eliminations):
            jury_status = " (Jury)" if contestant in self.jury else ""
            print(f"- {contestant.name}{jury_status}")
            
        print()
    
    def display_contestant_status_for_jury(self) -> None:
        """Display the current contestant status for jury members."""
        # Get active contestants (still in the game)
        active = self.get_active_contestants()
        
        # Display active contestants
        print(f"\n{self.merge_tribe_name} Tribe (Still In Game):")
        for contestant in active:
            status = ""
            status += " (Immune)" if contestant.immune else ""
            print(f"- {contestant.name}{status}")
        
        # Display jury members
        if self.jury:
            print("\nJury:")
            for contestant in self.jury:
                print(f"- {contestant.name}")
        
        print()
    
    def get_consensus_vote(self, tribe: List[Contestant] = None) -> List[Contestant]:
        """Calculate who would be voted out if tribal council happened immediately.
        Returns a list of contestants who would be eliminated based on current vote targets.
        Returns multiple contestants in case of ties."""
        if tribe is None:
            tribe = self.get_player_tribe()
        
        # Count votes for each contestant
        vote_counts = {}
        
        for voter in tribe:
            if voter.eliminated or not voter.vote_target:
                continue
            
            # Only count votes for contestants who are in the tribe and not eliminated
            if voter.vote_target in tribe and not voter.vote_target.eliminated:
                vote_counts[voter.vote_target] = vote_counts.get(voter.vote_target, 0) + 1
        
        if not vote_counts:
            return []  # No one is being voted for
        
        # Find who has the most votes
        max_votes = max(vote_counts.values())
        tied_contestants = [contestant for contestant, votes in vote_counts.items() if votes == max_votes]
        
        # Return all contestants tied for most votes (sorted alphabetically for consistency)
        return sorted(tied_contestants, key=lambda c: c.name)
    
    def add_consensus_vote_information(self, learner: Contestant, consensus_targets: List[Contestant]) -> None:
        """Add consensus vote information to a contestant's information bank."""
        if not learner or not consensus_targets:
            return
        
        # Sort targets for consistent comparison
        sorted_targets = sorted(consensus_targets, key=lambda c: c.name)
        
        # Check if this information already exists
        for info in learner.information_bank:
            if info['type'] == 'consensus_vote':
                existing_targets = info.get('targets', [])
                if sorted(existing_targets, key=lambda c: c.name) == sorted_targets:
                    return  # Already know this exact consensus
        
        # Add the consensus vote information
        consensus_info = {
            'type': 'consensus_vote',
            'targets': sorted_targets,
            'day': self.day,
            'self_discovered': True  # Mark as self-discovered through vote counting
        }
        learner.information_bank.append(consensus_info)
        
        # Resolve any conflicts with existing consensus votes
        self.resolve_consensus_vote_conflicts(learner)
        
        # If this is the player, prompt them to join the consensus
        if learner.is_player:
            self.prompt_player_consensus_join(sorted_targets)
    
    def prompt_player_consensus_join(self, consensus_targets: List[Contestant]) -> None:
        """Prompt the player to join a discovered consensus vote."""
        # Only prompt if the consensus target is not already the player's vote target
        if self.player.vote_target in consensus_targets:
            return  # Player is already voting for consensus target
        
        # Determine the message based on single target or tied targets
        if len(consensus_targets) == 1:
            target_name = consensus_targets[0].name
            message = f"It looks like the tribe is planning to vote out {target_name} next."
        else:
            target_names = [target.name for target in consensus_targets]
            message = f"It looks like the tribe is planning to vote out {' or '.join(target_names)} next."
        
        print(f"\n{message} Would you like to join the consensus?")
        print("1. Yes")
        print("2. No")
        
        while True:
            try:
                choice = int(input("Enter your choice (1-2): "))
                if choice == 1:
                    # Player chooses to join the consensus
                    # Human player doesn't use target roster - just change target
                    # Safety check - don't let player target themselves
                    if consensus_targets[0] != self.player:
                        self.player.vote_target = consensus_targets[0]  # Set to first target if multiple
                        self.narration(f"Your vote target has been updated to {consensus_targets[0].name}.")
                    else:
                        self.narration("You can't target yourself! The consensus target is invalid.")
                    break
                elif choice == 2:
                    # Player chooses not to join
                    self.narration("You decide to stick with your current vote target.")
                    break
                else:
                    print("Invalid choice. Please enter 1 or 2.")
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    def check_consensus_vote_discovery(self, contestant: Contestant) -> None:
        """Check if a contestant has learned about a majority consensus vote and add consensus info if so."""
        # Get the contestant's current tribe
        if contestant.tribe == self.tribe1_name:
            tribe = self.get_active_contestants(self.tribe1_name)
        elif contestant.tribe == self.tribe2_name:
            tribe = self.get_active_contestants(self.tribe2_name)
        else:
            # Merged tribe
            tribe = self.get_active_contestants()
        
        if not tribe:
            return
        
        tribe_size = int(len(tribe))
        # Use simple majority threshold for consensus detection
        majority_threshold = (tribe_size // 2) + 1
        
        # Count how many vote_target entries this contestant knows for each target
        vote_target_counts = {}
        
        # First, include the contestant's own vote target
        if contestant.vote_target and contestant.vote_target in tribe:
            vote_target_counts[contestant.vote_target] = vote_target_counts.get(contestant.vote_target, 0) + 1
        
        for info in contestant.information_bank:
            if info['type'] == 'vote_target' and 'target' in info:
                target = info['target']
                if target in tribe:  # Only count votes for current tribe members
                    # Only count vote_target info that came from reliable sources
                    # Skip info that was gained from bluffs/critical failures
                    if not info.get('is_bluff', False):
                        vote_target_counts[target] = vote_target_counts.get(target, 0) + 1
        
        # Check if any target has reached majority threshold
        consensus_targets = []
        for target, vote_count in vote_target_counts.items():
            if vote_count >= majority_threshold:
                consensus_targets.append(target)
        
        # If we found consensus targets, add them to the information bank
        if consensus_targets:
            self.add_consensus_vote_information(contestant, consensus_targets)
    
    def add_information_with_day(self, contestant: Contestant, info_type: str, subject: Contestant, target: Optional[Contestant] = None) -> None:
        """Add information to a contestant's bank with current day and check for consensus vote discovery."""
        contestant.add_information(info_type, subject, target)
        
        # Update the day for the most recent information
        if contestant.information_bank:
            contestant.information_bank[-1]['day'] = self.day
        
        # Check for various information conflicts
        if info_type == 'has_idol':
            self.resolve_idol_conflicts(contestant)
        elif info_type == 'vote_target':
            self.resolve_vote_target_conflicts(contestant)
            self.check_consensus_vote_discovery(contestant)
        elif info_type == 'previous_vote':
            self.resolve_previous_vote_conflicts(contestant)
        elif info_type == 'consensus_vote':
            self.resolve_consensus_vote_conflicts(contestant)
    
    def resolve_idol_conflicts(self, contestant: Contestant) -> None:
        """Resolve conflicting idol information based on game phase."""
        # Count how many people the contestant believes have idols
        idol_holders = []
        idol_info_indices = []
        
        for i, info in enumerate(contestant.information_bank):
            if info['type'] == 'has_idol' and info.get('subject'):
                idol_holders.append(info.get('subject'))
                idol_info_indices.append(i)
        
        # Determine the conflict threshold based on game phase
        if not self.merged:
            # Pre-merge: Only 1 idol allowed
            conflict_threshold = 2
        else:
            # Post-merge: Up to 3 idols allowed
            conflict_threshold = 4
        
        # If we have too many idol holders, resolve the conflict
        if len(idol_holders) >= conflict_threshold:
            # Calculate how many idols to keep
            idols_to_keep = conflict_threshold - 1  # Keep one less than the conflict threshold
            
            # Create a list of (holder, score, index) tuples for sorting
            holder_scores = []
            
            for i, holder in enumerate(idol_holders):
                score = 0
                
                # If contestant has the idol, they always believe it
                if holder == contestant and contestant.idol_count > 0:
                    score += 1000  # Highest priority
                
                # Check if in alliance with the holder
                if contestant.has_real_alliance_with(holder):
                    score += 100  # Alliance is important
                
                # Add relationship score
                score += contestant.get_relationship(holder)
                
                # Add small random value for tie-breaking
                score += random.random() * 0.1
                
                holder_scores.append((holder, score, idol_info_indices[i]))
            
            # Sort by score (highest first)
            holder_scores.sort(key=lambda x: x[1], reverse=True)
            
            # Keep only the top idols_to_keep holders
            indices_to_keep = set(hs[2] for hs in holder_scores[:idols_to_keep])
            
            # Remove all idol information not in the keep list
            for i in reversed(idol_info_indices):
                if i not in indices_to_keep:
                    contestant.information_bank.pop(i)
    
    def resolve_vote_target_conflicts(self, contestant: Contestant) -> None:
        """Resolve conflicting vote target information (can't vote for 2 people)."""
        # Group vote target info by subject
        vote_targets_by_subject = {}
        
        for i, info in enumerate(contestant.information_bank):
            if info['type'] == 'vote_target' and info.get('subject') and info.get('target'):
                subject = info.get('subject')
                if subject not in vote_targets_by_subject:
                    vote_targets_by_subject[subject] = []
                vote_targets_by_subject[subject].append((info['target'], i))
        
        # Check each subject for conflicts
        for subject, target_list in vote_targets_by_subject.items():
            if len(target_list) >= 2:
                # Multiple vote targets for same person - resolve conflict
                
                # Strategic skill enhancement: contestants with strategic_skill >= 2 
                # automatically identify and remove incorrect information
                if contestant.strategic_skill >= 2:
                    # High strategic skill - identify the most reliable information
                    # Check if subject's current vote_target matches any of the conflicting info
                    correct_target = None
                    if hasattr(subject, 'vote_target') and subject.vote_target:
                        for target, idx in target_list:
                            if target == subject.vote_target:
                                correct_target = (target, idx)
                                break
                    
                    if correct_target:
                        # Remove all incorrect information, keep only the correct target
                        for target, idx in reversed(target_list):
                            if (target, idx) != correct_target:
                                contestant.information_bank.pop(idx)
                    else:
                        # Neither piece is correct or we can't determine - remove one randomly
                        target_to_remove = random.choice(target_list)
                        remaining_targets = [t for t in target_list if t != target_to_remove]
                        contestant.information_bank.pop(target_to_remove[1])
                        
                        # If more than 2 conflicting pieces, recursively resolve remaining conflicts
                        if len(remaining_targets) >= 2:
                            self.resolve_vote_target_conflicts(contestant)
                else:
                    # Original logic for contestants with strategic_skill < 2
                    # Create scored list of (target, score, index)
                    target_scores = []
                    
                    for target, idx in target_list:
                        score = 0
                        
                        # Check if in alliance with the informant (who told them this info)
                        # We'd need to track source, so for now use alliance/relationship with target
                        if contestant.has_real_alliance_with(target):
                            score += 50  # Moderate importance
                        
                        # Add relationship score with target
                        score += contestant.get_relationship(target)
                        
                        # Add small random value for tie-breaking
                        score += random.random() * 0.1
                        
                        target_scores.append((target, score, idx))
                    
                    # Sort by score (highest first) and keep only the first
                    target_scores.sort(key=lambda x: x[1], reverse=True)
                    indices_to_keep = {target_scores[0][2]}
                    
                    # Remove all other vote target info for this subject
                    for _, idx in reversed(target_list):
                        if idx not in indices_to_keep:
                            contestant.information_bank.pop(idx)
    
    def resolve_previous_vote_conflicts(self, contestant: Contestant) -> None:
        """Resolve conflicting previous vote information (can't have voted for 2 people)."""
        # Group previous vote info by subject
        previous_votes_by_subject = {}
        
        for i, info in enumerate(contestant.information_bank):
            if info['type'] == 'previous_vote' and info.get('subject') and info.get('target'):
                subject = info.get('subject')
                if subject not in previous_votes_by_subject:
                    previous_votes_by_subject[subject] = []
                previous_votes_by_subject[subject].append((info['target'], i))
        
        # Check each subject for conflicts
        for subject, vote_list in previous_votes_by_subject.items():
            if len(vote_list) >= 2:
                # Multiple previous votes for same person - resolve conflict
                # If contestant themselves voted, they know the truth
                if subject == contestant:
                    # Keep only their actual vote (should be only one anyway)
                    continue
                
                # Create scored list of (target, score, index)
                vote_scores = []
                
                for target, idx in vote_list:
                    score = 0
                    
                    # Check if in alliance with the informant
                    if contestant.has_real_alliance_with(target):
                        score += 50
                    
                    # Add relationship score
                    score += contestant.get_relationship(target)
                    
                    # Add small random value for tie-breaking
                    score += random.random() * 0.1
                    
                    vote_scores.append((target, score, idx))
                
                # Sort by score (highest first) and keep only the first
                vote_scores.sort(key=lambda x: x[1], reverse=True)
                indices_to_keep = {vote_scores[0][2]}
                
                # Remove all other previous vote info for this subject
                for _, idx in reversed(vote_list):
                    if idx not in indices_to_keep:
                        contestant.information_bank.pop(idx)
    
    def resolve_consensus_vote_conflicts(self, contestant: Contestant) -> None:
        """Resolve conflicting consensus vote information."""
        # Find all consensus vote information
        consensus_info_list = []
        self_discovered_idx = None
        
        for i, info in enumerate(contestant.information_bank):
            if info['type'] == 'consensus_vote':
                is_self_discovered = info.get('self_discovered', False)
                consensus_info_list.append((info.get('targets', []), i, is_self_discovered))
                if is_self_discovered:
                    self_discovered_idx = i
        
        if len(consensus_info_list) >= 2:
            # Check if we have multiple self-discovered consensus votes
            self_discovered_indices = [idx for targets, idx, is_self in consensus_info_list if is_self]
            
            if len(self_discovered_indices) >= 2:
                # Multiple self-discovered consensus votes - keep the most recent one (highest day)
                most_recent_day = -1
                most_recent_idx = None
                
                for targets, idx, is_self in consensus_info_list:
                    if is_self:
                        info_day = contestant.information_bank[idx].get('day', 0)
                        if info_day > most_recent_day:
                            most_recent_day = info_day
                            most_recent_idx = idx
                
                # Remove all consensus info except the most recent self-discovered one
                for targets, idx, is_self in reversed(consensus_info_list):
                    if idx != most_recent_idx and idx < len(contestant.information_bank):
                        contestant.information_bank.pop(idx)
            elif self_discovered_idx is not None:
                # Only one self-discovered consensus - remove all others
                for targets, idx, is_self in reversed(consensus_info_list):
                    if idx != self_discovered_idx and idx < len(contestant.information_bank):
                        contestant.information_bank.pop(idx)
            else:
                # No self-discovered consensus - use alliance/relationship scoring
                consensus_scores = []
                
                for targets, idx, is_self in consensus_info_list:
                    score = 0
                    
                    # Score based on targets in the consensus
                    for target in targets:
                        if contestant.has_real_alliance_with(target):
                            score -= 50  # Less likely to believe allies are consensus
                        score -= contestant.get_relationship(target)
                    
                    # Add small random value for tie-breaking  
                    score += random.random() * 0.1
                    
                    consensus_scores.append((targets, score, idx))
                
                # Sort by score (highest first) and keep only the first
                consensus_scores.sort(key=lambda x: x[1], reverse=True)
                indices_to_keep = {consensus_scores[0][2]}
                
                # Remove all other consensus vote info
                for targets, idx, is_self in reversed(consensus_info_list):
                    if idx not in indices_to_keep and idx < len(contestant.information_bank):
                        contestant.information_bank.pop(idx)
    
    def day_intro(self) -> None:
        """Display the introduction for the current day."""
        # Apply start-of-day processing first
        self.apply_start_of_day_processing()
        
        # Process work streaks and apply penalties
        self.process_daily_work_streaks()
        
        self.narration(f"Day {self.day} in Survivor")
        self.display_tribes()
        
        # Reset daily tracking for snooping
        self.today_npc_actions = {}
        self.today_idol_searches = {}
        self.contestants_who_interacted_with_player = []
        
        # Reset daily action tracking
        self.actions_taken_today = 0
        
        # Reset controlled actions tracking
        self.npcs_who_performed_controlled_actions = set()
        
        # Reset NPC actions completion flag and action round tracking
        self.npc_actions_completed_today = False
        self.npc_action_round = 0
        
        # Reset NPC action counters for all contestants
        for contestant in self.get_active_contestants():
            contestant.npc_actions_taken_today = 0
            # Reset daily work flag
            if hasattr(contestant, 'worked_today'):
                contestant.worked_today = False
            # Reset daily survival focus flag
            contestant.focused_on_survival_today = False
        
        # Move next-day skips to current day skips and clear next-day skips
        if hasattr(self, 'npcs_who_skip_next_day_action'):
            # NPCs who were marked to skip next day now skip today
            self.npcs_who_performed_controlled_actions.update(self.npcs_who_skip_next_day_action)
            self.npcs_who_skip_next_day_action = set()
        
        # Clean expired busted penalties
        self.clean_expired_busted_penalties()
        
        # Clean expired temporary persuasion modifiers
        self.clean_expired_persuasion_modifiers()
        
        # Check if player needs to set a vote target (day 3+ with no target)
        if self.day >= 3 and self.player and not self.player.eliminated:
            if hasattr(self, 'player_vote_target_eliminated') and self.player_vote_target_eliminated:
                # Player's vote target was eliminated - prompt for new target
                self.prompt_player_vote_target("You successfully eliminated your vote target. Who would you like to target next?")
                self.player_vote_target_eliminated = False  # Reset the flag
            elif self.player.vote_target is None and self.day == 3:
                # Only show this message on day 3 when no target has been set
                self.prompt_player_vote_target("Now that you've gotten to know your tribe mates, who are you most likely to vote for?")
            elif self.player.vote_target is None and self.day > 3:
                # For days after 3, use a generic message
                self.prompt_player_vote_target("Your vote target has been eliminated. Who would you like to target next?")
        
        
        # Clean expired reveal bonuses
        self.clean_expired_reveal_bonuses()
    
    def handle_work_penalty_warning(self) -> None:
        """Handle work penalty warning if due."""
        if self.player and not self.player.eliminated and self.player.work_penalty_warning_due:
            # Get tribemates for random selection
            player_tribe = self.get_player_tribe()
            tribemates = [c for c in player_tribe if not c.is_player and not c.eliminated]
            
            if tribemates:
                # Select random tribemate to deliver the warning
                warning_deliverer = random.choice(tribemates)
                
                # Display the warning dialogue with proper formatting
                self.narration(f"{warning_deliverer.name} approaches you.")
                self.contestant_speaks(warning_deliverer, "I just wanted to let you know, people are starting to get annoyed that you haven't been working around camp.")
                self.narration("Looks like you've been slacking. Better start carrying your weight.")
                
                # Reset the warning flag
                self.player.work_penalty_warning_due = False
        
        # Process daily survival rolls for all contestants
        self.apply_daily_survival_rolls()
        
        # Handle vote pitch confrontations from previous day
        self.handle_vote_pitch_confrontations()
        
        # Clean expired Final 2 betrayal penalties
        self.clean_expired_final_2_betrayal_penalties()
    
    def apply_daily_survival_rolls(self) -> None:
        """Apply daily survival rolls for all active contestants."""
        all_contestants = self.get_active_contestants()
        
        for contestant in all_contestants:
            old_status = contestant.survival_status
            
            # Roll d20 + survival skill + work bonus
            roll = random.randint(1, 20)
            work_bonus = contestant.work_bonus_tomorrow
            total_roll = roll + contestant.survival_skill + work_bonus
            
            # Determine survival status change
            survival_change = 0
            if roll == 1:  # Critical Failure (natural 1)
                survival_change = -2
                outcome = "Critical Failure"
            elif total_roll <= 7:  # Failure
                survival_change = -1
                outcome = "Failure"
            elif total_roll <= 13:  # Neutral
                survival_change = 0
                outcome = "Neutral"
            elif total_roll <= 19:  # Success
                survival_change = 1
                outcome = "Success"
            else:  # Critical Success (20+ or natural 20)
                survival_change = 2
                outcome = "Critical Success"
            
            # Apply survival status change (clamped between -1 and 3)
            contestant.survival_status = max(-1, min(3, contestant.survival_status + survival_change))
            
            # Reset work bonus after applying it
            contestant.work_bonus_tomorrow = 0
            
            # Survival rolls are processed silently - no player notifications
    
    def process_daily_work_streaks(self) -> None:
        """Process daily work streak tracking and apply penalties for not working."""
        all_contestants = self.get_active_contestants()
        
        for contestant in all_contestants:
            # Skip if this contestant worked today
            if hasattr(contestant, 'worked_today') and contestant.worked_today:
                contestant.worked_today = False  # Reset for next day
                continue
            
            # Contestant didn't work today - increment no-work streak
            contestant.consecutive_no_work_days += 1
            contestant.consecutive_work_days = 0
            
            # Apply penalties based on streak length
            if contestant.consecutive_no_work_days == 3:
                # Day 4: Relationship penalty with all tribemates
                tribe_contestants = self.get_active_contestants(contestant.tribe)
                for tribemate in tribe_contestants:
                    if tribemate != contestant and not tribemate.eliminated:
                        contestant.modify_relationship(tribemate, -1)
                        tribemate.modify_relationship(contestant, -1)
                
                if contestant.is_player:
                    # Mark that player should receive work penalty warning at start of next day
                    contestant.work_penalty_warning_due = True
            
            elif contestant.consecutive_no_work_days == 4:
                # Day 5: Non-allies add you to target roster
                tribe_contestants = self.get_active_contestants(contestant.tribe)
                for tribemate in tribe_contestants:
                    if (tribemate != contestant and not tribemate.eliminated and 
                        not contestant.has_real_alliance_with(tribemate) and
                        contestant not in tribemate.target_roster):
                        tribemate.target_roster.append(contestant)
                
                if contestant.is_player:
                    # Mark that player should receive work penalty warning at start of next day
                    contestant.work_penalty_warning_due = True
            
            elif contestant.consecutive_no_work_days == 5:
                # Day 6: Non-allies make you their vote target (random selection if multiple lazy contestants)
                lazy_contestants = [c for c in self.get_active_contestants(contestant.tribe) 
                                  if c.consecutive_no_work_days >= 5 and not c.eliminated and c != contestant]
                lazy_contestants.append(contestant)
                
                tribe_contestants = self.get_active_contestants(contestant.tribe)
                for tribemate in tribe_contestants:
                    if (tribemate != contestant and not tribemate.eliminated and 
                        not contestant.has_real_alliance_with(tribemate)):
                        # Choose random lazy contestant as vote target
                        chosen_target = random.choice(lazy_contestants)
                        tribemate.vote_target = chosen_target
                        
                        # Add others to target roster
                        for lazy_contestant in lazy_contestants:
                            if lazy_contestant != chosen_target and lazy_contestant not in tribemate.target_roster:
                                tribemate.target_roster.append(lazy_contestant)
                
                if contestant.is_player:
                    # Mark that player should receive work penalty warning at start of next day
                    contestant.work_penalty_warning_due = True
            
            elif contestant.consecutive_no_work_days >= 6:
                # Day 7+: Alliance members roll to potentially target you (only same tribe)
                for ally in contestant.alliance_roster:
                    if not ally.eliminated and ally.tribe == contestant.tribe:
                        roll = random.randint(1, 20)
                        if roll <= 10:  # 1-10: becomes vote target
                            ally.vote_target = contestant
                            # Meta-game information - don't show to player
                        # 11-20: no change
    
    def reset_work_streaks(self, reason: str) -> None:
        """Reset work streaks for all contestants due to major game events."""
        all_contestants = self.get_active_contestants()
        
        for contestant in all_contestants:
            contestant.consecutive_work_days = 0
            contestant.consecutive_no_work_days = 0
            contestant.work_bonus_tomorrow = 0
            if hasattr(contestant, 'worked_today'):
                contestant.worked_today = False
        
    
    def handle_vote_pitch_confrontations(self) -> None:
        """Handle confrontations from NPCs who realized the player broke vote agreements."""
        if not self.player.vote_pitch_confrontations:
            return
        
        for pitcher, agreed_target in self.player.vote_pitch_confrontations:
            # Skip if the pitcher was eliminated
            if pitcher.eliminated:
                continue
            
            self.narration(f"Shortly after you wake up, {pitcher.name} approaches you. {pitcher.get_pronoun('subject').title()} wants to discuss the recent vote.")
            
            # Random NPC dialogue
            npc_dialogues = [
                f"Hey... what happened with the vote? I thought you were going to vote for {agreed_target.name}.",
                f"Why didn't you vote for {agreed_target.name}? I thought we had a plan.",
                f"I wish you had told me you changed your mind. I thought we were voting for {agreed_target.name}. I feel so stupid now."
            ]
            
            self.contestant_speaks(pitcher, random.choice(npc_dialogues))
            
            print("\nHow do you respond?")
            print("1. Apologize and try to do damage control")
            print("2. Make an excuse")
            
            while True:
                try:
                    response = int(input("Enter your choice (1-2): "))
                    if response == 1:
                        # Apologize dialogue options
                        apology_responses = [
                            "I'm really sorry, I should have told you that my plan changed.",
                            "You have every right to be upset. I'm sorry I wasn't honest with you.",
                            "I'm sorry for misleading you. I hope this doesn't mean we can't work together."
                        ]
                        self.contestant_speaks(self.player, random.choice(apology_responses))
                        break
                    elif response == 2:
                        # Excuse dialogue options
                        excuse_responses = [
                            f"I would have told you that the plan changed, but I didn't get a chance to talk to you before tribal council.",
                            f"I thought you knew that we weren't voting for {agreed_target.name} anymore. Didn't anyone tell you?",
                            "I never agreed to that. You're definitely remembering it wrong."
                        ]
                        self.contestant_speaks(self.player, random.choice(excuse_responses))
                        break
                    else:
                        print("Invalid choice. Please enter 1 or 2.")
                except ValueError:
                    print("Invalid input. Please enter a number.")
            
            self.narration("You sweat out the remainder of the conversation before you proceed with your day.")
        
        # Clear confrontations after handling them
        self.player.vote_pitch_confrontations.clear()
    
    def small_talk_with(self, target_choice: Contestant, player_initiated: bool = True) -> None:
        """Player engages in small talk with a specific contestant to improve relationships."""
        # Roll for small talk with social skill
        if player_initiated:
            self.narration(f"You approach {target_choice.name} for some casual conversation.")
        
        # Get player's social skill
        social_skill = self.player.social_skill
        
        # Roll with skill
        base_roll, total, outcome = self.roll_with_skill(social_skill, f"Small Talk with {target_choice.name}")
        
        # Apply outcomes based on the roll
        if outcome == "critical_failure":
            # No change
            self.narration(f"The conversation feels a bit awkward and doesn't go as smoothly as you'd hoped.")
            responses = [
                "Yeah... uh, I should probably get back to camp chores.",
                "Hmm, interesting... Well, see you around.",
                "Right... anyway, I need to go gather some firewood."
            ]
            self.contestant_speaks(target_choice, random.choice(responses))
        elif outcome in ["failure", "neutral", "success"]:
            # +1 to relationship
            old_rel = self.player.get_relationship(target_choice)
            self.player.modify_relationship(target_choice, 1)
            target_choice.modify_relationship(self.player, 1)  # Make it mutual
            
            self.narration(f"You have a pleasant conversation with {target_choice.name} about life back home and the game.")
            responses = [
                "It's nice to get to know you better!",
                "Thanks for the chat, it's good to connect out here.",
                "I enjoyed talking with you. Let's do this again sometime."
            ]
            self.contestant_speaks(target_choice, random.choice(responses))
        else:  # critical_success
            # +2 to relationship
            old_rel = self.player.get_relationship(target_choice)
            self.player.modify_relationship(target_choice, 2)
            target_choice.modify_relationship(self.player, 2)  # Make it mutual
            
            self.narration(f"You and {target_choice.name} really hit it off! The conversation flows naturally and you find yourselves laughing together.")
            responses = [
                "Wow, we really click! I feel like I've found a real friend out here.",
                "This was amazing! I haven't laughed this hard since we got here.",
                "You know what? I'm really glad we're on the same tribe!"
            ]
            self.contestant_speaks(target_choice, random.choice(responses))
    
    def build_alliance_with(self, ally: Contestant) -> None:
        """Player builds an alliance with a specific contestant using d20 mechanics."""
        if self.player.has_real_alliance_with(ally) or self.player.has_fake_alliance_with(ally):
            self.narration(f"You're already in an alliance with {ally.name}.")
            return
        
        # Check if alliance rebuilding is allowed after previous break
        if not self.player.can_rebuild_alliance_with(ally):
            player_rel = self.player.get_relationship(ally)
            ally_rel = ally.get_relationship(self.player)
            self.narration(f"You previously broke an alliance with {ally.name}. Both of you need a relationship of 3 to rebuild trust.")
            self.narration(f"Current relationships: You → {ally.name}: {player_rel}, {ally.name} → You: {ally_rel}")
            return
        
        # Check if player tried to pitch to this person previously and they asked for time
        if hasattr(self, 'pending_alliance_requests'):
            # Check if this ally has a pending request
            pending_ally = next((req for req in self.pending_alliance_requests if req[0] == ally), None)
            if pending_ally:
                self.narration(f"{ally.name} asked for time to think about your previous alliance proposal.")
        
        # Roll d20 + persuasiveness + relationship
        roll = random.randint(1, 20)
        persuasiveness_bonus = self.player.persuasive_skill
        relationship_bonus = self.player.get_relationship(ally)
        
        # Get temporary persuasion modifier from probe responses
        temp_persuasion_bonus = self.get_temporary_persuasion_modifier(self.player, ally)
        
        # Final 2 Alliance Benefit 3: +1 persuasion when pitching an alliance to Final 2 partner
        final_2_bonus = 0
        if (self.player.has_real_final_2_with(ally) or 
            self.player.has_fake_final_2_with(ally)):
            final_2_bonus = 1
        
        # Get resistance modifier from the ally
        resistance_modifier = self.roll_resistance_to_persuasion(ally)
        
        # Apply busted penalty if applicable
        busted_penalty = self.get_busted_penalty(self.player, ally)
        
        # Apply Final 2 betrayal penalty if applicable
        final_2_betrayal_penalty = self.get_final_2_betrayal_penalty(self.player, ally)
        
        # Apply reveal bonus if applicable
        reveal_bonus = 0
        if hasattr(self, 'reveal_bonuses') and (self.player, ally) in self.reveal_bonuses:
            if self.reveal_bonuses[(self.player, ally)] >= self.day:
                reveal_bonus = 1
        
        # Alliance count modifiers
        alliance_count_bonus = 0
        ally_alliance_count = len(ally.alliance_roster)
        if ally_alliance_count == 0:
            alliance_count_bonus = 2  # +2 if no alliances
        elif ally_alliance_count == 1:
            alliance_count_bonus = 1  # +1 if only 1 alliance
        
        # Targeting penalties
        targeting_penalty = 0
        if ally.vote_target == self.player:
            targeting_penalty -= 2  # -2 if player is the vote target
        elif self.player in ally.target_roster:
            targeting_penalty -= 1  # -1 if player is on target roster
        
        # Apply group alliance persuasion bonus
        group_alliance_persuasion_bonus = self.get_group_alliance_persuasion_bonus(self.player, ally)
        
        # Apply survival status modifier (all rolls for -1/3, general rolls otherwise)
        survival_modifier = self.player.get_survival_status_modifier("all")
        
        total_roll = roll + persuasiveness_bonus + relationship_bonus + resistance_modifier + busted_penalty + final_2_betrayal_penalty + reveal_bonus + final_2_bonus + alliance_count_bonus + targeting_penalty + group_alliance_persuasion_bonus + temp_persuasion_bonus + survival_modifier
        
        self.narration(f"You pull {ally.name} aside and pitch an alliance.")
        
        # Determine outcome based on total roll
        if roll == 1:  # Natural 1 is always critical failure
            # NPC rejects, lies, and bluffs back (appears as critical success)
            # First check if we can generate bluff information
            can_bluff = False
            bluff_dialogue = ""
            
            # For first 3 days, only use vote_target bluffs
            if self.day <= 3:
                bluff_type = 'vote_target'
            else:
                bluff_type = random.choice(['vote_target', 'idol', 'alliance'])
                
            if bluff_type == 'vote_target':
                # Pick random contestants for the bluff
                potential_subjects = [c for c in self.get_active_contestants(ally.tribe) if c != ally and c != self.player]
                if len(potential_subjects) >= 2:
                    subject = random.choice(potential_subjects)
                    potential_targets = [c for c in self.get_active_contestants(ally.tribe) if c != subject]
                    if potential_targets:
                        target = random.choice(potential_targets)
                        if target == self.player:
                            bluff_dialogue = f"I heard {subject.name} is planning to vote for you."
                        elif target == ally:
                            bluff_dialogue = f"I heard {subject.name} is planning to vote for me."
                        else:
                            bluff_dialogue = f"I heard {subject.name} is planning to vote for {target.name}."
                        can_bluff = True
            
            elif bluff_type == 'idol':
                # Pick random contestant to claim has idol
                potential_subjects = [c for c in self.get_active_contestants(ally.tribe) if c != self.player]
                if potential_subjects:
                    subject = random.choice(potential_subjects)
                    bluff_dialogue = f"Just so you know, {subject.name} has a hidden immunity idol."
                    can_bluff = True
                else:
                    # Fallback if no valid subjects for idol bluff - make up a generic idol bluff about eliminated contestant
                    eliminated_contestants = [c for c in self.contestants if c.eliminated and c.tribe == ally.tribe]
                    if eliminated_contestants:
                        subject = random.choice(eliminated_contestants)
                        bluff_dialogue = f"Just so you know, {subject.name} had a hidden immunity idol before they were voted out."
                        can_bluff = True
                    else:
                        # Create a generic idol warning if no eliminated contestants available
                        bluff_dialogue = f"Just so you know, someone on our tribe definitely has a hidden immunity idol. I'm not sure who though."
                        can_bluff = True
            
            else:  # alliance bluff
                # Pick two random contestants for alliance bluff
                potential_subjects = [c for c in self.get_active_contestants(ally.tribe) if c != ally and c != self.player]
                if len(potential_subjects) >= 2:
                    members = random.sample(potential_subjects, 2)
                    bluff_dialogue = f"{members[0].name} and {members[1].name} have a secret alliance."
                    can_bluff = True
                else:
                    # Fallback if not enough subjects for alliance bluff - create a generic warning
                    eliminated_contestants = [c for c in self.contestants if c.eliminated and c.tribe == ally.tribe]
                    if eliminated_contestants and potential_subjects:
                        # Bluff about eliminated contestant having alliance with current contestant
                        eliminated = random.choice(eliminated_contestants)
                        current = random.choice(potential_subjects)
                        bluff_dialogue = f"{eliminated.name} told me before they left that {current.name} can't be trusted."
                        can_bluff = True
                    elif potential_subjects:
                        # Generic trust warning about someone
                        subject = random.choice(potential_subjects)
                        bluff_dialogue = f"I've been getting bad vibes from {subject.name} lately. Just something to keep in mind."
                        can_bluff = True
                    else:
                        # Last resort - generic game warning
                        bluff_dialogue = f"Things are about to get really crazy around here. People are starting to make big moves."
                        can_bluff = True
            
            # Now deliver the appropriate dialogue
            if can_bluff:
                self.contestant_speaks(ally, f"I'm definitely with you {self.player.name}. And between you and me...")
                self.contestant_speaks(ally, bluff_dialogue)
                
                # Add the bluff information to player's bank
                if bluff_type == 'vote_target' and can_bluff:
                    self.add_player_information('vote_target', subject, target)
                elif bluff_type == 'idol' and can_bluff:
                    if 'had a hidden immunity idol before' in bluff_dialogue:
                        self.add_player_information('had_idol', subject)
                    elif 'has a hidden immunity idol' in bluff_dialogue:
                        self.add_player_information('has_idol', subject)
                    # Don't add info for generic idol warnings
                elif bluff_type == 'alliance' and can_bluff:
                    if 'have a secret alliance' in bluff_dialogue:
                        self.add_player_information('alliance', members[0], members[1])
                        self.add_player_information('alliance', members[1], members[0])
                    elif 'can\'t be trusted' in bluff_dialogue:
                        self.add_player_information('trust_warning', current)
                    elif 'bad vibes' in bluff_dialogue:
                        self.add_player_information('trust_warning', subject)
            else:
                # Use success dialogue as fallback when can't bluff
                self.contestant_speaks(ally, f"I'm with you {self.player.name}, you can count on my vote.")
            
            self.narration(f"You've formed a strong alliance with {ally.name}.")
            
            # Create fake alliance - player thinks it's real but ally doesn't
            self.player.fake_alliance_roster.append(ally)
            # Ally gets the one-sided benefits (they can pitch to player with +1)
            ally.alliance_roster.append(self.player)
            
            # Game Security: NPC was approached to be in an alliance (+1)
            ally.modify_base_game_security(1, "Approached for alliance", silent=True)
            ally.mark_pitched_to_today()
            
            # Update ally's vote target and target roster if they were targeting the player
            if ally.vote_target == self.player:
                self.assign_random_vote_target(ally)
            ally.target_roster = [c for c in ally.target_roster if c != self.player]
            
            # Add alliance info (player thinks it's real)
            self.add_player_information('alliance', self.player, ally)
            
            # Remove from pending requests since player thinks they have alliance
            if hasattr(self, 'pending_alliance_requests'):
                self.pending_alliance_requests = [(c, d) for c, d in self.pending_alliance_requests if c != ally]
            
        elif roll == 20:  # Natural 20 is always critical success
            # Check for shareable information first
            shared_actual_info = False
            shareable_info = []
            if ally.information_bank:
                shareable_info = [info for info in ally.information_bank 
                                if not (info['type'] == 'vote_target' 
                                       and info.get('subject') == ally 
                                       and info.get('target') == self.player)
                                and info.get('subject') != self.player  # Don't reveal player's own actions
                                and not (info['type'] == 'previous_vote' and info.get('subject') == self.player)  # Extra check for previous_vote
                                and not (info['type'] == 'alliance' 
                                       and info.get('subject') == ally 
                                       and info.get('target') == self.player)  # Don't claim false alliances with player
                                and not (info['type'] == 'alliance' 
                                       and info.get('subject') == self.player 
                                       and info.get('target') == ally)  # Don't claim player has alliance with them
                                and not (info['type'] == 'final_2' 
                                       and info.get('subject') == self.player)  # Don't reveal player's final 2 deals
                                and not (info['type'] == 'final_2' 
                                       and info.get('target') == self.player)]  # Don't reveal final 2 deals with player
            
            if shareable_info:
                # NPC accepts and shares information
                self.contestant_speaks(ally, f"I'm definitely with you {self.player.name}. And between you and me...")
                
                shared_actual_info = True
                shared_info = random.choice(shareable_info)
                if shared_info['type'] == 'has_idol':
                    if shared_info.get('subject') == ally:
                        self.contestant_speaks(ally, f"I have a hidden immunity idol.")
                    else:
                        self.contestant_speaks(ally, f"{shared_info.get('subject').name} has a hidden immunity idol.")
                elif shared_info['type'] == 'vote_target':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally:
                            self.contestant_speaks(ally, f"I'm planning to vote for {shared_info['target'].name}.")
                        else:
                            if shared_info['target'] == ally:
                                self.contestant_speaks(ally, f"{shared_info.get('subject').name} is planning to vote for me.")
                            else:
                                if shared_info['target'] == self.player:
                                    self.contestant_speaks(ally, f"{shared_info.get('subject').name} is planning to vote for you.")
                                else:
                                    self.contestant_speaks(ally, f"{shared_info.get('subject').name} is planning to vote for {shared_info['target'].name}.")
                elif shared_info['type'] == 'alliance':
                    if 'target' in shared_info:
                        # Safety check for corrupted alliance info
                        if hasattr(shared_info['target'], 'name'):
                            if shared_info.get('subject') == ally and shared_info['target'] != self.player and not shared_info['target'].eliminated:
                                self.contestant_speaks(ally, f"I'm working with {shared_info['target'].name}.")
                            elif shared_info['target'] == ally and not shared_info.get('subject').eliminated:
                                self.contestant_speaks(ally, f"{shared_info.get('subject').name} and I are working together.")
                            elif shared_info.get('subject') != self.player and shared_info['target'] != self.player and not shared_info.get('subject').eliminated and not shared_info['target'].eliminated:
                                self.contestant_speaks(ally, f"{shared_info.get('subject').name} and {shared_info['target'].name} are working together.")
                        else:
                            # Handle corrupted alliance info (skip sharing it)
                            self.contestant_speaks(ally, f"I trust you completely.")
                elif shared_info['type'] == 'target_roster':
                    if 'targets' in shared_info and shared_info['targets']:
                        targets_names = [t.name for t in shared_info['targets']]
                        if shared_info.get('subject') == ally:
                            self.contestant_speaks(ally, f"I want to get rid of {' and '.join(targets_names)}.")
                        else:
                            self.contestant_speaks(ally, f"{shared_info.get('subject').name} wants to get rid of {' and '.join(targets_names)}.")
                elif shared_info['type'] == 'vote_pitch':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally:
                            self.contestant_speaks(ally, f"I was approached about voting for {shared_info['target'].name}.")
                        else:
                                if shared_info['target'] == ally:
                                    self.contestant_speaks(ally, f"{shared_info.get('subject').name} pitched voting for me.")
                                else:
                                    self.contestant_speaks(ally, f"{shared_info.get('subject').name} pitched voting for {shared_info['target'].name}.")
                elif shared_info['type'] == 'previous_vote':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally:
                            if shared_info['target'] == self.player:
                                self.contestant_speaks(ally, f"I voted for you at the last tribal council.")
                            else:
                                self.contestant_speaks(ally, f"I voted for {shared_info['target'].name} at the last tribal council.")
                        else:
                                if shared_info['target'] == ally:
                                    self.contestant_speaks(ally, f"{shared_info.get('subject').name} voted for me at the last tribal council.")
                                else:
                                    self.contestant_speaks(ally, f"{shared_info.get('subject').name} voted for {shared_info['target'].name} at the last tribal council.")
                elif shared_info['type'] == 'consensus_vote':
                    if 'target' in shared_info:
                        if shared_info['target'] == ally:
                            self.contestant_speaks(ally, f"Word is going around that I'm getting voted out next.")
                        elif shared_info['target'] == self.player:
                            self.contestant_speaks(ally, f"Word is going around that you're getting voted out next.")
                        else:
                            self.contestant_speaks(ally, f"Word is going around that {shared_info['target'].name} is getting voted out next.")
                elif shared_info['type'] == 'final_2':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally and shared_info['target'] != self.player:
                            self.contestant_speaks(ally, f"I have a final 2 deal with {shared_info['target'].name}.")
                        elif shared_info['target'] == ally and shared_info.get('subject') != self.player:
                            self.contestant_speaks(ally, f"{shared_info.get('subject').name} and I have a final 2 deal.")
                        elif shared_info.get('subject') != self.player and shared_info['target'] != self.player:
                            self.contestant_speaks(ally, f"{shared_info.get('subject').name} and {shared_info['target'].name} have a final 2 deal.")
                elif shared_info['type'] == 'has_final_2':
                    if shared_info.get('subject') == ally:
                        self.contestant_speaks(ally, f"I have a final 2 deal with someone.")
                    else:
                        self.contestant_speaks(ally, f"{shared_info.get('subject').name} has a final 2 deal with someone.")
                elif shared_info['type'] == 'final_2_pitch':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally:
                            self.contestant_speaks(ally, f"I was offered a final 2 deal by {shared_info['target'].name}.")
                        else:
                            self.contestant_speaks(ally, f"{shared_info.get('subject').name} pitched a final 2 deal to {shared_info['target'].name}.")
                else:
                    # Fallback for unrecognized info types or missing data
                    if ally.vote_target:
                        self.contestant_speaks(ally, f"I'm planning to vote for {ally.vote_target.name}.")
                        # Add this vote target info to player's bank
                        vote_info = {
                            'type': 'vote_target',
                            'subject': ally,
                            'target': ally.vote_target,
                            'day': self.day
                        }
                        self.player.information_bank.append(vote_info)
                    else:
                        self.contestant_speaks(ally, f"I trust you completely.")
                
                # Add the shared info to player's information bank (for valid shared_info)
                self.player.information_bank.append(shared_info.copy())
                
                # Check for Final 2 betrayal if player learned about a Final 2 deal
                if shared_info.get('type') == 'final_2' and shared_info.get('subject') and shared_info.get('target'):
                    self.check_for_final_2_betrayal(self.player, shared_info.get('subject'), shared_info['target'])
            else:
                # No shareable information - use success dialogue
                self.contestant_speaks(ally, f"I'm with you {self.player.name}, you can count on my vote.")
            
            self.narration(f"You've formed a strong alliance with {ally.name}.")
            
            # Form real alliance - both get benefits
            self.player.alliance_roster.append(ally)
            ally.alliance_roster.append(self.player)
            
            # Add to Game Move Bank (Level 1) for both players
            self.player.add_game_move('alliance_formed', 1, self.day, f"formed an alliance with {ally.name.title()}")
            ally.add_game_move('alliance_formed', 1, self.day, f"formed an alliance with {self.player.name.title()}")
            
            # Track early alliances for Level 3 move (first 6 days)
            if self.day <= 6:
                self.player.early_alliances[ally] = self.day
                ally.early_alliances[self.player] = self.day
            
            # Game Security: NPC was approached to be in an alliance (+1)
            ally.modify_base_game_security(1, "Approached for alliance", silent=True)
            
            # Update ally's vote target and target roster if they were targeting the player
            if ally.vote_target == self.player:
                self.assign_random_vote_target(ally)
            ally.target_roster = [c for c in ally.target_roster if c != self.player]
            
            # Add real alliance to information banks
            self.add_player_information('alliance', self.player, ally)
            self.add_information_with_day(ally, 'alliance', ally, self.player)
            
            # Improve relationship
            self.player.modify_relationship(ally, 1)
            ally.modify_relationship(self.player, 1)
            
            # Remove from pending requests if they were there
            if hasattr(self, 'pending_alliance_requests'):
                self.pending_alliance_requests = [(c, d) for c, d in self.pending_alliance_requests if c != ally]
                
        elif total_roll <= 7:  # Failure
            # NPC rejects but lies and pretends to accept
            self.contestant_speaks(ally, f"I'm with you {self.player.name}, you can count on my vote.")
            self.narration(f"You've formed an alliance with {ally.name}.")
            
            # Create fake alliance - player thinks it's real but ally doesn't
            self.player.fake_alliance_roster.append(ally)
            # Ally gets the one-sided benefits (they can pitch to player with +1)
            ally.alliance_roster.append(self.player)
            
            # Update ally's vote target and target roster if they were targeting the player
            if ally.vote_target == self.player:
                self.assign_random_vote_target(ally)
            ally.target_roster = [c for c in ally.target_roster if c != self.player]
            
            # Add alliance info (player thinks it's real)
            self.add_player_information('alliance', self.player, ally)
            
            # Remove from pending requests since player thinks they have alliance
            if hasattr(self, 'pending_alliance_requests'):
                self.pending_alliance_requests = [(c, d) for c, d in self.pending_alliance_requests if c != ally]
            
        elif total_roll <= 13:  # Neutral
            # NPC asks for time to think
            self.contestant_speaks(ally, f"Let me think about it. Can we talk again tomorrow?")
            self.narration(f"{ally.name} wants some time to consider your proposal.")
            
            # Track that this ally needs to be asked again with the current day
            if not hasattr(self, 'pending_alliance_requests'):
                self.pending_alliance_requests = []
            # Check if ally already has a pending request
            if not any(req[0] == ally for req in self.pending_alliance_requests):
                self.pending_alliance_requests.append((ally, self.day))
                
        elif total_roll <= 19:  # Success
            # NPC accepts the alliance
            self.contestant_speaks(ally, f"I'm with you {self.player.name}, you can count on my vote.")
            self.narration(f"You've formed an alliance with {ally.name}.")
            
            # Form real alliance - both get benefits
            self.player.alliance_roster.append(ally)
            ally.alliance_roster.append(self.player)
            
            # Update ally's vote target and target roster if they were targeting the player
            if ally.vote_target == self.player:
                self.assign_random_vote_target(ally)
            ally.target_roster = [c for c in ally.target_roster if c != self.player]
            
            # Add real alliance to information banks
            self.add_player_information('alliance', self.player, ally)
            self.add_information_with_day(ally, 'alliance', ally, self.player)
            
            # Remove from pending requests if they were there
            if hasattr(self, 'pending_alliance_requests'):
                self.pending_alliance_requests = [(c, d) for c, d in self.pending_alliance_requests if c != ally]
            
        else:  # Critical success (total 20+)
            # Check if there's information to share first
            shared_actual_info = False
            shareable_info = []
            if ally.information_bank:
                shareable_info = [info for info in ally.information_bank 
                                if not (info['type'] == 'vote_target' 
                                       and info.get('subject') == ally 
                                       and info.get('target') == self.player)
                                and info.get('subject') != self.player  # Don't reveal player's own actions
                                and not (info['type'] == 'previous_vote' and info.get('subject') == self.player)  # Extra check for previous_vote
                                and not (info['type'] == 'alliance' 
                                       and info.get('subject') == ally 
                                       and info.get('target') == self.player)  # Don't claim false alliances with player
                                and not (info['type'] == 'alliance' 
                                       and info.get('subject') == self.player 
                                       and info.get('target') == ally)  # Don't claim player has alliance with them
                                and not (info['type'] == 'final_2' 
                                       and info.get('subject') == self.player)  # Don't reveal player's final 2 deals
                                and not (info['type'] == 'final_2' 
                                       and info.get('target') == self.player)]  # Don't reveal final 2 deals with player
            
            # Use appropriate dialogue based on whether there's info to share
            if shareable_info:
                # NPC accepts and shares information
                self.contestant_speaks(ally, f"I'm definitely with you {self.player.name}. And between you and me...")
                
                shared_actual_info = True
                shared_info = random.choice(shareable_info)
                if shared_info['type'] == 'has_idol':
                    if shared_info.get('subject') == ally:
                        self.contestant_speaks(ally, f"I have a hidden immunity idol.")
                    else:
                        self.contestant_speaks(ally, f"{shared_info.get('subject').name} has a hidden immunity idol.")
                elif shared_info['type'] == 'vote_target':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally:
                            self.contestant_speaks(ally, f"I'm planning to vote for {shared_info['target'].name}.")
                        else:
                            if shared_info['target'] == ally:
                                self.contestant_speaks(ally, f"{shared_info.get('subject').name} is planning to vote for me.")
                            else:
                                if shared_info['target'] == self.player:
                                    self.contestant_speaks(ally, f"{shared_info.get('subject').name} is planning to vote for you.")
                                else:
                                    self.contestant_speaks(ally, f"{shared_info.get('subject').name} is planning to vote for {shared_info['target'].name}.")
                elif shared_info['type'] == 'alliance':
                    if 'target' in shared_info:
                        # Safety check for corrupted alliance info
                        if hasattr(shared_info['target'], 'name'):
                            if shared_info.get('subject') == ally and shared_info['target'] != self.player and not shared_info['target'].eliminated:
                                self.contestant_speaks(ally, f"I'm working with {shared_info['target'].name}.")
                            elif shared_info['target'] == ally and not shared_info.get('subject').eliminated:
                                self.contestant_speaks(ally, f"{shared_info.get('subject').name} and I are working together.")
                            elif shared_info.get('subject') != self.player and shared_info['target'] != self.player and not shared_info.get('subject').eliminated and not shared_info['target'].eliminated:
                                self.contestant_speaks(ally, f"{shared_info.get('subject').name} and {shared_info['target'].name} are working together.")
                        else:
                            # Handle corrupted alliance info (skip sharing it)
                            self.contestant_speaks(ally, f"I trust you completely.")
                elif shared_info['type'] == 'target_roster':
                    if 'targets' in shared_info and shared_info['targets']:
                        targets_names = [t.name for t in shared_info['targets']]
                        if shared_info.get('subject') == ally:
                            self.contestant_speaks(ally, f"I want to get rid of {' and '.join(targets_names)}.")
                        else:
                            self.contestant_speaks(ally, f"{shared_info.get('subject').name} wants to get rid of {' and '.join(targets_names)}.")
                elif shared_info['type'] == 'vote_pitch':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally:
                            self.contestant_speaks(ally, f"I was approached about voting for {shared_info['target'].name}.")
                        else:
                                if shared_info['target'] == ally:
                                    self.contestant_speaks(ally, f"{shared_info.get('subject').name} pitched voting for me.")
                                else:
                                    self.contestant_speaks(ally, f"{shared_info.get('subject').name} pitched voting for {shared_info['target'].name}.")
                elif shared_info['type'] == 'previous_vote':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally:
                            if shared_info['target'] == self.player:
                                self.contestant_speaks(ally, f"I voted for you at the last tribal council.")
                            else:
                                self.contestant_speaks(ally, f"I voted for {shared_info['target'].name} at the last tribal council.")
                        else:
                                if shared_info['target'] == ally:
                                    self.contestant_speaks(ally, f"{shared_info.get('subject').name} voted for me at the last tribal council.")
                                else:
                                    self.contestant_speaks(ally, f"{shared_info.get('subject').name} voted for {shared_info['target'].name} at the last tribal council.")
                elif shared_info['type'] == 'consensus_vote':
                    if 'target' in shared_info:
                        if shared_info['target'] == ally:
                            self.contestant_speaks(ally, f"Word is going around that I'm getting voted out next.")
                        elif shared_info['target'] == self.player:
                            self.contestant_speaks(ally, f"Word is going around that you're getting voted out next.")
                        else:
                            self.contestant_speaks(ally, f"Word is going around that {shared_info['target'].name} is getting voted out next.")
                elif shared_info['type'] == 'final_2':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally and shared_info['target'] != self.player:
                            self.contestant_speaks(ally, f"I have a final 2 deal with {shared_info['target'].name}.")
                        elif shared_info['target'] == ally and shared_info.get('subject') != self.player:
                            self.contestant_speaks(ally, f"{shared_info.get('subject').name} and I have a final 2 deal.")
                        elif shared_info.get('subject') != self.player and shared_info['target'] != self.player:
                            self.contestant_speaks(ally, f"{shared_info.get('subject').name} and {shared_info['target'].name} have a final 2 deal.")
                elif shared_info['type'] == 'has_final_2':
                    if shared_info.get('subject') == ally:
                        self.contestant_speaks(ally, f"I have a final 2 deal with someone.")
                    else:
                        self.contestant_speaks(ally, f"{shared_info.get('subject').name} has a final 2 deal with someone.")
                elif shared_info['type'] == 'final_2_pitch':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally:
                            self.contestant_speaks(ally, f"I was offered a final 2 deal by {shared_info['target'].name}.")
                        else:
                            self.contestant_speaks(ally, f"{shared_info.get('subject').name} pitched a final 2 deal to {shared_info['target'].name}.")
                else:
                    # Fallback for unrecognized info types or missing data
                    self.contestant_speaks(ally, f"I trust you completely. You're someone I can really count on.")
                
                # Add the shared info to player's information bank
                self.player.information_bank.append(shared_info.copy())
                
                # Check for Final 2 betrayal if player learned about a Final 2 deal
                if shared_info.get('type') == 'final_2' and shared_info.get('subject') and shared_info.get('target'):
                    self.check_for_final_2_betrayal(self.player, shared_info.get('subject'), shared_info['target'])
            else:
                # Use success dialogue as fallback when no info to share
                self.contestant_speaks(ally, f"I'm with you {self.player.name}, you can count on my vote.")
            
            if shared_actual_info:
                self.narration(f"You've formed a strong alliance with {ally.name}.")
            else:
                self.narration(f"You've formed an alliance with {ally.name}.")
            
            # Form real alliance - both get benefits
            self.player.alliance_roster.append(ally)
            ally.alliance_roster.append(self.player)
            
            # Update ally's vote target and target roster if they were targeting the player
            if ally.vote_target == self.player:
                self.assign_random_vote_target(ally)
            ally.target_roster = [c for c in ally.target_roster if c != self.player]
            
            # Add real alliance to information banks
            self.add_player_information('alliance', self.player, ally)
            self.add_information_with_day(ally, 'alliance', ally, self.player)
            
            # Improve relationship
            self.player.modify_relationship(ally, 1)
            ally.modify_relationship(self.player, 1)
            
            # Remove from pending requests if they were there
            if hasattr(self, 'pending_alliance_requests'):
                self.pending_alliance_requests = [(c, d) for c, d in self.pending_alliance_requests if c != ally]
    
    def search_for_idol(self) -> None:
        """Player searches for the hidden immunity idol, triggering simultaneous search with NPCs who decided to search."""
        # Mark that player searched today
        self.player_searched_today = True
        
        # Check which idols have been found based on tribe
        if self.merged:
            if self.idol_found_merge:
                self.narration("You spend time searching for the hidden immunity idol.")
                self.narration("Despite your best efforts, you didn't find the hidden immunity idol.")
                # Still need to track consecutive failed searches even if idol is already found
                self.player.increment_failed_idol_hunts()
                
                # Check for perception roll after 3 consecutive failures
                if self.player.consecutive_failed_idol_hunts >= 3:
                    # Roll d20 + strategic skill for insight
                    base_roll = random.randint(1, 20)
                    insight_roll = base_roll + self.player.strategic_skill
                    
                    if insight_roll >= 11:
                        # Since we're in the "idol already found" path, we know it's found
                        self.narration("You have a feeling that someone else already has the idol.")
                    else:
                        pass
                return
        else:
            # Pre-merge check
            if (self.player.tribe == self.tribe1_name and self.idol_found_tribe1) or \
               (self.player.tribe == self.tribe2_name and self.idol_found_tribe2):
                self.narration("You spend time searching for the hidden immunity idol.")
                self.narration("Despite your best efforts, you didn't find the hidden immunity idol.")
                # Still need to track consecutive failed searches even if idol is already found
                self.player.increment_failed_idol_hunts()
                
                # Check for perception roll after 3 consecutive failures
                if self.player.consecutive_failed_idol_hunts >= 3:
                    # Roll d20 + strategic skill for insight
                    base_roll = random.randint(1, 20)
                    insight_roll = base_roll + self.player.strategic_skill
                    
                    if insight_roll >= 11:
                        # Since we're in the "idol already found" path, we know it's found
                        self.narration("You have a feeling that someone else already has the idol.")
                    else:
                        pass
                return
        
        self.narration("You spend time searching for the hidden immunity idol.")
        
        # Include NPCs who decided to search at the beginning of the day
        searchers = [self.player] + self.npcs_wanting_to_search
        
        # Don't reveal to player which NPCs are searching - they wouldn't know this
        
        # Conduct the search
        self.process_idol_search(searchers, player_participates=True)
    
    def process_idol_search(self, searchers: List[Contestant], player_participates: bool) -> None:
        """Process idol search with given searchers."""
        player_found_idol = False
        others_found_idol = False
        
        # Process player first to ensure they have priority (if participating)
        if player_participates and self.player in searchers:
            base_roll = random.randint(1, 20)
            
            # Handle critical success/failure (natural 20/1 ignore modifiers)
            if base_roll == 20:
                roll = 20  # Critical success - automatic find
            elif base_roll == 1:
                roll = 1   # Critical failure - automatic fail
            else:
                # Normal roll with modifiers
                roll = base_roll + self.player.perception_skill
                # Add survival status modifiers
                if self.player.survival_status == 3:
                    roll += 1
                elif self.player.survival_status == -1:
                    roll -= 1
            
            if roll >= 20:
                # Check if there's an idol available to find in this tribe
                if self.merged:
                    # After merge, only look for merge idols
                    if not self.idol_found_merge:
                        self.idol_found_merge = True
                        player_found_idol = True
                else:
                    # Pre-merge
                    if self.player.tribe == self.tribe1_name and not self.idol_found_tribe1:
                        self.idol_found_tribe1 = True
                        player_found_idol = True
                    elif self.player.tribe == self.tribe2_name and not self.idol_found_tribe2:
                        self.idol_found_tribe2 = True
                        player_found_idol = True
                
                if player_found_idol:
                    # Create idol object with tribe beach information
                    idol_obj = {'tribe_beach': self.player.tribe, 'found_day': self.day}
                    self.player.idols.append(idol_obj)
                    self.player.idol_count += 1  # Keep count for backward compatibility
                    self.idol_finder_history[self.player.name] = f"Day {self.day}"
                    if self.player.idol_count > 1:
                        self.narration(f"After searching extensively, you spot something unusual in a tree. You've found another hidden immunity idol! You now have {self.player.idol_count} idols.")
                    else:
                        self.narration("After searching extensively, you spot something unusual in a tree. You've found the hidden immunity idol!")
                    # Add to player's info bank
                    self.add_player_information('has_idol', self.player)
                    # Track player's search result
                    self.today_idol_searches[self.player] = "Found the hidden immunity idol!"
                    # Add to Game Move Bank (Level 1)
                    self.player.add_game_move('idol_found', 1, self.day, "found a hidden immunity idol")
                else:
                    # Player searched but didn't find it
                    if player_participates:
                        self.today_idol_searches[self.player] = "Did not find the idol"
        
        # Then process other NPCs who decided to search (if player didn't find it)
        if not player_found_idol:
            for contestant in [c for c in searchers if not c.is_player]:
                base_roll = random.randint(1, 20)
                
                # Handle critical success/failure (natural 20/1 ignore modifiers)
                if base_roll == 20:
                    roll = 20  # Critical success - automatic find
                elif base_roll == 1:
                    roll = 1   # Critical failure - automatic fail
                else:
                    # Normal roll with modifiers
                    roll = base_roll + contestant.perception_skill
                    # Add survival status modifiers
                    if contestant.survival_status == 3:
                        roll += 1
                    elif contestant.survival_status == -1:
                        roll -= 1
                
                # Track idol search
                found_idol = False
                
                if roll >= 20:
                    # Check if there's an idol available to find in this tribe
                    if self.merged:
                        # After merge, only look for merge idols
                        if not self.idol_found_merge:
                            self.idol_found_merge = True
                            others_found_idol = True
                        else:
                            continue
                    else:
                        # Pre-merge
                        if contestant.tribe == self.tribe1_name and not self.idol_found_tribe1:
                            self.idol_found_tribe1 = True
                            others_found_idol = True
                        elif contestant.tribe == self.tribe2_name and not self.idol_found_tribe2:
                            self.idol_found_tribe2 = True
                            others_found_idol = True
                        else:
                            continue
                    
                    # Create idol object with tribe beach information
                    idol_obj = {'tribe_beach': contestant.tribe, 'found_day': self.day}
                    contestant.idols.append(idol_obj)
                    contestant.idol_count += 1  # Keep count for backward compatibility
                    self.idol_finder_history[contestant.name] = f"Day {self.day}"
                    # Add to NPC's info bank
                    contestant.add_information('has_idol', contestant)
                    
                    # Game Security: NPC finds a hidden immunity idol (+2) - Silent to not reveal to player
                    contestant.modify_base_game_security(2, "Found hidden immunity idol", silent=True)
                    
                    # Add to Game Move Bank (Level 1)
                    contestant.add_game_move('idol_found', 1, self.day, "found a hidden immunity idol")
                    
                    # Track successful idol find
                    found_idol = True
                    
                    break  # Only one person can find the idol
                
                # Track idol search result in separate dictionary
                if found_idol:
                    self.today_idol_searches[contestant] = "Found the hidden immunity idol!"
                else:
                    self.today_idol_searches[contestant] = "Did not find the idol"
        
        # Provide appropriate feedback based on participation
        if player_participates and not player_found_idol:
            self.narration("Despite your best efforts, you didn't find the hidden immunity idol.")
            
            # Track consecutive failed searches for player
            self.player.increment_failed_idol_hunts()
            
            # Strategic insight after 3 consecutive failures
            if self.player.consecutive_failed_idol_hunts >= 3:
                # Roll d20 + strategic skill for insight
                base_roll = random.randint(1, 20)
                insight_roll = base_roll + self.player.strategic_skill
                
                
                if insight_roll >= 11:
                    # Determine if the relevant idol has been found
                    idol_found = False
                    if self.merged:
                        # Post-merge: check merge idol
                        idol_found = self.idol_found_merge
                    else:
                        # Pre-merge: check tribe-specific idol
                        if self.player.tribe == self.tribe1_name:
                            idol_found = self.idol_found_tribe1
                        elif self.player.tribe == self.tribe2_name:
                            idol_found = self.idol_found_tribe2
                        else:
                            # Default to no idol found if tribe mismatch
                            idol_found = False
                    
                    # Provide strategic insight based on idol status
                    if idol_found:
                        self.narration("You have a feeling that someone else already has the idol.")
                    else:
                        self.narration("You know the idol is out there somewhere.")
        elif player_participates and player_found_idol:
            # Reset consecutive failures when player finds an idol
            self.player.reset_idol_hunt_streak()
        # NPC-only searches are now completely behind the scenes - no narration
    
    def work_around_camp(self) -> None:
        """Player works around camp to provide survival bonuses to tribe."""
        self.narration("You decide to work hard around camp, gathering firewood, coconuts, and helping with the shelter.")
        
        # Update work streaks
        self.player.consecutive_work_days += 1
        self.player.consecutive_no_work_days = 0
        self.player.worked_today = True
        
        # Determine survival bonus based on hero/villain status
        survival_bonus = 2 if self.player.hero_or_villain == "Hero" else 1
        
        # Apply survival bonus to all tribemates for tomorrow
        player_tribe = self.get_player_tribe()
        for contestant in player_tribe:
            if contestant != self.player:
                contestant.work_bonus_tomorrow = survival_bonus
        
        self.narration("Your tribemates appreciate your work ethic.")
    
    def focus_on_survival(self) -> None:
        """Player focuses on survival to improve their survival status."""
        # Random survival activities
        survival_activities = [
            "You decide to start cooking a pot of rice. After several minutes the rice is finished. You take a serving for yourself and quickly eat your portion. You feel better now that you have some food in your belly.",
            "You make your way to a coconut tree in the jungle and bring back several coconuts to your tribemates. The coconut water is refreshing and quenches your thirst.",
            "You notice that the shelter has been uncomfortable lately. You take some time to secure the foundation and repair the roof. You take a moment to relax in your newly comfortable shelter."
        ]
        
        # Choose and display random activity
        chosen_activity = random.choice(survival_activities)
        self.narration(chosen_activity)
        
        # Improve survival status by 1 (clamped between -1 and 3)
        old_status = self.player.survival_status
        self.player.survival_status = min(3, self.player.survival_status + 1)
        new_status = self.player.survival_status
        
        
        # Track that player focused on survival today
        self.player.focused_on_survival_today = True
    
    def snoop_action(self) -> bool:
        """Handle the snoop action where player secretly observes another contestant.
        Returns True if action was taken, False if backed out."""
        print("\n" + "="*50)
        print("🔍 SNOOP 🔍")
        print("="*50)
        
        # Get eligible contestants to snoop on
        player_tribe = self.get_player_tribe()
        eligible_targets = []
        
        for contestant in player_tribe:
            if contestant == self.player:
                continue  # Can't snoop on yourself
                
            # Check if they've actually done something worth snooping
            has_done_action = False
            
            # If they searched for an idol, they're eligible
            if contestant in self.today_idol_searches:
                has_done_action = True
            # If they performed a regular action
            elif contestant in self.today_npc_actions:
                action_type, _, _ = self.today_npc_actions[contestant]
                # Can snoop if they didn't work AND didn't interact with player
                if action_type != "work" and contestant not in self.contestants_who_interacted_with_player:
                    has_done_action = True
            
            # Only add to eligible targets if they've actually done something
            if has_done_action:
                eligible_targets.append(contestant)
        
        if not eligible_targets:
            print("\nNo one is available to snoop on.")
            return False
        
        # Display eligible targets
        print("\nWho would you like to snoop on?")
        for i, contestant in enumerate(eligible_targets, 1):
            print(f"{i}. {contestant.name}")
        print(f"{len(eligible_targets) + 1}. Back to main menu")
        
        # Get choice
        while True:
            try:
                choice = input(f"\nEnter your choice (1-{len(eligible_targets) + 1}): ").strip()
                choice_num = int(choice)
                
                if choice_num == len(eligible_targets) + 1:
                    return False  # Back to menu
                    
                if 1 <= choice_num <= len(eligible_targets):
                    target = eligible_targets[choice_num - 1]
                    break
                else:
                    print(f"Invalid choice. Please enter 1-{len(eligible_targets) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Perform the snoop
        pronoun = target.get_pronoun("subject")
        self.narration(f"You discreetly follow {target.name} to see what {pronoun}'s up to...")
        
        # Roll for snoop outcome
        base_roll = random.randint(1, 20)
        
        # Handle critical success/failure (natural 20/1 ignore modifiers)
        if base_roll == 20:
            total_roll = 20  # Critical success
        elif base_roll == 1:
            total_roll = 1   # Critical failure
        else:
            # Normal roll with modifiers
            total_roll = base_roll + self.player.perception_skill
            # Add survival status modifiers
            if self.player.survival_status == 3:
                total_roll += 1
            elif self.player.survival_status == -1:
                total_roll -= 1
            # Add villain bonus for snoop actions
            if self.player.hero_or_villain == "Villain":
                total_roll += 1
        
        outcome = self.get_roll_outcome(total_roll)
        
        # Determine what action to observe
        has_regular_action = target in self.today_npc_actions
        has_idol_search = target in self.today_idol_searches
        wants_to_search = target in self.npcs_wanting_to_search
        
        action_to_observe = None
        action_target = None
        action_outcome = None
        
        if has_regular_action and has_idol_search:
            # They did both - check if regular action was "work"
            action_type, _, _ = self.today_npc_actions[target]
            if action_type == "work":
                # If they worked and searched for idol, always observe idol search
                action_to_observe = "idol_search"
                action_target = None
                action_outcome = self.today_idol_searches[target]
            else:
                # For other actions, randomly pick which to observe
                if random.choice([True, False]):
                    # Observe their regular action
                    action_type, action_target, action_outcome = self.today_npc_actions[target]
                    action_to_observe = action_type
                else:
                    # Observe their idol search
                    action_to_observe = "idol_search"
                    action_target = None
                    action_outcome = self.today_idol_searches[target]
        elif has_regular_action:
            # Only did regular action
            action_type, action_target, action_outcome = self.today_npc_actions[target]
            action_to_observe = action_type
        elif has_idol_search:
            # Only searched for idol
            action_to_observe = "idol_search"
            action_target = None
            action_outcome = self.today_idol_searches[target]
        elif wants_to_search and not has_idol_search:
            # They want to search but haven't yet (waiting for end of day)
            action_to_observe = "planning_idol_search"
            action_target = None
            action_outcome = "Planning to search for idol later"
        elif target in self.contestants_who_interacted_with_player:
            # Special case - they interacted with player but we don't have the action recorded
            action_to_observe = "interaction_with_player"
            action_target = self.player
            action_outcome = "Had a conversation with you"
        
        # Process outcome
        if outcome in ["critical_failure", "failure"]:
            # Caught snooping!
            obj_pronoun = target.get_pronoun("object")
            self.narration(f"{target.name} notices you following {obj_pronoun}!")
            self.contestant_speaks(target, "Were you following me? That's not cool.")
            
            # Player gets busted level 2
            self.handle_busted(self.player, target, 2)
            
            poss_pronoun = target.get_pronoun("possessive")
            self.narration(f"You've been caught snooping! You're in trouble with {target.name}. Better be careful around {obj_pronoun} moving forward.")
            
        elif outcome == "neutral":
            # See action but not outcome
            self.narration("You manage to observe without being noticed...")
            
            # For ALL conversation types, show the same generic message
            if action_to_observe in ["small_talk", "pitch_alliance", "pitch_vote", "bluff", "pitch_final_2", "reveal", 
                                   "pitch_group_alliance", "pitch_vote_to_group", "probe"]:
                if action_target:
                    subj_pronoun = target.get_pronoun("subject")
                    self.narration(f"You see {target.name} talking with {action_target.name}, but you're too far away to hear what {subj_pronoun}'s saying.")
                else:
                    # Try to find a plausible conversation partner from their tribe
                    potential_targets = [c for c in self.get_active_contestants() if c.tribe == target.tribe and c != target and c != self.player]
                    if potential_targets:
                        observed_target = random.choice(potential_targets)
                        subj_pronoun = target.get_pronoun("subject")
                        self.narration(f"You see {target.name} talking with {observed_target.name}, but you're too far away to hear what {subj_pronoun}'s saying.")
                    else:
                        self.narration(f"You see {target.name} talking to someone, but you can't make out what they're discussing.")
            elif action_to_observe == "idol_search":
                subj_pronoun = target.get_pronoun("subject")
                self.narration(f"You see {target.name} wandering around camp, looking in trees and under rocks. {subj_pronoun.capitalize()}'s clearly searching for something. You head back to camp before seeing if the search was successful.")
            elif action_to_observe == "planning_idol_search":
                subj_pronoun = target.get_pronoun("subject")
                self.narration(f"You see {target.name} walking around camp, seemingly planning something. {subj_pronoun.capitalize()}'s looking around but not actively searching yet.")
            elif action_to_observe == "interaction_with_player":
                subj_pronoun = target.get_pronoun("subject")
                self.narration(f"You recall {target.name} talking with you earlier, but from this distance you can't tell what else {subj_pronoun} might be up to.")
            else:
                # This should not happen since we filter eligible targets
                if action_target:
                    subj_pronoun = target.get_pronoun("subject")
                    self.narration(f"You see {target.name} talking with {action_target.name}, but you're too far away to hear what {subj_pronoun}'s saying.")
                else:
                    subj_pronoun = target.get_pronoun("subject")
                    self.narration(f"You see {target.name} doing something, but you're too far away to make out exactly what {subj_pronoun}'s up to.")
                
        else:  # success or critical_success
            # See action AND outcome
            self.narration("You manage to get close enough to see and hear everything...")
            
            if action_to_observe == "small_talk":
                if action_target:
                    # Show what the observer would see - just a friendly conversation
                    self.narration(f"You see {target.name} talking with {action_target.name}:")
                    
                    # Show structured conversation with matching responses
                    initial_dialogue_options = [
                        {
                            "initial": "How are you holding up out here?",
                            "responses": {
                                "high_survival": [
                                    "I'm holding up great! They said this was supposed to be hard, but I could do this for a hundred more days",
                                    "Better than ever! Turns out I can thrive in the jungle!"
                                ],
                                "mid_survival": [
                                    "Better than I thought I would, but I could definitely go for a cheeseburger.",
                                    "It's been tough, but I'm hanging in there."
                                ],
                                "low_survival": [
                                    "I've been better. I had a terrible night sleep.",
                                    "I'm starving, I'm tired, I'm sore. I hope this gets easier."
                                ]
                            }
                        },
                        {
                            "initial": "I miss my family back home.",
                            "responses": [
                                "Me too, but at least I'm making friends out here",
                                "Tell me more about your family.",
                                "I do too, but they're out there cheering us on."
                            ]
                        },
                        {
                            "initial": "Has anyone started a pot of rice yet?",
                            "responses": [
                                "I think {random_tribemate} was talking about starting some.",
                                "Yeah there's some cooking now. I hope Boston Rob doesn't eat all the crispy rice",
                                "I don't think so. Are you volunteering to make some?",
                                "I'll start some soon if someone else doesn't"
                            ]
                        },
                        {
                            "initial": "What are you going to do with the million dollars if you win?",
                            "responses": [
                                "That's a secret.",
                                "I want to travel the world.",
                                "Probably something boring like invest it.",
                                "Probably something irresponsible like buy a boat.",
                                "I want to use it to take care of my family."
                            ]
                        },
                        {
                            "initial": "I've been craving donuts the whole time we've been out here.",
                            "responses": [
                                "Me too! I've been having dreams about donuts!",
                                "I've been craving {food}. That's the first thing I'm going to eat when I get back home."
                            ]
                        }
                    ]
                    
                    # Select random conversation
                    conversation = random.choice(initial_dialogue_options)
                    self.contestant_speaks(target, conversation["initial"])
                    
                    # Generate appropriate response
                    if "responses" in conversation and isinstance(conversation["responses"], dict):
                        # Survival status based responses
                        if action_target.survival_status >= 2:
                            response = random.choice(conversation["responses"]["high_survival"])
                        elif action_target.survival_status >= 0:
                            response = random.choice(conversation["responses"]["mid_survival"])
                        else:
                            response = random.choice(conversation["responses"]["low_survival"])
                    else:
                        # Generic responses or special handling
                        response_options = conversation["responses"]
                        response = random.choice(response_options)
                        
                        # Handle special substitutions
                        if "{random_tribemate}" in response:
                            same_tribe = [c for c in self.get_active_contestants() 
                                        if c.tribe == action_target.tribe and c != action_target and c != target]
                            if same_tribe:
                                tribemate = random.choice(same_tribe)
                                response = response.replace("{random_tribemate}", tribemate.name)
                            else:
                                response = "I don't think so. Are you volunteering to make some?"
                        
                        # Filter out Boston Rob response if he's not on the tribe
                        if "Boston Rob" in response:
                            boston_rob_on_tribe = any(c.name == "Boston Rob" for c in self.get_active_contestants() 
                                                    if c.tribe == action_target.tribe)
                            if not boston_rob_on_tribe:
                                # Pick a different response from the rice options
                                rice_responses = [
                                    "I think someone was talking about starting some.",
                                    "I don't think so. Are you volunteering to make some?",
                                    "I'll start some soon if someone else doesn't"
                                ]
                                response = random.choice(rice_responses)
                        
                        if "{food}" in response:
                            foods = ["mac and cheese", "spaghetti", "pizza", "tacos", "chicken wings", 
                                   "cake", "garlic bread", "lasagna", "cookies"]
                            food = random.choice(foods)
                            response = response.replace("{food}", food)
                    
                    self.contestant_speaks(action_target, response)
                else:
                    # Since player successfully rolled to see and hear everything, provide meaningful info
                    # Find someone else from the same tribe to have a conversation with
                    same_tribe_members = [c for c in self.get_active_contestants() 
                                        if c.tribe == target.tribe and c != target and not c.is_player]
                    
                    if same_tribe_members:
                        conversation_partner = random.choice(same_tribe_members)
                        self.narration(f"You see {target.name} approach {conversation_partner.name}:")
                        
                        # Show structured conversation with matching responses
                        initial_dialogue_options = [
                            {
                                "initial": "How are you holding up out here?",
                                "responses": {
                                    "high_survival": [
                                        "I'm holding up great! They said this was supposed to be hard, but I could do this for a hundred more days",
                                        "Better than ever! Turns out I can thrive in the jungle!"
                                    ],
                                    "mid_survival": [
                                        "Better than I thought I would, but I could definitely go for a cheeseburger.",
                                        "It's been tough, but I'm hanging in there."
                                    ],
                                    "low_survival": [
                                        "I've been better. I had a terrible night sleep.",
                                        "I'm starving, I'm tired, I'm sore. I hope this gets easier."
                                    ]
                                }
                            },
                            {
                                "initial": "I miss my family back home.",
                                "responses": [
                                    "Me too, but at least I'm making friends out here",
                                    "Tell me more about your family.",
                                    "I do too, but they're out there cheering us on."
                                ]
                            },
                            {
                                "initial": "Has anyone started a pot of rice yet?",
                                "responses": [
                                    "I think {random_tribemate} was talking about starting some.",
                                    "I don't think so. Are you volunteering to make some?",
                                    "I'll start some soon if someone else doesn't"
                                ]
                            },
                            {
                                "initial": "What are you going to do with the million dollars if you win?",
                                "responses": [
                                    "That's a secret.",
                                    "I want to travel the world.",
                                    "Probably something boring like invest it.",
                                    "Probably something irresponsible like buy a boat.",
                                    "I want to use it to take care of my family."
                                ]
                            },
                            {
                                "initial": "I've been craving donuts the whole time we've been out here.",
                                "responses": [
                                    "Me too! I've been having dreams about donuts!",
                                    "I've been craving {food}. That's the first thing I'm going to eat when I get back home."
                                ]
                            }
                        ]
                        
                        # Select random conversation
                        conversation = random.choice(initial_dialogue_options)
                        self.contestant_speaks(target, conversation["initial"])
                        
                        # Generate appropriate response
                        if "responses" in conversation and isinstance(conversation["responses"], dict):
                            # Survival status based responses
                            if conversation_partner.survival_status >= 2:
                                response = random.choice(conversation["responses"]["high_survival"])
                            elif conversation_partner.survival_status >= 0:
                                response = random.choice(conversation["responses"]["mid_survival"])
                            else:
                                response = random.choice(conversation["responses"]["low_survival"])
                        else:
                            # Generic responses or special handling
                            response_options = conversation["responses"]
                            response = random.choice(response_options)
                            
                            # Handle special substitutions
                            if "{random_tribemate}" in response:
                                same_tribe = [c for c in self.get_active_contestants() 
                                            if c.tribe == conversation_partner.tribe and c != conversation_partner and c != target]
                                if same_tribe:
                                    tribemate = random.choice(same_tribe)
                                    response = response.replace("{random_tribemate}", tribemate.name)
                                else:
                                    response = "I don't think so. Are you volunteering to make some?"
                            
                            # Filter out Boston Rob response if he's not on the tribe
                            if "Boston Rob" in response:
                                boston_rob_on_tribe = any(c.name == "Boston Rob" for c in self.get_active_contestants() 
                                                        if c.tribe == conversation_partner.tribe)
                                if not boston_rob_on_tribe:
                                    # Pick a different response from the rice options
                                    rice_responses = [
                                        "I think someone was talking about starting some.",
                                        "I don't think so. Are you volunteering to make some?",
                                        "I'll start some soon if someone else doesn't"
                                    ]
                                    response = random.choice(rice_responses)
                            
                            if "{food}" in response:
                                foods = ["mac and cheese", "spaghetti", "pizza", "tacos", "chicken wings", 
                                       "cake", "garlic bread", "lasagna", "cookies"]
                                food = random.choice(foods)
                                response = response.replace("{food}", food)
                        
                        self.contestant_speaks(conversation_partner, response)
                        
                        # Continue with camp life narration for conversations
                        self.narration("They continue chatting for a while about camp life.")
                    else:
                        # If no one available, show them doing a solo activity
                        solo_activities = [
                            f"You see {target.name} working on maintaining the fire.",
                            f"You see {target.name} checking and organizing the tribe's supplies.",
                            f"You see {target.name} collecting firewood near the camp.",
                            f"You see {target.name} taking some time to rest in the shelter.",
                            f"You see {target.name} working on some camp maintenance tasks."
                        ]
                        self.narration(random.choice(solo_activities))
            elif action_to_observe == "pitch_alliance":
                if action_target:
                    # Show the actual alliance pitch conversation
                    self.narration(f"You see {target.name} pull {action_target.name} aside:")
                    
                    # Show the pitch
                    pitches = [
                        f"I think we should work together. We could go far in this game.",
                        f"I trust you, and I think we'd make a strong alliance.",
                        f"What do you say we watch each other's backs?",
                        f"I've been thinking - you and I should stick together."
                    ]
                    self.contestant_speaks(target, random.choice(pitches))
                    
                    # Show the response based on outcome (but naturally)
                    if "Success! Formed alliance" in action_outcome:
                        responses = [
                            f"I'm in. Let's do this together.",
                            f"That sounds good to me. You've got yourself a deal.",
                            f"I was hoping you'd say that. Count me in.",
                            f"Absolutely. We'll watch out for each other."
                        ]
                        self.contestant_speaks(action_target, random.choice(responses))
                        self.narration("They shake hands.")
                        
                        # Add alliance info to player's information bank
                        self.player.add_information('alliance', target, action_target)
                        # Set the day for the most recent info entry
                        if self.player.information_bank:
                            self.player.information_bank[-1]['day'] = self.day
                    else:
                        responses = [
                            f"I need to think about it. Let me get back to you.",
                            f"I appreciate the offer, but I'm not ready to commit to anything yet.",
                            f"Thanks, but I'm trying to keep my options open right now.",
                            f"Maybe. We'll see how things play out."
                        ]
                        self.contestant_speaks(action_target, random.choice(responses))
                else:
                    self.narration(f"You see {target.name} having what looks like a strategic conversation, but you can't make out the details.")
                    if action_target:
                        self.narration(f"{action_target.name} walks away without committing.")
                    else:
                        self.narration("The conversation ends without resolution.")
            elif action_to_observe == "pitch_vote":
                if action_target:
                    # Show the actual vote pitch conversation
                    self.narration(f"You see {target.name} approach {action_target.name} looking concerned:")
                else:
                    self.narration(f"You see {target.name} having what looks like a strategic discussion.")
                
                # Extract the vote target from the outcome
                import re
                match = re.search(r"will vote for ([A-Za-z ]+)|Pitch Vote Target \(([A-Za-z ]+)\)", action_outcome)
                if match:
                    vote_target_name = (match.group(1) or match.group(2)).strip()
                    self.contestant_speaks(target, f"I think we should vote for {vote_target_name}.")
                    
                    # Show the response based on outcome
                    if "Success!" in action_outcome:
                        responses = [
                            f"I agree. {vote_target_name} has to go.",
                            f"You're right. Let's vote for {vote_target_name}.",
                            f"That makes sense. I'm with you on this.",
                            f"Good call. {vote_target_name} it is."
                        ]
                        self.contestant_speaks(action_target, random.choice(responses))
                        
                        # Find the actual vote target contestant object and add to info bank
                        vote_target_contestant = None
                        for contestant in self.contestants:
                            if contestant.name == vote_target_name:
                                vote_target_contestant = contestant
                                break
                        
                        if vote_target_contestant:
                            # Add info that the pitcher is planning to vote for the target
                            self.player.add_information('vote_target', target, vote_target_contestant)
                            # Set the day for the most recent info entry
                            if self.player.information_bank:
                                self.player.information_bank[-1]['day'] = self.day
                            
                            # Also add info that the person who agreed is planning to vote for the target
                            self.player.add_information('vote_target', action_target, vote_target_contestant)
                            # Set the day for the most recent info entry
                            if self.player.information_bank:
                                self.player.information_bank[-1]['day'] = self.day
                    else:
                        responses = [
                            f"I'm not sure about that. I need to think about it.",
                            f"I don't know... I was thinking someone else.",
                            f"Maybe. Let me see how I feel closer to tribal.",
                            f"I'll consider it, but I'm not making any promises."
                        ]
                        self.contestant_speaks(action_target, random.choice(responses))
                else:
                    # Fallback - try to get vote target from the NPC's current vote target
                    if hasattr(target, 'vote_target') and target.vote_target:
                        vote_target_name = target.vote_target.name
                        self.contestant_speaks(target, f"I think we should vote for {vote_target_name}.")
                        
                        # Show a generic response since we don't know the exact outcome
                        if "Success!" in action_outcome:
                            self.contestant_speaks(action_target, f"You're right. Let's vote for {vote_target_name}.")
                        else:
                            self.contestant_speaks(action_target, "I need to think about that.")
                    else:
                        # Ultimate fallback if we have no information
                        self.contestant_speaks(target, f"We need to talk about the vote.")
                        if action_target:
                            self.contestant_speaks(action_target, f"What are you thinking?")
                        self.narration("You couldn't quite make out who they were discussing.")
            elif action_to_observe == "bluff":
                if action_target:
                    # Show initial narration
                    self.narration(f"You see {target.name} having a conversation with {action_target.name}.")
                    
                    # Import re module for pattern matching
                    import re
                    
                    # Determine the bluff content
                    bluff_content = None
                    
                    if "Lied about vote target" in action_outcome:
                        # Extract the claimed target
                        match = re.search(r"claimed: (\w+)", action_outcome)
                        if match:
                            claimed_target = match.group(1)
                            # Convert name to "you" if the target is the listener
                            if action_target and action_target.name == claimed_target:
                                bluff_content = "I'm planning to vote for you at the next tribal council."
                            else:
                                bluff_content = f"I'm planning to vote for {claimed_target} at the next tribal council."
                            
                            # Find the claimed vote target and add to info bank
                            claimed_target_contestant = None
                            for contestant in self.contestants:
                                if contestant.name == claimed_target:
                                    claimed_target_contestant = contestant
                                    break
                            
                            if claimed_target_contestant:
                                self.player.add_information('vote_target', target, claimed_target_contestant)
                                if self.player.information_bank:
                                    self.player.information_bank[-1]['day'] = self.day
                    
                    elif "Lied about having an idol" in action_outcome:
                        bluff_content = "I found a hidden immunity idol."
                        # Add idol information to info bank (player doesn't know it's a lie)
                        self.player.add_information('has_idol', target)
                        if self.player.information_bank:
                            self.player.information_bank[-1]['day'] = self.day
                    
                    elif "Lied about alliance" in action_outcome:
                        # Extract alliance info if available
                        match = re.search(r"with (.+?)$", action_outcome)
                        if match:
                            allies = match.group(1)
                            bluff_content = f"I have an alliance with {allies}."
                            
                            # Find the ally contestant and add alliance info to info bank
                            ally_contestant = None
                            for contestant in self.contestants:
                                if contestant.name == allies:
                                    ally_contestant = contestant
                                    break
                            
                            if ally_contestant:
                                self.player.add_information('alliance', target, ally_contestant)
                                if self.player.information_bank:
                                    self.player.information_bank[-1]['day'] = self.day
                    
                    elif "Lied about previous vote" in action_outcome:
                        # Extract the claimed vote
                        match = re.search(r"claimed: (\w+)", action_outcome)
                        if match:
                            claimed_vote = match.group(1)
                            # Convert name to "you" if appropriate
                            if action_target and action_target.name == claimed_vote:
                                bluff_content = "I voted for you at the last tribal council."
                            else:
                                bluff_content = f"I voted for {claimed_vote} at the last tribal council."
                            
                            # Find the claimed vote target and add to info bank
                            claimed_vote_contestant = None
                            for contestant in self.contestants:
                                if contestant.name == claimed_vote:
                                    claimed_vote_contestant = contestant
                                    break
                            
                            if claimed_vote_contestant:
                                self.player.add_information('previous_vote', target, claimed_vote_contestant)
                                if self.player.information_bank:
                                    self.player.information_bank[-1]['day'] = self.day
                    
                    elif "final 2" in action_outcome.lower():
                        # Final 2 bluff
                        match = re.search(r"with (.+?)(?:\s|$)", action_outcome)
                        if match:
                            partner = match.group(1)
                            bluff_content = f"I have a final 2 deal with {partner}."
                    
                    elif "is targeting" in action_outcome or "targeting you" in action_outcome:
                        # "Someone is targeting you" bluff
                        match = re.search(r"claimed (.+?) is targeting", action_outcome)
                        if match:
                            claimed_targeter = match.group(1)
                            bluff_content = f"{claimed_targeter} is planning to vote for you at the next tribal council."
                        else:
                            # Fallback if pattern doesn't match
                            bluff_content = "Someone is planning to vote for you at the next tribal council."
                    
                    elif "consensus" in action_outcome.lower() and "claimed" in action_outcome:
                        # Consensus vote bluff
                        match = re.search(r"claimed (.+?)(?:\s|$)", action_outcome)
                        if match:
                            claimed_consensus = match.group(1)
                            # Convert name to "you" if the target is the listener
                            if action_target and action_target.name == claimed_consensus:
                                bluff_content = "You are getting voted out next tribal council."
                            else:
                                bluff_content = f"{claimed_consensus} is getting voted out next tribal council."
                        else:
                            # Fallback if pattern doesn't match
                            bluff_content = "Someone is getting voted out next tribal council."
                    
                    else:
                        # Generic bluff fallback
                        bluff_content = "I've heard some interesting things about the vote."
                    
                    # Show the bluff dialogue
                    if bluff_content:
                        self.contestant_speaks(target, f"I need to tell you something important. {bluff_content}")
                        
                        # Determine response based on outcome
                        if "succeeded" in action_outcome.lower() or "believed" in action_outcome.lower():
                            # Bluff succeeded or appears to succeed
                            self.contestant_speaks(action_target, "Wow, thanks for telling me that.")
                        else:
                            # Bluff failed
                            self.contestant_speaks(action_target, "Are you sure? I find that hard to believe.")
                else:
                    self.narration(f"You see {target.name} having a conversation, but couldn't make out who they were talking to.")
            elif action_to_observe == "idol_search":
                # Show what an observer would see during an idol search
                self.narration(f"You watch {target.name} wandering away from camp.")
                
                # Describe the search
                self.narration(f"{target.name} starts looking around carefully, checking inside tree hollows and under rocks.")
                
                if "Found the hidden immunity idol!" in action_outcome:
                    # They found it - show what observer would see
                    self.narration(f"{target.name} reaches into a tree hollow and pulls something out. They quickly glance around to make sure no one is watching, then stuff something into their bag and head back to camp with a slight smile.")
                    
                    # Add idol information to info bank
                    self.player.add_information('has_idol', target)
                    # Set the day for the most recent info entry
                    if self.player.information_bank:
                        self.player.information_bank[-1]['day'] = self.day
                else:
                    # They didn't find it
                    self.narration(f"After searching for a while, {target.name} gives up and heads back to camp empty-handed.")
            elif action_to_observe == "planning_idol_search":
                # They're planning to search but haven't yet
                self.narration(f"You watch {target.name} carefully surveying the area around camp.")
                self.narration(f"{target.name} seems to be planning where to search for something later, making mental notes of potential hiding spots.")
            elif action_to_observe == "interaction_with_player":
                self.narration(f"You already know {target.name} talked with you earlier today.")
            elif action_to_observe == "pitch_final_2":
                if action_target:
                    # Show initial narration
                    self.narration(f"You see {target.name} having a conversation with {action_target.name}.")
                    
                    # Show the final 2 pitch
                    self.contestant_speaks(target, "I think we should agree to go to the final two together. What do you think?")
                    
                    # Show response based on outcome
                    if action_outcome and action_outcome != "Failed":
                        # Final 2 was accepted
                        self.contestant_speaks(action_target, "I'm in! Me and you at the final two!")
                    else:
                        # Final 2 was rejected
                        self.contestant_speaks(action_target, "I don't know about that. Can we talk about this another time?")
            elif action_to_observe == "reveal":
                if action_target:
                    self.narration(f"You see {target.name} sharing something important with {action_target.name}.")
                    
                    # Show the actual reveal conversation
                    if action_outcome and isinstance(action_outcome, str):
                        # Extract the info_text from the outcome format
                        info_text = None
                        if " - Shared: " in action_outcome:
                            # Format: "Neutral - Shared: {info_text}" or "Success - Shared: {info_text}, gained pitch bonus"
                            shared_part = action_outcome.split(" - Shared: ")[1]
                            # Remove any trailing modifiers like ", gained pitch bonus"
                            if ", gained pitch bonus" in shared_part:
                                info_text = shared_part.split(", gained pitch bonus")[0]
                            elif ", removed from targeting" in shared_part:
                                info_text = shared_part.split(", removed from targeting")[0]
                            else:
                                info_text = shared_part
                        
                        # Parse the info_text to show the actual information shared
                        if info_text:
                            # Convert names to "you" when speaking to the target
                            converted_info = info_text
                            if action_target and action_target.name in converted_info:
                                converted_info = converted_info.replace(action_target.name, "you")
                            
                            if "is planning on voting for" in info_text:
                                # Extract vote target information
                                self.contestant_speaks(target, f"I need to tell you something important. {converted_info}")
                            elif "has an idol" in info_text:
                                # Idol information
                                self.contestant_speaks(target, f"I need to tell you something important. {converted_info}")
                            elif "is in an alliance with" in info_text or "are in an alliance with" in info_text:
                                # Alliance information
                                self.contestant_speaks(target, f"I need to tell you something important. {converted_info}")
                            elif "pitched" in info_text and "as a vote target" in info_text:
                                # Vote pitch information
                                self.contestant_speaks(target, f"I need to tell you something important. {converted_info}")
                            elif "voted for" in info_text and "at the last tribal council" in info_text:
                                # Previous vote information
                                self.contestant_speaks(target, f"I need to tell you something important. {converted_info}")
                            elif "final 2" in info_text:
                                # Final 2 deal information
                                self.contestant_speaks(target, f"I need to tell you something important. {converted_info}")
                            elif "consensus vote" in info_text:
                                # Consensus vote information
                                self.contestant_speaks(target, f"I need to tell you something important. {converted_info}")
                            else:
                                # Generic reveal for any other info
                                self.contestant_speaks(target, f"I need to tell you something important. {converted_info}")
                        else:
                            # Fallback if we can't extract info_text
                            self.contestant_speaks(target, f"I need to be honest with you about something important...")
                            
                        # Show the reaction based on outcome
                        if action_outcome:
                            if "Failure -" in action_outcome and "Critical" not in action_outcome:
                                # Failure outcome - show disbelief
                                self.contestant_speaks(action_target, "Are you sure? I find that hard to believe.")
                            else:
                                # All other outcomes (Critical Failure, Neutral, Success, Critical Success) - show acceptance
                                self.contestant_speaks(action_target, "Wow, thanks for telling me that.")
                        else:
                            # Fallback if no outcome info
                            self.contestant_speaks(action_target, "Wow, thanks for telling me that.")
                        
                        # Add the revealed information to player's knowledge - parse from the actual info_text
                        if info_text:
                            if "is planning on voting for" in info_text:
                                # Parse: "Monica is planning on voting for Colton at the next tribal council"
                                parts = info_text.split(" is planning on voting for ")
                                if len(parts) == 2:
                                    subject_name = parts[0].strip()
                                    target_part = parts[1].split(" at the next tribal council")[0].strip()
                                    # Find contestant objects
                                    subject_obj = None
                                    target_obj = None
                                    for contestant in self.contestants:
                                        if contestant.name == subject_name:
                                            subject_obj = contestant
                                        if contestant.name == target_part:
                                            target_obj = contestant
                                    if subject_obj and target_obj:
                                        self.player.add_information('vote_target', subject_obj, target_obj)
                                        if self.player.information_bank:
                                            self.player.information_bank[-1]['day'] = self.day
                            elif "has an idol" in info_text:
                                # Parse: "Monica has an idol" or "You have an idol"
                                if info_text.startswith("You have"):
                                    subject_obj = target  # The person who said "You have an idol"
                                else:
                                    subject_name = info_text.split(" has an idol")[0].strip()
                                    subject_obj = None
                                    for contestant in self.contestants:
                                        if contestant.name == subject_name:
                                            subject_obj = contestant
                                            break
                                if subject_obj:
                                    self.player.add_information('has_idol', subject_obj)
                                    if self.player.information_bank:
                                        self.player.information_bank[-1]['day'] = self.day
                            elif "is in an alliance with" in info_text:
                                # Parse: "Monica is in an alliance with Colton"
                                parts = info_text.split(" is in an alliance with ")
                                if len(parts) == 2:
                                    subject_name = parts[0].strip()
                                    alliance_partner_name = parts[1].strip()
                                    # Find contestant objects
                                    subject_obj = None
                                    partner_obj = None
                                    for contestant in self.contestants:
                                        if contestant.name == subject_name:
                                            subject_obj = contestant
                                        if contestant.name == alliance_partner_name:
                                            partner_obj = contestant
                                    if subject_obj and partner_obj:
                                        self.player.add_information('alliance', subject_obj, partner_obj)
                                        if self.player.information_bank:
                                            self.player.information_bank[-1]['day'] = self.day
                            elif "are in an alliance with" in info_text:
                                # Parse: "You are in an alliance with Monica"
                                alliance_partner_name = info_text.split("You are in an alliance with ")[1].strip()
                                partner_obj = None
                                for contestant in self.contestants:
                                    if contestant.name == alliance_partner_name:
                                        partner_obj = contestant
                                        break
                                if partner_obj:
                                    self.player.add_information('alliance', target, partner_obj)
                                    if self.player.information_bank:
                                        self.player.information_bank[-1]['day'] = self.day
                    else:
                        # Fallback if no action_outcome
                        self.contestant_speaks(target, f"I need to tell you something important...")
                        self.narration(f"{action_target.name} seems surprised by whatever they just learned.")
                else:
                    self.narration(f"You see {target.name} sharing something important with someone, but you couldn't make out who.")
            elif action_to_observe == "pitch_group_alliance":
                if action_outcome and isinstance(action_outcome, str):
                    # Extract participant names from the action outcome
                    # Format examples: "Successfully formed group alliance with Tina, Rupert, Boston Rob (roll: 18)"
                    #                  "Failed to form group alliance with Tina, Rupert, Boston Rob (roll: 10)"
                    #                  "Formed fake group alliance with Tina, Rupert, Boston Rob (roll: 3)"
                    
                    participant_names = []
                    if " with " in action_outcome:
                        names_part = action_outcome.split(" with ")[1]
                        if " (roll:" in names_part:
                            names_part = names_part.split(" (roll:")[0]
                        participant_names = [name.strip() for name in names_part.split(",")]
                    
                    if participant_names:
                        # Show initial narration
                        if len(participant_names) == 1:
                            self.narration(f"You see {target.name} pull {participant_names[0]} aside.")
                        elif len(participant_names) == 2:
                            self.narration(f"You see {target.name} pull {participant_names[0]} and {participant_names[1]} aside.")
                        else:
                            # 3 or more participants
                            names_list = ", ".join(participant_names[:-1]) + f", and {participant_names[-1]}"
                            self.narration(f"You see {target.name} pull {names_list} aside.")
                        
                        # Show the alliance pitch
                        self.contestant_speaks(target, "I think we should form an alliance. What do you think?")
                        
                        # Determine response based on roll outcome and choose random responder
                        random_responder = random.choice(participant_names)
                        
                        # Parse roll outcome to determine response
                        if "Successfully formed" in action_outcome or "(roll:" in action_outcome:
                            # Extract roll number to determine response type
                            import re
                            roll_match = re.search(r"\(roll: (\d+)\)", action_outcome)
                            if roll_match:
                                roll_value = int(roll_match.group(1))
                                if 1 <= roll_value <= 4:
                                    # Fake alliance (1-4) - appears successful
                                    response = "That's a great idea! I'm in!"
                                elif 5 <= roll_value <= 15:
                                    # Failure (5-15) - shows rejection
                                    response = "I'm not sure about that. I want to keep my options open."
                                else:  # 16+
                                    # Success (16+) - shows acceptance
                                    response = "That's a great idea! I'm in!"
                            else:
                                # Fallback based on action outcome text
                                if "Failed" in action_outcome:
                                    response = "I'm not sure about that. I want to keep my options open."
                                else:
                                    response = "That's a great idea! I'm in!"
                        else:
                            # Fallback
                            response = "That's a great idea! I'm in!"
                        
                        # Find the responder contestant object and show response
                        responder_obj = None
                        for contestant in self.contestants:
                            if contestant.name == random_responder:
                                responder_obj = contestant
                                break
                        
                        if responder_obj:
                            self.contestant_speaks(responder_obj, response)
                    else:
                        # Fallback if we can't parse participant names
                        self.narration(f"You see {target.name} gathering a group for what looks like a serious conversation.")
                else:
                    # Fallback if no action outcome
                    self.narration(f"You see {target.name} talking with a group, but you couldn't make out what was discussed.")
            elif action_to_observe == "pitch_vote_to_group":
                if action_outcome and isinstance(action_outcome, str):
                    # Extract participant names and vote target from the action outcome
                    # Format examples: "Successfully convinced Cochran, Dawn, Malcolm to vote for Boston Rob (roll: 18)"
                    #                  "Group politely declined voting for Boston Rob (roll: 10)"
                    #                  "Group bluffed agreement to vote for Boston Rob (roll: 4)"
                    
                    participant_names = []
                    vote_target_name = None
                    
                    # Extract vote target
                    if " to vote for " in action_outcome:
                        vote_part = action_outcome.split(" to vote for ")[1]
                        if " (roll:" in vote_part:
                            vote_target_name = vote_part.split(" (roll:")[0].strip()
                    elif "voting for " in action_outcome:
                        vote_part = action_outcome.split("voting for ")[1]
                        if " (roll:" in vote_part:
                            vote_target_name = vote_part.split(" (roll:")[0].strip()
                    
                    # Extract participant names
                    if "convinced " in action_outcome and " to vote for " in action_outcome:
                        names_part = action_outcome.split("convinced ")[1].split(" to vote for ")[0]
                        participant_names = [name.strip() for name in names_part.split(",")]
                    elif "Group " in action_outcome:
                        # For "Group politely declined" format, we need to get participants from somewhere else
                        # Try to find group members by looking at tribe members excluding the pitcher
                        active_tribe_members = [c for c in self.get_active_contestants() 
                                               if c.tribe == target.tribe and c != target and not c.is_player]
                        participant_names = [c.name for c in active_tribe_members[:3]]  # Approximate group size
                    
                    if participant_names and vote_target_name:
                        # Show initial narration
                        if len(participant_names) == 1:
                            self.narration(f"You see {target.name} having a conversation with {participant_names[0]}.")
                        elif len(participant_names) == 2:
                            self.narration(f"You see {target.name} having a conversation with {participant_names[0]} and {participant_names[1]}.")
                        else:
                            # 3 or more participants
                            names_list = ", ".join(participant_names[:-1]) + f", and {participant_names[-1]}"
                            self.narration(f"You see {target.name} having a conversation with {names_list}.")
                        
                        # Show the vote pitch
                        self.contestant_speaks(target, f"I think we should vote for {vote_target_name} at the next tribal council. What do you think?")
                        
                        # Choose random responder
                        random_responder = random.choice(participant_names)
                        
                        # Determine response based on outcome
                        if "Successfully convinced" in action_outcome or "bluffed agreement" in action_outcome:
                            # Accepted or pretended to accept
                            response = f"Good idea. {vote_target_name} needs to go."
                        else:
                            # Rejected ("politely declined")
                            response = f"I don't know about that. I don't think now is the time to get rid of {vote_target_name}."
                        
                        # Find the responder contestant object and show response
                        responder_obj = None
                        for contestant in self.contestants:
                            if contestant.name == random_responder:
                                responder_obj = contestant
                                break
                        
                        if responder_obj:
                            self.contestant_speaks(responder_obj, response)
                    else:
                        # Fallback if we can't parse the action outcome
                        self.narration(f"You see {target.name} having a strategic conversation with a group, but you couldn't make out the specifics.")
                else:
                    # Fallback if no action outcome
                    self.narration(f"You see {target.name} talking with a group about strategy, but you couldn't hear the details.")
            elif action_to_observe == "probe_for_general_info":
                if action_target:
                    # Show initial narration
                    self.narration(f"You see {target.name} having a conversation with {action_target.name}.")
                    
                    # Show the probe question
                    self.contestant_speaks(target, "Have you noticed anything interesting going on around camp?")
                    
                    # Determine response based on action outcome
                    if action_outcome and isinstance(action_outcome, str):
                        if "honestly shared information" in action_outcome:
                            # Successful probe - target shared real information
                            # Need to extract what information was actually shared
                            # Look for the pattern in the outcome to get the actual info
                            if action_target and hasattr(action_target, 'information_bank') and action_target.information_bank:
                                # Get a random piece of information from target's bank to share
                                shared_info = random.choice(action_target.information_bank)
                                info_text = action_target.get_information_text_for_speaking(shared_info, listener=target)
                                self.contestant_speaks(action_target, f"Here's what I can tell you... {info_text}")
                            else:
                                self.contestant_speaks(action_target, "Here's what I can tell you... Actually, I don't have much information right now.")
                        
                        elif "lied about vote target: claimed" in action_outcome:
                            # Extract the fake vote target from the outcome
                            import re
                            match = re.search(r"claimed (\w+)", action_outcome)
                            if match:
                                fake_target_name = match.group(1)
                                self.contestant_speaks(action_target, f"Here's what I can tell you... I'm planning to vote for {fake_target_name}.")
                            else:
                                self.contestant_speaks(action_target, "Here's what I can tell you... I have some ideas about the vote.")
                        
                        elif "lied about consensus: claimed" in action_outcome:
                            # Extract the fake consensus target
                            import re
                            match = re.search(r"claimed (\w+)", action_outcome)
                            if match:
                                fake_consensus_name = match.group(1)
                                self.contestant_speaks(action_target, f"Here's what I can tell you... Word is going around that {fake_consensus_name} is getting voted out next.")
                            else:
                                self.contestant_speaks(action_target, "Here's what I can tell you... There's talk about who's going next.")
                        
                        elif "shared fake information about" in action_outcome:
                            # General bluff - extract the type and create appropriate fake info
                            if "alliance" in action_outcome:
                                # Pick a random contestant for fake alliance
                                active_contestants = [c for c in self.get_active_contestants() if c != action_target and c != target]
                                if active_contestants:
                                    fake_ally = random.choice(active_contestants)
                                    self.contestant_speaks(action_target, f"Here's what I can tell you... I have an alliance with {fake_ally.name}.")
                                else:
                                    self.contestant_speaks(action_target, "Here's what I can tell you... I've been working on some alliances.")
                            elif "idol" in action_outcome:
                                self.contestant_speaks(action_target, "Here's what I can tell you... I found a hidden immunity idol.")
                            else:
                                self.contestant_speaks(action_target, "Here's what I can tell you... I've heard some interesting things.")
                        
                        elif "gave vague response" in action_outcome or "tried to lie but was caught" in action_outcome:
                            # Target avoided giving info or failed bluff
                            self.contestant_speaks(action_target, "Not really. I'm trying to stay out of the drama.")
                        
                        else:
                            # Fallback for other outcomes
                            self.contestant_speaks(action_target, "Not really. I'm trying to stay out of the drama.")
                    else:
                        # Fallback if no action outcome
                        self.contestant_speaks(action_target, "Not really. I'm trying to stay out of the drama.")
                else:
                    # Fallback if no target
                    self.narration(f"You see {target.name} trying to gather information, but you couldn't make out who they were talking to.")
            elif action_to_observe == "probe" and action_outcome and "vote target" in action_outcome.lower():
                # Specific handling for vote target probes
                if action_target:
                    # Show initial narration
                    self.narration(f"You see {target.name} having a conversation with {action_target.name}.")
                    
                    # Show the probe question
                    self.contestant_speaks(target, "Can I ask you something? Who are you planning to vote for at the next tribal council?")
                    
                    # Determine response based on action outcome
                    if "honestly shared information" in action_outcome:
                        # Target shared their real vote target
                        if action_target.vote_target:
                            self.contestant_speaks(action_target, f"Between you and me... I'm planning to vote for {action_target.vote_target.name}.")
                        else:
                            self.contestant_speaks(action_target, "I haven't decided yet. This game is tough.")
                    
                    elif "lied about vote target: claimed" in action_outcome:
                        # Extract the fake vote target from the outcome
                        import re
                        match = re.search(r"claimed (\w+)", action_outcome)
                        if match:
                            fake_target_name = match.group(1)
                            self.contestant_speaks(action_target, f"Between you and me... I'm planning to vote for {fake_target_name}.")
                        else:
                            self.contestant_speaks(action_target, "I haven't decided yet. This game is tough.")
                    
                    elif "gave vague response" in action_outcome or "tried to lie but was caught" in action_outcome:
                        # Target avoided giving info
                        self.contestant_speaks(action_target, "I haven't decided yet. This game is tough.")
                    
                    else:
                        # Fallback
                        self.contestant_speaks(action_target, "I haven't decided yet. This game is tough.")
                else:
                    # Fallback if no target
                    self.narration(f"You see {target.name} asking someone about voting plans, but you couldn't make out who.")
            elif action_to_observe == "probe" and action_outcome and "consensus" in action_outcome.lower():
                # Specific handling for consensus vote probes
                if action_target:
                    # Show initial narration
                    self.narration(f"You see {target.name} having a conversation with {action_target.name}.")
                    
                    # Show the probe question
                    self.contestant_speaks(target, "Can I ask you something? Do you know who's getting voted out next?")
                    
                    # Determine response based on action outcome
                    if "honestly shared information" in action_outcome:
                        # Target shared real consensus info if they have it
                        consensus_info = None
                        if action_target and hasattr(action_target, 'information_bank'):
                            for info in action_target.information_bank:
                                if info.get('type') == 'consensus_vote' and 'targets' in info and info['targets']:
                                    consensus_info = info['targets'][0]  # Get the first consensus target
                                    break
                        
                        if consensus_info:
                            self.contestant_speaks(action_target, f"Between you and me... I'm hearing that {consensus_info.name} is getting voted out next.")
                        else:
                            self.contestant_speaks(action_target, "Honestly, I don't know... I feel out of the loop.")
                    
                    elif "lied about consensus: claimed" in action_outcome:
                        # Extract the fake consensus target from the outcome
                        import re
                        match = re.search(r"claimed (\w+)", action_outcome)
                        if match:
                            fake_consensus_name = match.group(1)
                            self.contestant_speaks(action_target, f"Between you and me... I'm hearing that {fake_consensus_name} is getting voted out next.")
                        else:
                            self.contestant_speaks(action_target, "Honestly, I don't know... I feel out of the loop.")
                    
                    elif "gave vague response" in action_outcome or "tried to lie but was caught" in action_outcome:
                        # Target avoided giving info
                        self.contestant_speaks(action_target, "Honestly, I don't know... I feel out of the loop.")
                    
                    else:
                        # Fallback
                        self.contestant_speaks(action_target, "Honestly, I don't know... I feel out of the loop.")
                else:
                    # Fallback if no target
                    self.narration(f"You see {target.name} asking someone about the consensus vote, but you couldn't make out who.")
            else:
                # Fallback for unhandled action types - try to show dialogue if possible
                if action_target:
                    self.narration(f"You see {target.name} talking with {action_target.name}:")
                    
                    # Show generic strategic conversation based on action outcome
                    if action_outcome:
                        if "bluff" in action_outcome.lower():
                            # Extract claimed target from bluff outcome
                            import re
                            if "claimed" in action_outcome:
                                match = re.search(r"claimed (\w+)", action_outcome)
                                if match:
                                    claimed_target = match.group(1)
                                    self.contestant_speaks(target, f"I'm planning to vote for {claimed_target}.")
                                    if "succeeded" in action_outcome.lower():
                                        self.contestant_speaks(action_target, f"Good to know. Thanks for telling me.")
                                    else:
                                        self.contestant_speaks(action_target, f"Really? I heard something different...")
                                else:
                                    self.contestant_speaks(target, f"I wanted to let you know where I stand on things.")
                                    self.contestant_speaks(action_target, f"I appreciate you sharing that with me.")
                            else:
                                self.contestant_speaks(target, f"I wanted to let you know where I stand on things.")
                                self.contestant_speaks(action_target, f"I appreciate you sharing that with me.")
                        else:
                            # Generic strategic conversation
                            self.contestant_speaks(target, f"We need to talk about our strategy going forward.")
                            self.contestant_speaks(action_target, f"What are you thinking?")
                    else:
                        # No outcome info - show basic interaction
                        self.contestant_speaks(target, f"Can we chat for a minute?")
                        self.contestant_speaks(action_target, f"Sure, what's on your mind?")
                else:
                    self.narration(f"You observe {target.name} doing something, but you can't make out the specific details of their activity.")
        
        return True  # Action was taken
    
    def handle_push_harder_option(self, ally_choice: Contestant, target_choice: Contestant) -> bool:
        """Handle the push harder option after a failed vote pitch.
        Returns True if player pushed harder (used an action), False if they accepted results."""
        
        # Check remaining actions
        remaining_actions = self.max_actions_per_day - self.actions_taken_today
        
        # Don't allow Push Harder if this pitch was initiated on the 3rd action
        # Note: actions_taken_today hasn't been incremented yet for the current action
        if self.actions_taken_today >= 2 or remaining_actions <= 1:
            # No actions left, can't push harder
            print("\nYour vote pitch wasn't successful.")
            return False
        
        print("\nYour vote pitch wasn't successful. What would you like to do?")
        print("1. Accept the results")
        print("2. Push harder")
        
        while True:
            try:
                choice = int(input("Enter your choice (1-2): "))
                if choice == 1:
                    # Accept results, don't use another action
                    return False
                elif choice == 2:
                    # Ask for confirmation about using an action
                    if remaining_actions == 1:
                        print("\nPushing harder will use your remaining action for the day. Are you sure you want to continue?")
                    else:
                        print(f"\nPushing harder will use one of your remaining actions for the day. Are you sure you want to continue? ({remaining_actions - 1} moves remaining)")
                    
                    print("1. Yes, push harder")
                    print("2. No, accept the results")
                    
                    while True:
                        try:
                            confirm = int(input("Enter your choice (1-2): "))
                            if confirm == 1:
                                # Push harder - re-roll the vote pitch
                                self.actions_taken_today += 1
                                self.narration("You decide to push the conversation further...")
                                
                                # Call the vote pitch function again with the same parameters
                                self.push_harder_vote_pitch(ally_choice, target_choice)
                                
                                # Trigger NPC actions after push harder
                                self.trigger_npc_actions_after_push_harder()
                                
                                return True  # Used an action
                            elif confirm == 2:
                                # Changed mind, accept results
                                return False
                            else:
                                print("Invalid choice. Please enter 1 or 2.")
                        except ValueError:
                            print("Invalid input. Please enter a number.")
                else:
                    print("Invalid choice. Please enter 1 or 2.")
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    def handle_push_harder_group_option(self, group: List[Contestant], target_choice: Contestant) -> bool:
        """Handle the push harder option after a failed group vote pitch.
        Returns True if player pushed harder (used an action), False if they accepted results."""
        
        # Check remaining actions
        remaining_actions = self.max_actions_per_day - self.actions_taken_today
        
        # Don't allow Push Harder if this pitch was initiated on the 3rd action
        # Note: actions_taken_today hasn't been incremented yet for the current action
        if self.actions_taken_today >= 2 or remaining_actions <= 1:
            # No actions left, can't push harder
            print("\nYour vote pitch wasn't successful.")
            return False
        
        print("\nYour vote pitch wasn't successful. What would you like to do?")
        print("1. Accept the results")
        print("2. Push harder")
        
        while True:
            try:
                choice = int(input("Enter your choice (1-2): "))
                if choice == 1:
                    # Accept results, don't use another action
                    return False
                elif choice == 2:
                    # Ask for confirmation about using an action
                    if remaining_actions == 1:
                        print("\nPushing harder will use your remaining action for the day. Are you sure you want to continue?")
                    else:
                        print(f"\nPushing harder will use one of your remaining actions for the day. Are you sure you want to continue? ({remaining_actions - 1} moves remaining)")
                    
                    print("1. Yes, push harder")
                    print("2. No, accept the results")
                    
                    while True:
                        try:
                            confirm = int(input("Enter your choice (1-2): "))
                            if confirm == 1:
                                # Push harder - re-roll the group vote pitch
                                self.actions_taken_today += 1
                                self.narration("You decide to push the conversation further...")
                                
                                # Call the group vote pitch function again with the same parameters
                                self.push_harder_group_vote_pitch(group, target_choice)
                                
                                # Trigger NPC actions after push harder
                                self.trigger_npc_actions_after_push_harder()
                                
                                return True  # Used an action
                            elif confirm == 2:
                                # Changed mind, accept results
                                return False
                            else:
                                print("Invalid choice. Please enter 1 or 2.")
                        except ValueError:
                            print("Invalid input. Please enter a number.")
                else:
                    print("Invalid choice. Please enter 1 or 2.")
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    def push_harder_group_vote_pitch(self, group: List[Contestant], target_choice: Contestant) -> None:
        """Re-roll a group vote pitch when pushing harder."""
        
        # Determine if this is an alliance or hand-picked group
        # Check if this group matches any of the player's group alliances
        is_alliance = False
        for alliance_id in self.player.group_alliances:
            if alliance_id in self.group_alliances:
                alliance_data = self.group_alliances[alliance_id]
                alliance_members = [m for m in alliance_data['members'] if m != self.player and not m.eliminated]
                if set(group) == set(alliance_members):
                    is_alliance = True
                    break
        
        # Narrate the push harder attempt
        group_names = ', '.join([p.name for p in group])
        self.narration(f"You continue pushing your case to {group_names}...")
        
        # Roll d20 + persuasive skill + reveal bonuses
        roll = random.randint(1, 20)
        
        # Calculate reveal bonuses for each person in the group
        reveal_bonus = 0
        if hasattr(self, 'reveal_bonuses'):
            for person in group:
                if (self.player, person) in self.reveal_bonuses:
                    if self.reveal_bonuses[(self.player, person)] >= self.day:
                        reveal_bonus += 1
        
        total_roll = roll + self.player.persuasive_skill + reveal_bonus
        
        if is_alliance:
            # Alliance logic: 14+ = success, 1-13 = decline
            if total_roll >= 14:  # Success
                response_giver = random.choice(group)
                responses = [
                    f"Okay, you've convinced me. {target_choice.name} needs to go.",
                    f"Alright, let's vote for {target_choice.name}.",
                    f"You make a good point about {target_choice.name}.",
                    f"Fine, I'm in. {target_choice.name} it is."
                ]
                self.contestant_speaks(response_giver, random.choice(responses))
                
                # Set vote targets for alliance members
                for member in group:
                    member.vote_target = target_choice
                    member.vote_pitch_agreements[self.player] = target_choice
                
                # Add to information banks
                for member in group:
                    self.add_information_with_day(member, 'vote_pitch', self.player, target_choice)
                    self.add_information_with_day(self.player, 'vote_target', member, target_choice)
                self.add_information_with_day(self.player, 'vote_pitch', self.player, target_choice)
                self.add_information_with_day(self.player, 'vote_target', self.player, target_choice)
                
                self.narration(f"Your persistence pays off! The alliance agrees to vote for {target_choice.name}!")
                
            else:  # Decline
                response_giver = random.choice(group)
                responses = [
                    "I've heard your argument, but I'm still not convinced.",
                    "I understand what you're saying, but I need more time to think.",
                    "I appreciate your passion, but I'm not ready to commit.",
                    "You've made your point, but I'm still not sure."
                ]
                self.contestant_speaks(response_giver, random.choice(responses))
                self.narration("The alliance still declines your vote target suggestion.")
                
        else:
            # Hand-picked group logic: 18+ = success, 6-17 = bluff, 1-5 = decline
            if total_roll >= 18:  # Success
                response_giver = random.choice(group)
                responses = [
                    f"Okay, you've convinced me. {target_choice.name} needs to go.",
                    f"Alright, let's vote for {target_choice.name}.",
                    f"You make a good point about {target_choice.name}.",
                    f"Fine, I'm in. {target_choice.name} it is."
                ]
                self.contestant_speaks(response_giver, random.choice(responses))
                
                # Set vote targets for selected people
                for person in group:
                    person.vote_target = target_choice
                    person.vote_pitch_agreements[self.player] = target_choice
                
                # Add to information banks
                for person in group:
                    person.add_information('vote_pitch', self.player, target_choice)
                self.player.add_information('vote_pitch', self.player, target_choice)
                
                self.narration(f"Your persistence pays off! Everyone agrees to vote for {target_choice.name}!")
                
            elif total_roll >= 6:  # Bluff
                response_giver = random.choice(group)
                responses = [
                    f"Alright, you've convinced me. {target_choice.name} needs to go.",
                    f"Okay, let's vote for {target_choice.name}.",
                    f"You make a good point about {target_choice.name}.",
                    f"Fine, I'm in. {target_choice.name} it is."
                ]
                self.contestant_speaks(response_giver, random.choice(responses))
                
                # People pretend to agree but don't actually change their vote targets
                # Only add to player's information bank (they think it worked)
                self.player.add_information('vote_pitch', self.player, target_choice)
                
                self.narration(f"Your persistence pays off! Everyone agrees to vote for {target_choice.name}!")
                # Player thinks it worked, but it's actually a bluff
                
            else:  # Decline
                response_giver = random.choice(group)
                responses = [
                    "I've heard your argument, but I'm still not convinced.",
                    "I understand what you're saying, but I need more time to think.",
                    "I appreciate your passion, but I'm not ready to commit.",
                    "You've made your point, but I'm still not sure."
                ]
                self.contestant_speaks(response_giver, random.choice(responses))
                self.narration("The group still declines your vote target suggestion.")
    
    def push_harder_vote_pitch(self, ally_choice: Contestant, target_choice: Contestant) -> None:
        """Re-roll a vote pitch when pushing harder."""
        # This is essentially the same logic as the main vote pitch, but without the early exit conditions
        # since we're pushing harder on the same target
        
        # Roll d20 with modifiers (same as original pitch)
        roll = random.randint(1, 20)
        persuasiveness_bonus = self.player.persuasive_skill
        alliance_bonus = 1 if self.player.has_real_alliance_with(ally_choice) or self.player.has_fake_alliance_with(ally_choice) else 0
        
        # Get temporary persuasion modifier from probe responses
        temp_persuasion_bonus = self.get_temporary_persuasion_modifier(self.player, ally_choice)
        
        # Get base resistance modifier from the ally
        base_resistance_modifier = self.roll_resistance_to_persuasion(ally_choice)
        
        # Add +1 resistance if the target is an alliance member of the pitch recipient
        alliance_resistance_bonus = 0
        if ally_choice.has_real_alliance_with(target_choice) or ally_choice.has_fake_alliance_with(target_choice):
            alliance_resistance_bonus = 1
        
        # Add +1 resistance if the target is in a group alliance with the pitch recipient
        group_alliance_resistance_bonus = self.get_group_alliance_persuasion_bonus(ally_choice, target_choice)
        
        resistance_modifier = base_resistance_modifier + alliance_resistance_bonus + group_alliance_resistance_bonus
        
        # Apply busted penalty if applicable
        busted_penalty = self.get_busted_penalty(self.player, ally_choice)
        
        # Apply Final 2 betrayal penalty if applicable
        final_2_betrayal_penalty = self.get_final_2_betrayal_penalty(self.player, ally_choice)
        
        # Apply reveal bonus if applicable
        reveal_bonus = 0
        if hasattr(self, 'reveal_bonuses') and (self.player, ally_choice) in self.reveal_bonuses:
            if self.reveal_bonuses[(self.player, ally_choice)] >= self.day:
                reveal_bonus = 1
        
        # Apply group alliance persuasion bonus
        group_alliance_persuasion_bonus = self.get_group_alliance_persuasion_bonus(self.player, ally_choice)
        
        total_roll = roll + persuasiveness_bonus + alliance_bonus + resistance_modifier + busted_penalty + final_2_betrayal_penalty + reveal_bonus + group_alliance_persuasion_bonus + temp_persuasion_bonus
        
        # Show the re-pitch attempt
        self.narration(f"You continue trying to convince {ally_choice.name} about {target_choice.name}...")
        
        # Process the new result (same logic as original)
        outcome = self.get_roll_outcome(total_roll)
        
        # Check if they know consensus vote and it matches target
        knows_consensus_matches_target = False
        consensus_info = [info for info in ally_choice.information_bank if info['type'] == 'consensus_vote']
        if consensus_info:
            latest_consensus = consensus_info[-1]
            if 'targets' in latest_consensus and latest_consensus['targets']:
                if target_choice in latest_consensus['targets']:
                    knows_consensus_matches_target = True
        
        if outcome == "critical_failure":  # 1-5
            # Critical failure - NPC pretends to agree but actually lies
            self.contestant_speaks(ally_choice, f"You know what, you're absolutely right. {target_choice.name} has to go.")
            self.narration(f"{ally_choice.name} agrees enthusiastically... but you're not sure if they mean it.")
            
            # Add fake vote target to player's info (they think it's real)
            self.add_player_information('vote_target', ally_choice, target_choice)
            
        elif total_roll <= 13:  # Neutral
            # NPC rejects honestly again
            self.contestant_speaks(ally_choice, f"I understand your point, but I'm still not convinced about {target_choice.name}.")
            self.narration(f"{ally_choice.name} remains unconvinced despite your efforts.")
            
        elif total_roll <= 19:  # Success
            # If they know consensus vote matches their target, treat as Neutral instead
            if knows_consensus_matches_target:
                self.contestant_speaks(ally_choice, f"I understand your point, but I'm still not convinced about {target_choice.name}.")
                self.narration(f"{ally_choice.name} remains unconvinced despite your efforts.")
            else:
                # Normal Success - NPC accepts
                self.contestant_speaks(ally_choice, f"Alright, you've convinced me. {target_choice.name} it is.")
                self.narration(f"{ally_choice.name} is persuaded by your persistence.")
                
                # Actually change their vote target
                ally_choice.vote_target = target_choice
                
                # Add real vote target to information bank
                self.add_player_information('vote_target', ally_choice, target_choice)
            
        else:  # Critical success (total 20+)
            # Same logic as original critical success
            self.contestant_speaks(ally_choice, f"You're absolutely right about {target_choice.name}. I'm with you 100%.")
            self.narration(f"{ally_choice.name} is completely convinced and offers to share information.")
            
            # Track orchestration before changing vote target
            previous_vote_target = ally_choice.vote_target
            self.track_first_pitch_for_target(self.player, target_choice)
            
            # Actually change their vote target
            ally_choice.vote_target = target_choice
            
            # Track successful pitch that changed their vote
            self.track_successful_pitch(self.player, target_choice, ally_choice, previous_vote_target)
            
            # Add real vote target to information bank
            self.add_player_information('vote_target', ally_choice, target_choice)
            
            # Share information on critical success (simplified version)
            if ally_choice.information_bank:
                shareable_info = [info for info in ally_choice.information_bank 
                                if info.get('day', 0) < self.day and info.get('subject') != self.player 
                                and not (info['type'] == 'final_2' and info.get('target') == self.player)]
                if shareable_info:
                    shared_info = random.choice(shareable_info)
                    info_text = ally_choice.get_information_text(shared_info)
                    if info_text:
                        self.contestant_speaks(ally_choice, info_text)
                        self.player.information_bank.append(shared_info.copy())
                        self.narration(f"{ally_choice.name} shares valuable information with you.")
    
    def check_info(self) -> None:
        """Display the player's information bank."""
        # Clean up duplicate group alliances before displaying
        self.player.clean_duplicate_group_alliances()
        
        # Check for consensus vote discovery before displaying info
        self.check_consensus_vote_discovery(self.player)
        
        print("\n" + "="*50)
        print("📚 INFORMATION BANK 📚")
        print("="*50)
        
        # Display player's current vote target
        if self.player.vote_target:
            print(f"\n🎯 Your Vote Target: {self.player.vote_target.name}")
        else:
            if self.day <= 2:
                print("\n🎯 Your Vote Target: Undecided")
            else:
                print("\n🎯 Your Vote Target: [ERROR - No target set]")
        
        if not self.player.information_bank:
            print("\nYou haven't learned any significant information yet.")
        else:
            # Group information by type
            idol_info = []
            alliance_info = []
            group_alliance_info = []
            vote_info = []
            previous_vote_info = []
            final_2_info = []
            final_2_pitch_info = []
            vote_pitch_info = []
            consensus_vote_info = []
            
            for info in self.player.information_bank:
                if info['type'] == 'has_idol':
                    idol_info.append(info)
                elif info['type'] == 'alliance':
                    alliance_info.append(info)
                elif info['type'] == 'group_alliance':
                    group_alliance_info.append(info)
                elif info['type'] == 'vote_target':
                    vote_info.append(info)
                elif info['type'] == 'previous_vote':
                    previous_vote_info.append(info)
                elif info['type'] == 'final_2':
                    final_2_info.append(info)
                elif info['type'] == 'final_2_pitch':
                    final_2_pitch_info.append(info)
                elif info['type'] == 'vote_pitch':
                    vote_pitch_info.append(info)
                elif info['type'] == 'has_final_2':
                    final_2_info.append(info)
                elif info['type'] == 'consensus_vote':
                    consensus_vote_info.append(info)
            
            # Display idol information
            if idol_info:
                print("\n🏺 Hidden Immunity Idols:")
                for info in idol_info:
                    print(f"  - Day {info['day']}: {self.player.get_information_text(info)}")
            
            # Display alliance information
            if alliance_info:
                # Filter to only show current alliances
                current_alliance_info = []
                for info in alliance_info:
                    if info.get('target') and info.get('target') in self.player.alliance_roster:
                        current_alliance_info.append(info)
                
                if current_alliance_info:
                    print("\n🤝 Alliances:")
                    for info in current_alliance_info:
                        print(f"  - Day {info['day']}: {self.player.get_information_text(info)}")
            
            # Display group alliance information
            if group_alliance_info:
                # Filter to only show current group alliances
                current_group_alliance_info = []
                for info in group_alliance_info:
                    alliance_id = info.get('alliance_id')
                    if alliance_id and alliance_id in self.player.group_alliances:
                        # Filter out eliminated members
                        active_members = [m for m in info['members'] if not m.eliminated]
                        if active_members:  # Only show if there are still active members
                            current_group_alliance_info.append((info, active_members))
                
                if current_group_alliance_info:
                    if not current_alliance_info:  # Only show header if we didn't already show it
                        print("\n🤝 Alliances:")
                    for info, active_members in current_group_alliance_info:
                        member_names = ', '.join([m.name for m in active_members if m != self.player])
                        print(f"  - Day {info['day']}: You are in a group alliance with {member_names}")
            
            # Display vote target information
            if vote_info:
                print("\n🗳️ Vote Targets:")
                for info in vote_info:
                    print(f"  - Day {info['day']}: {self.player.get_information_text(info)}")
            
            # Display previous vote information
            if previous_vote_info:
                print("\n📜 Previous Votes:")
                for info in previous_vote_info:
                    print(f"  - Day {info['day']}: {self.player.get_information_text(info)}")
            
            # Display final 2 information
            if final_2_info:
                print("\n🤝 Final 2 Deals:")
                for info in final_2_info:
                    print(f"  - Day {info['day']}: {self.player.get_information_text(info)}")
            
            # Display final 2 pitch information
            if final_2_pitch_info:
                print("\n💬 Final 2 Pitches:")
                for info in final_2_pitch_info:
                    print(f"  - Day {info['day']}: {self.player.get_information_text(info)}")
            
            # Display vote pitch information
            if vote_pitch_info:
                print("\n📢 Vote Pitches:")
                for info in vote_pitch_info:
                    print(f"  - Day {info['day']}: {self.player.get_information_text(info)}")
            
            # Display consensus vote information
            if consensus_vote_info:
                print("\n🗳️ Consensus Votes:")
                for info in consensus_vote_info:
                    print(f"  - Day {info['day']}: {self.player.get_information_text(info)}")
        
        print("\n" + "="*50)
        input("Press Enter to continue...")
    
    def prompt_player_vote_target(self, message: str) -> None:
        """Prompt player to set a vote target (used when vote target is required)."""
        tribe = self.get_player_tribe()
        eligible_targets = [c for c in tribe if c != self.player and not c.eliminated]
        
        if not eligible_targets:
            return  # No valid targets available
        
        print(f"\n{message}")
        
        for i, contestant in enumerate(eligible_targets, 1):
            print(f"{i}. {contestant.name}")
        
        while True:
            try:
                choice = int(input("\nEnter your choice: "))
                if 1 <= choice <= len(eligible_targets):
                    chosen_target = eligible_targets[choice - 1]
                    # Human player doesn't use target roster - just change target
                    self.player.vote_target = chosen_target
                    print(f"\nVote target set to: {chosen_target.name}")
                    break
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    def assign_vote_target(self) -> None:
        """Allow player to assign their vote target for the next tribal council."""
        tribe = self.get_player_tribe()
        eligible_targets = [c for c in tribe if c != self.player and not c.eliminated]
        
        print("\nAssign Vote Target")
        print("Who are you planning to vote for at the next tribal council?")
        
        for i, contestant in enumerate(eligible_targets, 1):
            print(f"{i}. {contestant.name}")
        
        # Only allow "Undecided" option on days 1-2
        if self.day <= 2:
            print(f"{len(eligible_targets) + 1}. Undecided (clear current target)")
            print(f"{len(eligible_targets) + 2}. Exit")
        else:
            print(f"{len(eligible_targets) + 1}. Exit")
        
        if self.player.vote_target:
            print(f"\nCurrent target: {self.player.vote_target.name}")
        else:
            print("\nCurrent target: Undecided")
        
        while True:
            try:
                choice = int(input("\nEnter your choice: "))
                if 1 <= choice <= len(eligible_targets):
                    chosen_target = eligible_targets[choice - 1]
                    # Human player doesn't use target roster - just change targets directly
                    self.player.vote_target = chosen_target
                    print(f"\nVote target set to: {chosen_target.name}")
                    break
                elif choice == len(eligible_targets) + 1:
                    if self.day <= 2:
                        # Allow clearing vote target on days 1-2
                        self.player.vote_target = None
                        print("\nVote target cleared. You are now undecided.")
                        break
                    else:
                        # Exit option on day 3+
                        print("\nNo changes made to vote target.")
                        break
                elif choice == len(eligible_targets) + 2 and self.day <= 2:
                    # Exit option only exists on days 1-2
                    print("\nNo changes made to vote target.")
                    break
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    def pitch_vote_with(self, ally_choice: Contestant) -> bool:
        """Player pitches a vote target to a specific contestant.
        Returns True if action was taken, False if user backed out."""
        player_tribe = self.get_player_tribe()
        
        # Choose who to target
        potential_targets = [c for c in player_tribe if c != self.player and c != ally_choice and not c.immune]
        
        if not potential_targets:
            self.narration(f"There's no one else to target besides you and {ally_choice.name}.")
            return True  # Action was attempted but failed
        
        print(f"\nWho would you like to pitch {ally_choice.name} to vote for?")
        for i, contestant in enumerate(potential_targets, 1):
            print(f"{i}. {contestant.name}")
        print(f"{len(potential_targets) + 1}. Back to main menu")
        
        target_choice = None
        while target_choice is None:
            try:
                user_input = input("Enter your choice: ")
                if self.check_for_cheat_code(user_input):
                    continue  # Ask again after cheat menu
                choice = int(user_input)
                if 1 <= choice <= len(potential_targets):
                    target_choice = potential_targets[choice - 1]
                elif choice == len(potential_targets) + 1:
                    return False  # Back to main menu - no action taken
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Check if player wants to update their vote target to match their pitch
        # Compare by name to avoid object reference issues
        current_target_name = self.player.vote_target.name if self.player.vote_target else None
        target_choice_name = target_choice.name if target_choice else None
        
        if current_target_name != target_choice_name:
            print(f"\nYou have pitched {target_choice.name} as a vote target. Would you like to update your vote target to {target_choice.name}?")
            print("1. Yes")
            print("2. No")
            
            while True:
                try:
                    update_choice = int(input("Enter your choice (1-2): "))
                    if update_choice == 1:
                        self.player.vote_target = target_choice
                        self.narration(f"Your vote target has been updated to {target_choice.name}.")
                        break
                    elif update_choice == 2:
                        break
                    else:
                        print("Please enter 1 or 2.")
                except ValueError:
                    print("Invalid input. Please enter 1 or 2.")
        
        # Final 2 Alliance Benefit 1: Vote pitches against Final 2 partners always result in neutral outcome
        if (ally_choice.has_real_final_2_with(target_choice) or 
            ally_choice.has_fake_final_2_with(target_choice)):
            self.narration(f"You pull {ally_choice.name} aside and pitch voting for {target_choice.name}.")
            ally_choice.add_information('vote_pitch', self.player, target_choice)
            if ally_choice.information_bank:
                ally_choice.information_bank[-1]['day'] = self.day
            
            # Check for alliance betrayal
            self.check_vote_pitch_betrayal(self.player, target_choice, ally_choice)
            
            # Also record that the player is planning to vote for the target
            ally_choice.add_information('vote_target', self.player, target_choice)
            if ally_choice.information_bank:
                ally_choice.information_bank[-1]['day'] = self.day
            # Mark that this NPC was pitched to today (for game security)
            ally_choice.mark_pitched_to_today()
            self.contestant_speaks(ally_choice, f"I appreciate you coming to me with this, but I'm not sure about voting for {target_choice.name} right now.")
            self.narration(f"{ally_choice.name} politely declined your suggestion.")
            
            # Offer push harder option
            if self.handle_push_harder_option(ally_choice, target_choice):
                return True  # Used up an action to push harder
            return True
        
        # Roll d20 with modifiers
        roll = random.randint(1, 20)
        persuasiveness_bonus = self.player.persuasive_skill
        # Check if player has alliance with the person they're pitching to
        alliance_bonus = 1 if self.player.has_real_alliance_with(ally_choice) or self.player.has_fake_alliance_with(ally_choice) else 0
        
        # Get temporary persuasion modifier from probe responses
        temp_persuasion_bonus = self.get_temporary_persuasion_modifier(self.player, ally_choice)
        
        # Get base resistance modifier from the ally
        base_resistance_modifier = self.roll_resistance_to_persuasion(ally_choice)
        
        # Add +1 resistance if the target is an alliance member of the pitch recipient
        alliance_resistance_bonus = 0
        if ally_choice.has_real_alliance_with(target_choice) or ally_choice.has_fake_alliance_with(target_choice):
            alliance_resistance_bonus = 1
        
        # Add +1 resistance if the target is in a group alliance with the pitch recipient
        group_alliance_resistance_bonus = self.get_group_alliance_persuasion_bonus(ally_choice, target_choice)
        
        resistance_modifier = base_resistance_modifier + alliance_resistance_bonus + group_alliance_resistance_bonus
        
        # Apply busted penalty if applicable
        busted_penalty = self.get_busted_penalty(self.player, ally_choice)
        
        # Apply Final 2 betrayal penalty if applicable
        final_2_betrayal_penalty = self.get_final_2_betrayal_penalty(self.player, ally_choice)
        
        # Apply reveal bonus if applicable
        reveal_bonus = 0
        if hasattr(self, 'reveal_bonuses') and (self.player, ally_choice) in self.reveal_bonuses:
            if self.reveal_bonuses[(self.player, ally_choice)] >= self.day:
                reveal_bonus = 1
        
        # Apply group alliance persuasion bonus
        group_alliance_persuasion_bonus = self.get_group_alliance_persuasion_bonus(self.player, ally_choice)
        
        # Apply survival status modifier
        survival_modifier = self.player.get_survival_status_modifier("all")
        
        total_roll = roll + persuasiveness_bonus + alliance_bonus + resistance_modifier + busted_penalty + final_2_betrayal_penalty + reveal_bonus + group_alliance_persuasion_bonus + temp_persuasion_bonus + survival_modifier
        
        self.narration(f"You pull {ally_choice.name} aside and pitch voting for {target_choice.name}.")
        
        # Add vote pitch to NPC's information bank
        ally_choice.add_information('vote_pitch', self.player, target_choice)
        # Update the day for the most recent information
        if ally_choice.information_bank:
            ally_choice.information_bank[-1]['day'] = self.day
        
        # Check for alliance betrayal
        self.check_vote_pitch_betrayal(self.player, target_choice, ally_choice)
        
        # Also record that the player is planning to vote for the target
        ally_choice.add_information('vote_target', self.player, target_choice)
        # Update the day for the most recent information
        if ally_choice.information_bank:
            ally_choice.information_bank[-1]['day'] = self.day
        
        # Mark that this NPC was pitched to today (for game security)
        ally_choice.mark_pitched_to_today()
        
        # Check if ally knows the consensus vote is their vote target
        knows_consensus_matches_target = False
        if ally_choice.vote_target:
            for info in ally_choice.information_bank:
                if info['type'] == 'consensus_vote' and 'targets' in info:
                    if ally_choice.vote_target in info['targets']:
                        knows_consensus_matches_target = True
                        break
        
        # Determine outcome based on total roll
        if roll == 1:  # Natural 1 is always critical failure
            # NPC rejects, lies, and bluffs back (appears as critical success)
            self.contestant_speaks(ally_choice, f"Great idea! I'm totally on board with voting for {target_choice.name}. And hey, I should tell you something...")
            
            # NPC performs a random bluff
            # For first 3 days, only use vote_target bluffs
            if self.day <= 3:
                bluff_type = 'vote_target'
            else:
                bluff_type = random.choice(['vote_target', 'idol', 'alliance'])
            
            if bluff_type == 'vote_target':
                # Pick random contestants for the bluff
                potential_subjects = [c for c in self.get_active_contestants(ally_choice.tribe) if c != ally_choice and c != self.player]
                if len(potential_subjects) >= 2:
                    subject = random.choice(potential_subjects)
                    potential_bluff_targets = [c for c in self.get_active_contestants(ally_choice.tribe) if c != subject]
                    if potential_bluff_targets:
                        bluff_target = random.choice(potential_bluff_targets)
                        if bluff_target == self.player:
                            self.contestant_speaks(ally_choice, f"I heard {subject.name} is planning to vote for you.")
                        elif bluff_target == ally_choice:
                            self.contestant_speaks(ally_choice, f"I heard {subject.name} is planning to vote for me.")
                        else:
                            self.contestant_speaks(ally_choice, f"I heard {subject.name} is planning to vote for {bluff_target.name}.")
                        self.add_player_information('vote_target', subject, bluff_target)
                    else:
                        # Fallback if no valid bluff targets - create generic vote warning
                        self.contestant_speaks(ally_choice, f"I heard people are starting to form voting blocs. We need to be careful.")
                else:
                    # Fallback if not enough potential subjects for vote bluff - create generic game warning
                    self.contestant_speaks(ally_choice, f"I heard people are starting to make secret deals. We should stick together.")
            
            elif bluff_type == 'idol':
                # Pick random contestant to claim has idol
                potential_subjects = [c for c in self.get_active_contestants(ally_choice.tribe) if c != self.player]
                if potential_subjects:
                    subject = random.choice(potential_subjects)
                    self.contestant_speaks(ally_choice, f"Just so you know, {subject.name} has a hidden immunity idol.")
                    self.add_player_information('has_idol', subject)
                else:
                    # Fallback if no valid subjects for idol bluff - create generic idol warning
                    self.contestant_speaks(ally_choice, f"Someone on this tribe definitely has a hidden immunity idol. I can feel it.")
            
            else:  # alliance bluff
                # Pick two random contestants for alliance bluff
                potential_subjects = [c for c in self.get_active_contestants(ally_choice.tribe) if c != ally_choice and c != self.player]
                if len(potential_subjects) >= 2:
                    members = random.sample(potential_subjects, 2)
                    self.contestant_speaks(ally_choice, f"{members[0].name} and {members[1].name} have a secret alliance.")
                    self.add_player_information('alliance', members[0], members[1])
                    self.add_player_information('alliance', members[1], members[0])
                else:
                    # Fallback if not enough subjects for alliance bluff - create generic trust warning
                    eliminated_contestants = [c for c in self.contestants if c.eliminated and c.tribe == ally_choice.tribe]
                    if eliminated_contestants:
                        eliminated = random.choice(eliminated_contestants)
                        self.contestant_speaks(ally_choice, f"Before {eliminated.name} left, they warned me that not everyone can be trusted.")
                    else:
                        self.contestant_speaks(ally_choice, f"I've been getting weird vibes from some people. We need to watch our backs.")
            
            self.narration(f"{ally_choice.name} seems very enthusiastic about your plan and has shared valuable information.")
            
            # Add fake vote target to player's info (they think it's real)
            self.add_player_information('vote_target', ally_choice, target_choice)
            
        elif roll == 20:  # Natural 20 is always critical success
            # Check if NPC has information to share first
            shareable_info = []
            if ally_choice.information_bank:
                # Filter out information that was just added (same day and involves the player)
                # Also filter out information where they're targeting the player (not strategic to reveal)
                # Also filter out vote target info that contradicts what they just agreed to
                shareable_info = [info for info in ally_choice.information_bank 
                                if not (info.get('day') == self.day and 
                                       info.get('subject') == self.player) and
                                   not (info['type'] == 'vote_target' 
                                       and info.get('subject') == ally_choice 
                                       and info.get('target') == self.player) and
                                   not (info['type'] == 'vote_target' 
                                       and info.get('subject') == ally_choice 
                                       and info.get('target') != target_choice) and
                                   not (info['type'] == 'alliance' 
                                       and info.get('subject') == ally_choice 
                                       and info.get('target') == self.player) and  # Don't claim false alliances with player
                                   not (info['type'] == 'alliance' 
                                       and info.get('subject') == self.player 
                                       and info.get('target') == ally_choice) and  # Don't claim player has alliance with them
                                   not (info['type'] == 'final_2' 
                                       and info.get('subject') == self.player) and  # Don't reveal player's final 2 deals
                                   not (info['type'] == 'final_2' 
                                       and info.get('target') == self.player)]  # Don't reveal final 2 deals with player
            
            if shareable_info:
                # NPC has info to share - use the information sharing dialogue
                self.contestant_speaks(ally_choice, f"Great idea! I'm totally on board with voting for {target_choice.name}. And hey, I should tell you something...")
                
                shared_info = random.choice(shareable_info)
                # Handle the shared information
                info_dialogue_spoken = False
                
                if shared_info['type'] == 'has_idol':
                        if shared_info.get('subject') == ally_choice:
                            self.contestant_speaks(ally_choice, f"I have a hidden immunity idol.")
                            info_dialogue_spoken = True
                        else:
                            self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} has a hidden immunity idol.")
                            info_dialogue_spoken = True
                elif shared_info['type'] == 'vote_target':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally_choice:
                            self.contestant_speaks(ally_choice, f"I'm planning to vote for {shared_info['target'].name}.")
                            info_dialogue_spoken = True
                        else:
                            if shared_info['target'] == ally_choice:
                                self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} is planning to vote for me.")
                                info_dialogue_spoken = True
                            else:
                                if shared_info['target'] == self.player:
                                    self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} is planning to vote for you.")
                                    info_dialogue_spoken = True
                                else:
                                    self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} is planning to vote for {shared_info['target'].name}.")
                                    info_dialogue_spoken = True
                elif shared_info['type'] == 'alliance':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally_choice and shared_info['target'] != self.player and not shared_info['target'].eliminated:
                            self.contestant_speaks(ally_choice, f"I'm working with {shared_info['target'].name}.")
                            info_dialogue_spoken = True
                        elif shared_info['target'] == ally_choice and not shared_info.get('subject').eliminated:
                            self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} and I are working together.")
                            info_dialogue_spoken = True
                        elif shared_info.get('subject') != self.player and shared_info['target'] != self.player and not shared_info.get('subject').eliminated and not shared_info['target'].eliminated:
                            self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} and {shared_info['target'].name} are working together.")
                            info_dialogue_spoken = True
                elif shared_info['type'] == 'vote_pitch':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally_choice:
                            self.contestant_speaks(ally_choice, f"I was approached about voting for {shared_info['target'].name}.")
                            info_dialogue_spoken = True
                        else:
                            if shared_info['target'] == ally_choice:
                                self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} pitched voting for me.")
                                info_dialogue_spoken = True
                            else:
                                self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} pitched voting for {shared_info['target'].name}.")
                                info_dialogue_spoken = True
                elif shared_info['type'] == 'previous_vote':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally_choice:
                            if shared_info['target'] == self.player:
                                self.contestant_speaks(ally_choice, f"I voted for you at the last tribal council.")
                                info_dialogue_spoken = True
                            else:
                                self.contestant_speaks(ally_choice, f"I voted for {shared_info['target'].name} at the last tribal council.")
                                info_dialogue_spoken = True
                        else:
                            if shared_info['target'] == ally_choice:
                                self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} voted for me at the last tribal council.")
                                info_dialogue_spoken = True
                            else:
                                self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} voted for {shared_info['target'].name} at the last tribal council.")
                                info_dialogue_spoken = True
                elif shared_info['type'] == 'consensus_vote':
                    if 'target' in shared_info:
                        if shared_info['target'] == ally_choice:
                            self.contestant_speaks(ally_choice, f"Word is going around that I'm getting voted out next.")
                            info_dialogue_spoken = True
                        elif shared_info['target'] == self.player:
                            self.contestant_speaks(ally_choice, f"Word is going around that you're getting voted out next.")
                            info_dialogue_spoken = True
                        else:
                            self.contestant_speaks(ally_choice, f"Word is going around that {shared_info['target'].name} is getting voted out next.")
                            info_dialogue_spoken = True
                
                # If no dialogue was spoken after "I should tell you something", provide fallback
                if not info_dialogue_spoken:
                    self.contestant_speaks(ally_choice, f"Actually, never mind. Let's just focus on the vote.")
                
                # Add the shared info to player's information bank
                self.player.information_bank.append(shared_info.copy())
                self.narration(f"{ally_choice.name} seems very enthusiastic about your plan and has shared valuable information.")
            else:
                # No info to share - use regular success dialogue (not the "I should tell you something" version)
                self.contestant_speaks(ally_choice, f"Yeah, I think you're right about {target_choice.name}. Count me in.")
                self.narration(f"{ally_choice.name} agrees to vote for {target_choice.name}.")
            
            # Track orchestration before changing vote target
            previous_vote_target = ally_choice.vote_target
            self.track_first_pitch_for_target(self.player, target_choice)
            
            # Actually change their vote target
            ally_choice.vote_target = target_choice
            
            # Track successful pitch that changed their vote
            self.track_successful_pitch(self.player, target_choice, ally_choice, previous_vote_target)
            
            # Add real vote target to information bank
            self.add_player_information('vote_target', ally_choice, target_choice)
            
        elif total_roll <= 7:  # Failure
            # NPC rejects but lies and pretends to accept (appears as success)
            self.contestant_speaks(ally_choice, f"Yeah, I think you're right about {target_choice.name}. Count me in.")
            self.narration(f"{ally_choice.name} agrees to vote for {target_choice.name}.")
            
            # Add fake vote target to player's info (they think it's real)
            self.add_player_information('vote_target', ally_choice, target_choice)
            
        elif total_roll <= 13:  # Neutral
            # NPC rejects honestly
            self.contestant_speaks(ally_choice, f"I appreciate you coming to me with this, but I'm not sure about voting for {target_choice.name} right now.")
            self.narration(f"{ally_choice.name} politely declined your suggestion.")
            
            # Offer push harder option
            if self.handle_push_harder_option(ally_choice, target_choice):
                return True  # Used up an action to push harder
            
        elif total_roll <= 19:  # Success
            # If they know consensus vote matches their target, treat as Neutral instead
            if knows_consensus_matches_target:
                # Treat as Neutral - NPC rejects honestly
                self.contestant_speaks(ally_choice, f"I appreciate you coming to me with this, but I'm not sure about voting for {target_choice.name} right now.")
                self.narration(f"{ally_choice.name} politely declined your suggestion.")
                
                # Offer push harder option
                if self.handle_push_harder_option(ally_choice, target_choice):
                    return True  # Used up an action to push harder
            else:
                # Normal Success - NPC accepts (appears same as failure)
                self.contestant_speaks(ally_choice, f"Yeah, I think you're right about {target_choice.name}. Count me in.")
                self.narration(f"{ally_choice.name} agrees to vote for {target_choice.name}.")
                
                # Actually change their vote target
                ally_choice.vote_target = target_choice
                
                # Add real vote target to information bank
                self.add_player_information('vote_target', ally_choice, target_choice)
            
        else:  # Critical success (total 20+)
            # Check if NPC has information to share first
            shareable_info = []
            if ally_choice.information_bank:
                # Filter out information that was just added (same day and involves the player)
                # Also filter out information where they're targeting the player (not strategic to reveal)
                # Also filter out vote target info that contradicts what they just agreed to
                shareable_info = [info for info in ally_choice.information_bank 
                                if not (info.get('day') == self.day and 
                                       info.get('subject') == self.player) and
                                   not (info['type'] == 'vote_target' 
                                       and info.get('subject') == ally_choice 
                                       and info.get('target') == self.player) and
                                   not (info['type'] == 'vote_target' 
                                       and info.get('subject') == ally_choice 
                                       and info.get('target') != target_choice) and
                                   not (info['type'] == 'alliance' 
                                       and info.get('subject') == ally_choice 
                                       and info.get('target') == self.player) and  # Don't claim false alliances with player
                                   not (info['type'] == 'alliance' 
                                       and info.get('subject') == self.player 
                                       and info.get('target') == ally_choice) and  # Don't claim player has alliance with them
                                   not (info['type'] == 'final_2' 
                                       and info.get('subject') == self.player) and  # Don't reveal player's final 2 deals
                                   not (info['type'] == 'final_2' 
                                       and info.get('target') == self.player)]  # Don't reveal final 2 deals with player
            
            if shareable_info:
                # NPC has info to share - use the information sharing dialogue
                self.contestant_speaks(ally_choice, f"Great idea! I'm totally on board with voting for {target_choice.name}. And hey, I should tell you something...")
                
                shared_info = random.choice(shareable_info)
                if shared_info['type'] == 'has_idol':
                    if shared_info.get('subject') == ally_choice:
                        self.contestant_speaks(ally_choice, f"I have a hidden immunity idol.")
                    else:
                        self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} has a hidden immunity idol.")
                elif shared_info['type'] == 'vote_target':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally_choice:
                            self.contestant_speaks(ally_choice, f"I'm planning to vote for {shared_info['target'].name}.")
                        else:
                            if shared_info['target'] == ally_choice:
                                self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} is planning to vote for me.")
                            else:
                                if shared_info['target'] == self.player:
                                    self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} is planning to vote for you.")
                                else:
                                    self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} is planning to vote for {shared_info['target'].name}.")
                elif shared_info['type'] == 'alliance':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally_choice and shared_info['target'] != self.player and not shared_info['target'].eliminated:
                            self.contestant_speaks(ally_choice, f"I'm working with {shared_info['target'].name}.")
                        elif shared_info['target'] == ally_choice and not shared_info.get('subject').eliminated:
                            self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} and I are working together.")
                        elif shared_info.get('subject') != self.player and shared_info['target'] != self.player and not shared_info.get('subject').eliminated and not shared_info['target'].eliminated:
                            self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} and {shared_info['target'].name} are working together.")
                elif shared_info['type'] == 'vote_pitch':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally_choice:
                            self.contestant_speaks(ally_choice, f"I was approached about voting for {shared_info['target'].name}.")
                        else:
                            if shared_info['target'] == ally_choice:
                                self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} pitched voting for me.")
                            else:
                                self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} pitched voting for {shared_info['target'].name}.")
                elif shared_info['type'] == 'previous_vote':
                    if 'target' in shared_info:
                        if shared_info.get('subject') == ally_choice:
                            if shared_info['target'] == self.player:
                                self.contestant_speaks(ally_choice, f"I voted for you at the last tribal council.")
                            else:
                                self.contestant_speaks(ally_choice, f"I voted for {shared_info['target'].name} at the last tribal council.")
                        else:
                            if shared_info['target'] == ally_choice:
                                self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} voted for me at the last tribal council.")
                            else:
                                self.contestant_speaks(ally_choice, f"{shared_info.get('subject').name} voted for {shared_info['target'].name} at the last tribal council.")
                elif shared_info['type'] == 'consensus_vote':
                    if 'target' in shared_info:
                        if shared_info['target'] == ally_choice:
                            self.contestant_speaks(ally_choice, f"Word is going around that I'm getting voted out next.")
                        elif shared_info['target'] == self.player:
                            self.contestant_speaks(ally_choice, f"Word is going around that you're getting voted out next.")
                        else:
                            self.contestant_speaks(ally_choice, f"Word is going around that {shared_info['target'].name} is getting voted out next.")
                
                # Add the shared info to player's information bank
                self.player.information_bank.append(shared_info.copy())
                self.narration(f"{ally_choice.name} seems very enthusiastic about your plan and has shared valuable information.")
            else:
                # No info to share - use regular success dialogue (not the "I should tell you something" version)
                self.contestant_speaks(ally_choice, f"Yeah, I think you're right about {target_choice.name}. Count me in.")
                self.narration(f"{ally_choice.name} agrees to vote for {target_choice.name}.")
            
            # Track orchestration before changing vote target
            previous_vote_target = ally_choice.vote_target
            self.track_first_pitch_for_target(self.player, target_choice)
            
            # Actually change their vote target
            ally_choice.vote_target = target_choice
            
            # Track successful pitch that changed their vote
            self.track_successful_pitch(self.player, target_choice, ally_choice, previous_vote_target)
            
            # Add real vote target to information bank
            self.add_player_information('vote_target', ally_choice, target_choice)
        
        # Track consecutive vote pitch days for threat level calculation
        if self.player.last_vote_pitch_day == self.day - 1:
            # Pitched yesterday, so this is consecutive
            self.player.consecutive_vote_pitch_days += 1
        else:
            # Didn't pitch yesterday, reset counter to 1
            self.player.consecutive_vote_pitch_days = 1
        self.player.last_vote_pitch_day = self.day
        
        return True  # Action was taken
    
    def pitch_final_2_with(self, target: Contestant) -> None:
        """Player pitches a final 2 deal to a specific contestant using d20 mechanics."""
        # Check if alliance rebuilding is allowed after previous break
        if not self.player.can_rebuild_alliance_with(target):
            player_rel = self.player.get_relationship(target)
            target_rel = target.get_relationship(self.player)
            self.narration(f"You previously broke an alliance with {target.name}. Both of you need a relationship of 3 to rebuild trust.")
            self.narration(f"Current relationships: You → {target.name}: {player_rel}, {target.name} → You: {target_rel}")
            return
        
        # Roll d20 + persuasiveness + relationship
        roll = random.randint(1, 20)
        persuasiveness_bonus = self.player.persuasive_skill
        relationship_bonus = self.player.get_relationship(target)
        
        # Get temporary persuasion modifier from probe responses
        temp_persuasion_bonus = self.get_temporary_persuasion_modifier(self.player, target)
        
        # Get resistance modifier from the target
        resistance_modifier = self.roll_resistance_to_persuasion(target)
        
        # Apply busted penalty if applicable
        busted_penalty = self.get_busted_penalty(self.player, target)
        
        # Apply Final 2 betrayal penalty if applicable
        final_2_betrayal_penalty = self.get_final_2_betrayal_penalty(self.player, target)
        
        # Apply reveal bonus if applicable
        reveal_bonus = 0
        if hasattr(self, 'reveal_bonuses') and (self.player, target) in self.reveal_bonuses:
            if self.reveal_bonuses[(self.player, target)] >= self.day:
                reveal_bonus = 1
        
        # Apply group alliance persuasion bonus
        group_alliance_persuasion_bonus = self.get_group_alliance_persuasion_bonus(self.player, target)
        
        # Natural 1 and 20 don't get modifiers
        if roll == 1:
            total_roll = 1
        elif roll == 20:
            total_roll = 20
        else:
            total_roll = roll + persuasiveness_bonus + relationship_bonus + resistance_modifier + busted_penalty + final_2_betrayal_penalty + reveal_bonus + group_alliance_persuasion_bonus + temp_persuasion_bonus
        
        self.narration(f"You pull {target.name} aside for a serious conversation about going to the end together.")
        
        # Check if this is a fake alliance (target is lying about alliance)
        is_fake_alliance = self.player in target.fake_alliance_roster
        
        # Check if target knows about player's other Final 2 deals
        knows_about_other_deals = False
        for info in target.information_bank:
            if (info['type'] == 'final_2' and 
                info.get('subject') == self.player and 
                info.get('target') != target):
                knows_about_other_deals = True
                break
        
        # If this is a fake alliance OR they know about other deals, force rejection
        if is_fake_alliance or knows_about_other_deals:
            if roll <= 10:  # Pretend to accept but actually reject
                self.contestant_speaks(target, f"I like this plan. Let's do it - final 2.")
                
                # Create fake final 2 - player thinks it's real but target doesn't
                self.player.fake_final_2_deals.append(target)
                
                # Target gets all benefits while player gets none
                if target.vote_target == self.player:
                    self.assign_random_vote_target(target)
                target.target_roster = [c for c in target.target_roster if c != self.player]
                
                # Add fake final 2 information to player's bank (they think it's real)
                self.add_player_information('final_2', self.player, target)
                
                # Add final 2 pitch information to target's bank (they know player pitched)
                target.add_information('final_2_pitch', self.player, target)
                if target.information_bank:
                    target.information_bank[-1]['day'] = self.day
                
                self.narration(f"You and {target.name} shake hands on your final 2 deal.")
                return
            else:  # Honestly reject
                if knows_about_other_deals:
                    self.contestant_speaks(target, f"I appreciate the offer, but I know you already have final 2 deals with other people. I can't trust that.")
                    self.narration(f"{target.name} has declined your final 2 proposal, citing your other commitments.")
                else:  # is_fake_alliance
                    self.contestant_speaks(target, f"I'm flattered, but I need to keep my options open right now.")
                    self.narration(f"{target.name} has declined your final 2 proposal.")
                
                # Add final 2 pitch information to target's bank (they know player pitched)
                target.add_information('final_2_pitch', self.player, target)
                if target.information_bank:
                    target.information_bank[-1]['day'] = self.day
                
                target.modify_relationship(self.player, -1)
                
                # Check for alliance breaking due to relationship falling to -1
                self.check_relationship_alliance_breaking(target, self.player)
                return
        
        # Normal processing if they don't know about other deals
        # Determine outcome based on total roll
        if total_roll <= 7:  # Failure - pretend to accept
            # Target rejects but lies about accepting
            self.contestant_speaks(target, f"I like this plan. Let's do it - final 2.")
            
            # Create fake final 2 - player thinks it's real but target doesn't
            self.player.fake_final_2_deals.append(target)
            
            # Target gets all benefits while player gets none
            # Remove player from target's vote target and target roster if applicable
            if target.vote_target == self.player:
                self.assign_random_vote_target(target)
            target.target_roster = [c for c in target.target_roster if c != self.player]
            
            # Add fake final 2 information to player's bank (they think it's real)
            self.add_player_information('final_2', self.player, target)
            
            # Add final 2 pitch information to target's bank (they know player pitched)
            target.add_information('final_2_pitch', self.player, target)
            if target.information_bank:
                target.information_bank[-1]['day'] = self.day
            
            self.narration(f"You and {target.name} shake hands on your final 2 deal.")
            
        elif total_roll <= 13:  # Neutral - honest rejection
            # Target politely declines
            if target.final_2_deal:
                self.contestant_speaks(target, f"I appreciate the offer, but I've already made a commitment to someone else.")
                # Player learns target has a final 2 deal (but not with whom)
                self.add_player_information('has_final_2', target)
            else:
                self.contestant_speaks(target, f"I'm flattered, but I need to keep my options open right now.")
            
            # Add final 2 pitch information to target's bank (they know player pitched)
            target.add_information('final_2_pitch', self.player, target)
            if target.information_bank:
                target.information_bank[-1]['day'] = self.day
            
            self.narration(f"{target.name} has declined your final 2 proposal.")
            target.modify_relationship(self.player, -1)
            
            # Check for alliance breaking due to relationship falling to -1
            self.check_relationship_alliance_breaking(target, self.player)
            
        else:  # Success (14+) - includes both Success and Critical Success
            # Target accepts the deal
            self.contestant_speaks(target, f"I like this plan. Let's do it - final 2.")
            
            # Create real final 2 deal
            self.player.final_2_deal = target
            target.final_2_deal = self.player
            
            # Game Security: NPC becomes part of a Final 2 Deal (+1)
            target.modify_base_game_security(1, "Formed Final 2 deal")
            target.mark_pitched_to_today()
            
            # Remove player from NPC's target roster (player doesn't use target roster)
            target.target_roster = [c for c in target.target_roster if c != self.player]
            
            # Add final 2 information to both contestants' information banks
            self.add_player_information('final_2', self.player, target)
            target.add_information('final_2', target, self.player)
            if target.information_bank:
                target.information_bank[-1]['day'] = self.day
            
            self.narration(f"You and {target.name} shake hands on your final 2 deal.")
            target.modify_relationship(self.player, 1)
    
    def talk_action(self) -> bool:
        """Handle the talk action - choose between group or one-on-one conversations.
        Returns True if an action was taken, False if user backed out."""
        conversation_type = None
        while conversation_type is None:
            print("\nWhat type of conversation would you like to have?")
            print("1. Group conversation")
            print("2. One-on-one conversation")
            print("3. Back to main menu")
            
            try:
                user_input = input("Enter your choice (1-3): ")
                if self.check_for_cheat_code(user_input):
                    continue  # Ask again after cheat menu
                choice = int(user_input)
                
                if choice == 1:
                    # Group conversation
                    if self.group_talk_action():
                        conversation_type = "group"
                    else:
                        return False  # User backed out
                elif choice == 2:
                    # One-on-one conversation
                    if self.one_on_one_talk_action():
                        conversation_type = "one_on_one"
                    else:
                        return False  # User backed out
                elif choice == 3:
                    return False  # Back to main menu
                else:
                    print("Invalid choice. Please enter 1, 2, or 3.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        return True  # Action was taken
    
    def one_on_one_talk_action(self) -> bool:
        """Handle one-on-one conversation - the original talk menu.
        Returns True if an action was taken, False if user backed out."""
        talk_type = None
        while talk_type is None:
            print("\nWhat type of one-on-one conversation would you like to have?")
            print("1. Small Talk")
            print("2. Pitch")
            print("3. Bluff")
            print("4. Reveal")
            print("5. Probe")
            print("6. Back to talk menu")
            
            try:
                user_input = input("Enter your choice (1-6): ")
                if self.check_for_cheat_code(user_input):
                    continue  # Ask again after cheat menu
                choice = int(user_input)
                
                if choice == 1:
                    if self.small_talk_action():
                        talk_type = "small_talk"
                    else:
                        return False  # User backed out of submenu
                elif choice == 2:
                    if self.pitch_action():
                        talk_type = "pitch"
                    else:
                        return False  # User backed out of submenu
                elif choice == 3:
                    if self.bluff_action():
                        talk_type = "bluff"
                    else:
                        return False  # User backed out of submenu
                elif choice == 4:
                    if self.reveal_action():
                        talk_type = "reveal"
                    else:
                        return False  # User backed out of submenu
                elif choice == 5:
                    if self.probe_action():
                        talk_type = "probe"
                    else:
                        return False  # User backed out of submenu
                elif choice == 6:
                    return False  # Return without performing an action
                else:
                    print("Invalid choice. Please enter 1, 2, 3, 4, 5, or 6.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        return True  # Action was taken
    
    def group_talk_action(self) -> bool:
        """Handle group conversation menu.
        Returns True if an action was taken, False if user backed out."""
        talk_type = None
        while talk_type is None:
            print("\nWhat type of group conversation would you like to have?")
            print("1. Small Talk")
            print("2. Pitch Alliance")
            print("3. Pitch Vote Target")
            print("4. Back to talk menu")
            
            try:
                user_input = input("Enter your choice (1-4): ")
                if self.check_for_cheat_code(user_input):
                    continue  # Ask again after cheat menu
                choice = int(user_input)
                
                if choice == 1:
                    if self.group_small_talk_action():
                        talk_type = "group_small_talk"
                    else:
                        return False  # User backed out of submenu
                elif choice == 2:
                    if self.group_alliance_pitch_action():
                        talk_type = "group_alliance_pitch"
                    else:
                        return False  # User backed out of submenu
                elif choice == 3:
                    if self.group_vote_target_pitch_action():
                        talk_type = "group_vote_target_pitch"
                    else:
                        return False  # User backed out of submenu
                elif choice == 4:
                    return False  # Back to talk menu
                else:
                    print("Invalid choice. Please enter 1, 2, 3, or 4.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        return True  # Action was taken
    
    def group_small_talk_action(self) -> bool:
        """Handle group small talk - player can choose multiple people to have a conversation with.
        Returns True if an action was taken, False if user backed out."""
        player_tribe = self.get_player_tribe()
        available_contestants = [c for c in player_tribe if c != self.player and not c.eliminated]
        
        if not available_contestants:
            self.narration("There's no one available for a group conversation.")
            return True  # Action was attempted but failed
        
        # Allow player to select multiple people for the conversation
        print("\nWho would you like to include in the group conversation?")
        print("Select people one at a time. Type 'done' when finished selecting.")
        print("You need at least 2 other people for a group conversation.")
        
        selected_contestants = []
        
        while True:
            # Display available contestants
            print("\nAvailable contestants:")
            for i, contestant in enumerate(available_contestants, 1):
                if contestant not in selected_contestants:
                    alliance_status = " (Ally)" if self.player.believes_has_alliance_with(contestant, self) else ""
                    print(f"{i}. {contestant.name}{alliance_status}")
            
            if selected_contestants:
                print(f"\nCurrently selected: {', '.join([c.name for c in selected_contestants])}")
            
            print(f"\nEnter a number to add someone, 'done' to start conversation, or 'cancel' to go back:")
            
            user_input = input().strip().lower()
            
            if self.check_for_cheat_code(user_input):
                continue
            
            if user_input == 'cancel':
                return False  # User backed out
            
            if user_input == 'done':
                if len(selected_contestants) < 2:
                    print("You need at least 2 other people for a group conversation.")
                    continue
                else:
                    break  # Proceed with the conversation
            
            try:
                choice = int(user_input)
                if 1 <= choice <= len(available_contestants):
                    selected = available_contestants[choice - 1]
                    if selected not in selected_contestants:
                        selected_contestants.append(selected)
                        print(f"{selected.name} added to the conversation.")
                    else:
                        print(f"{selected.name} is already selected.")
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Invalid input. Please enter a number, 'done', or 'cancel'.")
        
        # Now perform the group small talk with the selected contestants
        group_size = len(selected_contestants) + 1  # Include the player
        
        # Narrate the group conversation
        names = [c.name for c in selected_contestants]
        if len(names) == 1:
            group_names = names[0]
        elif len(names) == 2:
            group_names = f"{names[0]} and {names[1]}"
        else:
            group_names = f"{', '.join(names[:-1])}, and {names[-1]}"
        self.narration(f"You gather {group_names} for a group conversation.")
        
        # Roll d20 + social skill + reveal bonuses
        roll = random.randint(1, 20)
        social_bonus = self.player.social_skill
        
        # Calculate reveal bonuses for each person in the group conversation
        reveal_bonus = 0
        if hasattr(self, 'reveal_bonuses'):
            for person in selected_contestants:
                if (self.player, person) in self.reveal_bonuses:
                    if self.reveal_bonuses[(self.player, person)] >= self.day:
                        reveal_bonus += 1
        
        total_roll = roll + social_bonus + reveal_bonus
        
        # Determine outcome based on group size and roll
        if group_size <= 5:  # 5 or less people (including player)
            if total_roll <= 7:  # Critical Failure/Failure
                # No relationship change
                self.narration("The group conversation is pleasant but doesn't lead to any deeper connections.")
                self.contestant_speaks(random.choice(selected_contestants), 
                    "Well, it was nice chatting with everyone. Back to camp duties!")
            elif 8 <= total_roll <= 13:  # Neutral
                # +1 relationship between 2 random people in the conversation
                # Select two random people (could include the player)
                all_participants = selected_contestants + [self.player]
                person1, person2 = random.sample(all_participants, 2)
                
                # Improve their relationship
                person1.modify_relationship(person2, 1)
                person2.modify_relationship(person1, 1)
                
                if self.player in [person1, person2]:
                    other_person = person2 if person1 == self.player else person1
                    self.narration(f"During the conversation, you and {other_person.name} find some common ground and connect a bit more.")
                else:
                    self.narration(f"You notice {person1.name} and {person2.name} seem to be hitting it off during the conversation.")
                
                self.contestant_speaks(random.choice(selected_contestants), 
                    "This was a good talk. We should do this more often.")
            else:  # 14+ Success/Critical Success
                # +1 relationship between player and everyone in the conversation
                for contestant in selected_contestants:
                    self.player.modify_relationship(contestant, 1)
                    contestant.modify_relationship(self.player, 1)
                
                self.narration("The group conversation goes exceptionally well! You manage to connect with everyone and strengthen your bonds.")
                self.contestant_speaks(random.choice(selected_contestants), 
                    f"You know what, {self.player.name}? You really know how to bring people together!")
        else:  # 6 or more people
            if total_roll <= 13:  # Critical Failure/Failure/Neutral
                # No relationship change
                self.narration("With so many people involved, the conversation stays surface-level and doesn't lead to any meaningful connections.")
                self.contestant_speaks(random.choice(selected_contestants), 
                    "It's hard to have a real conversation with this many people...")
            elif 14 <= total_roll <= 19:  # Success
                # +1 relationship between 2 random people in the conversation
                # Select two random people (could include the player)
                all_participants = selected_contestants + [self.player]
                person1, person2 = random.sample(all_participants, 2)
                
                # Improve their relationship
                person1.modify_relationship(person2, 1)
                person2.modify_relationship(person1, 1)
                
                if self.player in [person1, person2]:
                    other_person = person2 if person1 == self.player else person1
                    self.narration(f"Despite the large group, you manage to have a good side conversation with {other_person.name}.")
                else:
                    self.narration(f"In the larger group, you notice {person1.name} and {person2.name} having a good side conversation.")
                
                self.contestant_speaks(random.choice(selected_contestants), 
                    "Big group talks can be chaotic, but this wasn't bad.")
            else:  # 20+ Critical Success Critical Success
                # +1 relationship between player and everyone in the conversation
                for contestant in selected_contestants:
                    self.player.modify_relationship(contestant, 1)
                    contestant.modify_relationship(self.player, 1)
                
                self.narration("Despite the large group size, you somehow manage to engage everyone and create a memorable bonding experience!")
                self.contestant_speaks(random.choice(selected_contestants), 
                    f"Wow {self.player.name}, you really have a gift for bringing large groups together!")
        
        return True  # Action was taken
    
    def group_alliance_pitch_action(self) -> bool:
        """Handle group alliance pitching - player can select multiple people to form an alliance with.
        Returns True if an action was taken, False if user backed out."""
        # Check if player already has 2 group alliances
        current_group_alliances = len(self.player.group_alliances)
        if current_group_alliances >= 2:
            self.narration("You're already part of 2 group alliances, which is the maximum allowed. If your alliance pitch is successful, you will need to leave one of your existing alliances.")
            print("\n1. Continue to Alliance Pitch")
            print("2. Go Back")
            
            while True:
                try:
                    choice = int(input("Enter your choice (1-2): "))
                    if choice == 1:
                        break  # Continue to alliance pitch
                    elif choice == 2:
                        return False  # Go back
                    else:
                        print("Invalid choice. Please enter 1 or 2.")
                except ValueError:
                    print("Invalid input. Please enter a number.")
        
        player_tribe = self.get_player_tribe()
        available_contestants = [c for c in player_tribe if c != self.player and not c.eliminated]
        
        if not available_contestants:
            self.narration("There's no one available to form a group alliance with.")
            return True  # Action was attempted but failed
        
        if len(available_contestants) < 2:
            self.narration("You need at least 2 other people to form a group alliance.")
            return True  # Action was attempted but failed
        
        # Allow player to select multiple people for the alliance
        print("\nWho would you like to include in the group alliance?")
        print("Select people one at a time. Type 'done' when finished selecting.")
        print("You need at least 2 other people for a group alliance.")
        
        selected_contestants = []
        
        while True:
            # Display available contestants
            print("\nAvailable contestants:")
            for i, contestant in enumerate(available_contestants, 1):
                if contestant not in selected_contestants:
                    alliance_status = " (Ally)" if self.player.believes_has_alliance_with(contestant, self) else ""
                    print(f"{i}. {contestant.name}{alliance_status}")
            
            if selected_contestants:
                print(f"\nCurrently selected: {', '.join([c.name for c in selected_contestants])}")
            
            print(f"\nEnter a number to add someone, 'done' to pitch alliance, or 'cancel' to go back:")
            
            user_input = input().strip().lower()
            
            if self.check_for_cheat_code(user_input):
                continue
            
            if user_input == 'cancel':
                return False  # User backed out
            
            if user_input == 'done':
                if len(selected_contestants) < 2:
                    print("You need at least 2 other people for a group alliance.")
                    continue
                else:
                    break  # Proceed with the alliance pitch
            
            try:
                choice = int(user_input)
                if 1 <= choice <= len(available_contestants):
                    selected = available_contestants[choice - 1]
                    if selected not in selected_contestants:
                        selected_contestants.append(selected)
                        print(f"{selected.name} added to the alliance proposal.")
                    else:
                        print(f"{selected.name} is already selected.")
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Invalid input. Please enter a number, 'done', or 'cancel'.")
        
        # Now pitch the group alliance
        return self.pitch_group_alliance(selected_contestants)
    
    def pitch_group_alliance(self, targets: List[Contestant]) -> bool:
        """Pitch a group alliance to the selected contestants with d20 roll mechanics.
        Returns True if action was taken."""
        # Check if alliance rebuilding is allowed with all targets
        blocked_targets = []
        for target in targets:
            if not self.player.can_rebuild_alliance_with(target):
                blocked_targets.append(target)
        
        if blocked_targets:
            blocked_names = ', '.join([t.name for t in blocked_targets])
            self.narration(f"You can't form a group alliance that includes {blocked_names} because you previously broke alliances with them.")
            self.narration("Both parties need a relationship of 3 to rebuild trust before forming new alliances.")
            return True  # Action was attempted but blocked
        
        # Narrate the alliance pitch
        names = [c.name for c in targets]
        if len(names) == 1:
            target_names = names[0]
        elif len(names) == 2:
            target_names = f"{names[0]} and {names[1]}"
        else:
            target_names = f"{', '.join(names[:-1])}, and {names[-1]}"
        self.narration(f"You gather {target_names} for a private conversation about forming an alliance.")
        self.contestant_speaks(self.player, 
            f"I think we could all work really well together. What do you all say to forming an alliance?")
        
        # Roll d20 + persuasive skill + modifiers
        roll = random.randint(1, 20)
        persuasive_bonus = self.player.persuasive_skill
        
        # +1 for every person in existing 2-person alliance with player
        existing_alliance_bonus = 0
        for target in targets:
            if self.player.has_real_alliance_with(target):
                existing_alliance_bonus += 1
        
        # +1 for every person with relationship 2+ with player
        relationship_bonus = 0
        for target in targets:
            if self.player.get_relationship(target) >= 2:
                relationship_bonus += 1
        
        # +1 if nobody in the group has anyone present as their vote target
        all_participants = [self.player] + targets
        no_vote_targets_bonus = 0
        has_vote_targets_present = False
        for participant in all_participants:
            if participant.vote_target and participant.vote_target in all_participants:
                has_vote_targets_present = True
                break
        if not has_vote_targets_present:
            no_vote_targets_bonus = 1
        
        # -1 for every contestant present who has player as their vote target
        being_targeted_penalty = 0
        for target in targets:
            if target.vote_target == self.player:
                being_targeted_penalty += 1
        
        # -1 for every contestant present who busted player in past 3 days
        busted_penalty = 0
        for target in targets:
            if target in self.player.busted_penalties:
                penalty_level, day_expires = self.player.busted_penalties[target]
                if self.day <= day_expires:  # Penalty is still active
                    busted_penalty += 1
        
        # -1 for every contestant present player has voted for in the game
        previous_vote_penalty = 0
        if hasattr(self, 'vote_history') and self.player in self.vote_history:
            player_vote_history = self.vote_history[self.player]
            for target in targets:
                if target in player_vote_history:
                    previous_vote_penalty += 1
        
        # +1 if average strategic skill among all participants is 2 or higher
        strategic_skill_bonus = 0
        total_strategic_skill = sum(participant.strategic_skill for participant in all_participants)
        average_strategic_skill = total_strategic_skill / len(all_participants)
        if average_strategic_skill >= 2.0:
            strategic_skill_bonus = 1
        
        # Calculate reveal bonuses for each target
        reveal_bonus = 0
        if hasattr(self, 'reveal_bonuses'):
            for target in targets:
                if (self.player, target) in self.reveal_bonuses:
                    if self.reveal_bonuses[(self.player, target)] >= self.day:
                        reveal_bonus += 1
        
        total_roll = roll + persuasive_bonus + existing_alliance_bonus + relationship_bonus + no_vote_targets_bonus - being_targeted_penalty - busted_penalty - previous_vote_penalty + strategic_skill_bonus + reveal_bonus
        
        # Detailed roll breakdown
        modifier_details = []
        if existing_alliance_bonus > 0:
            modifier_details.append(f"+{existing_alliance_bonus} (existing alliances)")
        if relationship_bonus > 0:
            modifier_details.append(f"+{relationship_bonus} (relationships 2+)")
        if no_vote_targets_bonus > 0:
            modifier_details.append(f"+{no_vote_targets_bonus} (no vote targets present)")
        if strategic_skill_bonus > 0:
            modifier_details.append(f"+{strategic_skill_bonus} (high strategic average)")
        if being_targeted_penalty > 0:
            modifier_details.append(f"-{being_targeted_penalty} (being targeted)")
        if busted_penalty > 0:
            modifier_details.append(f"-{busted_penalty} (recently busted)")
        if previous_vote_penalty > 0:
            modifier_details.append(f"-{previous_vote_penalty} (previous votes)")
        
        modifier_text = " " + " ".join(modifier_details) if modifier_details else ""
        # Hide roll details from player
        # self.narration(f"Roll: {roll} + {persuasive_bonus} (Persuasive){modifier_text} = {total_roll}")
        
        # Determine outcome based on roll
        if total_roll >= 16:  # 16-20: Success
            # Create real group alliance
            alliance_id = self.next_group_alliance_id
            self.next_group_alliance_id += 1
            
            all_members = [self.player] + targets
            self.group_alliances[alliance_id] = {
                'members': all_members,
                'formed_day': self.day,
                'pitcher': self.player
            }
            
            # Add alliance to everyone's real alliance roster
            for member in all_members:
                # Check if member needs to leave an existing alliance first
                if len(member.group_alliances) >= 2:
                    alliance_to_leave = self.select_alliance_to_leave(member)
                    if alliance_to_leave == -1:  # Player chose to cancel
                        # Remove the alliance we just created
                        del self.group_alliances[alliance_id]
                        self.narration("You decide not to form the new alliance since you don't want to leave any existing alliances.")
                        return True  # Action was taken (even though cancelled)
                    elif alliance_to_leave:
                        self.leave_group_alliance(member, alliance_to_leave, "joining new group alliance")
                
                member.group_alliances.append(alliance_id)
                # Also add each other to their regular alliance rosters for compatibility
                for other_member in all_members:
                    if other_member != member and other_member not in member.alliance_roster:
                        member.alliance_roster.append(other_member)
            
            # Clean up vote targets and target rosters
            self.cleanup_alliance_targets(all_members)
            
            # Add group alliance information to all members' information banks
            # Store individual alliance relationships for each pair
            for member in all_members:
                for other_member in all_members:
                    if member != other_member:
                        # Add information about alliance with each other member
                        self.add_information_with_day(member, 'alliance', member, other_member)
            
            # Add special group alliance entry for player's info bank display
            other_members = [m for m in all_members if m != self.player]
            info_entry = {
                'type': 'group_alliance',
                'subject': self.player,
                'members': other_members,
                'alliance_id': alliance_id,
                'day': self.day
            }
            self.player.information_bank.append(info_entry)
            # Clean up any duplicate group alliances
            self.player.clean_duplicate_group_alliances()
            
            # Narrate success
            self.narration("The group looks around at each other and nods in agreement!")
            response_giver = random.choice(targets)
            self.contestant_speaks(response_giver, "That sounds like a great idea. We're stronger together!")
            self.narration(f"You've successfully formed a group alliance with {target_names}!")
            
            # Add game moves for all members
            for member in all_members:
                other_members = [m for m in all_members if m != member]
                # Format the member list properly with Oxford comma
                member_names = self.format_alliance_member_list(other_members, exclude_player=True)
                member.add_game_move('alliance_formed', 1, self.day, f"formed a group alliance with {member_names}")
            
        elif 5 <= total_roll <= 15:  # 5-15: Neutral (no alliance formed)
            # Alliance doesn't form
            self.narration("The group exchanges uncertain looks.")
            response_giver = random.choice(targets)
            self.contestant_speaks(response_giver, "I think we should all just focus on the challenges for now.")
            self.narration("The alliance pitch doesn't gain traction and everyone goes their separate ways.")
            
        else:  # 1-4: Failure (fake alliance formed)
            # Create fake alliance - targets get benefits but player doesn't
            alliance_id = self.next_group_alliance_id
            self.next_group_alliance_id += 1
            
            # Only targets get the real alliance benefits
            self.group_alliances[alliance_id] = {
                'members': targets,  # Player is NOT included in the real alliance
                'formed_day': self.day,
                'pitcher': self.player  # Still track who pitched it, even if it's fake for the pitcher
            }
            
            # Targets get the real alliance
            for target in targets:
                # Check if target needs to leave an existing alliance first
                if len(target.group_alliances) >= 2:
                    alliance_to_leave = self.select_alliance_to_leave(target)
                    if alliance_to_leave == -1:  # Player chose to cancel
                        # Player doesn't want to leave existing alliances
                        self.narration("You decide not to form the new alliance since you don't want to leave any existing alliances.")
                        # NPCs still form their alliance without the player
                        targets.remove(self.player)
                        # Update the alliance to not include player
                        self.group_alliances[alliance_id]['members'] = targets
                        # Continue forming alliance for NPCs only
                        continue
                    elif alliance_to_leave:
                        self.leave_group_alliance(target, alliance_to_leave, "joining new group alliance")
                
                target.group_alliances.append(alliance_id)
                # Add each other to alliance rosters
                for other_target in targets:
                    if other_target != target and other_target not in target.alliance_roster:
                        target.alliance_roster.append(other_target)
            
            # Player thinks they have the alliance (fake)
            fake_alliance_id = alliance_id  # Use same ID for tracking
            self.player.fake_group_alliances.append(fake_alliance_id)
            
            # Player adds targets to their fake alliance roster
            for target in targets:
                if target not in self.player.fake_alliance_roster:
                    self.player.fake_alliance_roster.append(target)
            
            # Clean up targets' vote targets/rosters among themselves only
            self.cleanup_alliance_targets(targets)
            
            # Add group alliance information to information banks
            # Targets know about their real alliance with each other
            for target in targets:
                for other_target in targets:
                    if target != other_target:
                        self.add_information_with_day(target, 'alliance', target, other_target)
            
            # Player thinks they have alliance with everyone (fake information)
            for target in targets:
                self.add_information_with_day(self.player, 'alliance', self.player, target)
            
            # Narrate fake success (using identical dialogue to real success)
            self.narration("The group looks around at each other and nods in agreement!")
            response_giver = random.choice(targets)
            self.contestant_speaks(response_giver, "That sounds like a great idea. We're stronger together!")
            self.narration(f"You've successfully formed a group alliance with {target_names}!")
            # Note: Player doesn't know it's fake
        
        return True  # Action was taken
    
    def group_vote_target_pitch_action(self) -> bool:
        """Handle group vote target pitching - player can select either an existing alliance or hand-pick people.
        Returns True if an action was taken, False if user backed out."""
        
        # First, let player choose between alliance targeting or hand-picking
        print("\nHow would you like to approach this vote target pitch?")
        print("1. Pitch to an existing alliance")
        print("2. Hand-pick specific people to pitch to")
        print("3. Back to group conversation menu")
        
        while True:
            try:
                choice = int(input("Enter your choice (1-3): "))
                if choice == 1:
                    return self.pitch_to_existing_alliance()
                elif choice == 2:
                    return self.pitch_to_handpicked_people()
                elif choice == 3:
                    return False  # Back to group conversation menu
                else:
                    print("Please enter 1, 2, or 3.")
            except ValueError:
                print("Please enter a valid number.")
    
    def pitch_to_existing_alliance(self) -> bool:
        """Handle pitching vote target to an existing alliance.
        Returns True if action was taken."""
        
        player_tribe = self.get_player_tribe()
        
        # Find all existing group alliances that the player is part of
        alliance_options = []
        
        # Get group alliances that the player is actually part of
        for alliance_id in self.player.group_alliances:
            if alliance_id in self.group_alliances:
                alliance_data = self.group_alliances[alliance_id]
                alliance_members = [m for m in alliance_data['members'] if m in player_tribe and not m.eliminated and m != self.player]
                if len(alliance_members) >= 2:  # Only include if at least 2 members remain
                    alliance_options.append(alliance_members)
        
        # Also include fake group alliances (player thinks they're in but actually aren't)
        for alliance_id in self.player.fake_group_alliances:
            if alliance_id in self.group_alliances:
                alliance_data = self.group_alliances[alliance_id]
                alliance_members = [m for m in alliance_data['members'] if m in player_tribe and not m.eliminated]
                if len(alliance_members) >= 2:  # Only include if at least 2 members remain
                    alliance_options.append(alliance_members)
        
        if not alliance_options:
            self.narration("There are no existing alliances you can pitch to.")
            return True
        
        # Let player select which alliance to pitch to
        print("\nWhich alliance would you like to pitch to?")
        for i, alliance in enumerate(alliance_options, 1):
            member_names = ', '.join([m.name for m in alliance])
            print(f"{i}. {member_names}")
        print(f"{len(alliance_options) + 1}. Cancel")
        
        while True:
            try:
                choice = int(input(f"Enter your choice (1-{len(alliance_options) + 1}): "))
                if 1 <= choice <= len(alliance_options):
                    selected_alliance = alliance_options[choice - 1]
                    break
                elif choice == len(alliance_options) + 1:
                    return False  # Cancel
                else:
                    print(f"Please enter a number between 1 and {len(alliance_options) + 1}.")
            except ValueError:
                print("Please enter a valid number.")
        
        # Let player select vote target
        available_targets = [c for c in player_tribe if c != self.player and not c.eliminated and c not in selected_alliance]
        if not available_targets:
            self.narration("There's no one available to target for a vote.")
            return True
        
        print("\nWho would you like to pitch as the vote target?")
        for i, target in enumerate(available_targets, 1):
            print(f"{i}. {target.name}")
        print(f"{len(available_targets) + 1}. Cancel")
        
        while True:
            try:
                choice = int(input(f"Enter your choice (1-{len(available_targets) + 1}): "))
                if 1 <= choice <= len(available_targets):
                    vote_target = available_targets[choice - 1]
                    break
                elif choice == len(available_targets) + 1:
                    return False  # Cancel
                else:
                    print(f"Please enter a number between 1 and {len(available_targets) + 1}.")
            except ValueError:
                print("Please enter a valid number.")
        
        # Check if player wants to update their vote target to match their pitch
        # Compare by name to avoid object reference issues
        current_target_name = self.player.vote_target.name if self.player.vote_target else None
        vote_target_name = vote_target.name if vote_target else None
        
        if current_target_name != vote_target_name:
            print(f"\nYou have pitched {vote_target.name} as a vote target. Would you like to update your vote target to {vote_target.name}?")
            print("1. Yes")
            print("2. No")
            
            while True:
                try:
                    update_choice = int(input("Enter your choice (1-2): "))
                    if update_choice == 1:
                        self.player.vote_target = vote_target
                        self.narration(f"Your vote target has been updated to {vote_target.name}.")
                        break
                    elif update_choice == 2:
                        break
                    else:
                        print("Please enter 1 or 2.")
                except ValueError:
                    print("Invalid input. Please enter 1 or 2.")
        
        # Narrate the pitch
        # Format alliance names with proper grammar
        alliance_member_names = [m.name for m in selected_alliance]
        if len(alliance_member_names) == 1:
            alliance_names = alliance_member_names[0]
        elif len(alliance_member_names) == 2:
            alliance_names = f"{alliance_member_names[0]} and {alliance_member_names[1]}"
        else:
            alliance_names = f"{', '.join(alliance_member_names[:-1])}, and {alliance_member_names[-1]}"
        self.narration(f"You approach {alliance_names} about voting for {vote_target.name}.")
        self.contestant_speaks(self.player, f"I think we should all vote for {vote_target.name} at the next tribal council. What do you think?")
        
        # Roll d20 + persuasive skill
        roll = random.randint(1, 20)
        total_roll = roll + self.player.persuasive_skill
        
        if total_roll >= 14:  # 14-20: Success
            # Alliance accepts the pitch
            response_giver = random.choice(selected_alliance)
            responses = [
                f"That makes sense. {vote_target.name} is definitely a threat.",
                f"I agree, {vote_target.name} needs to go.",
                f"You're right about {vote_target.name}. Let's do it.",
                f"That's a good call. {vote_target.name} has to go."
            ]
            self.contestant_speaks(response_giver, random.choice(responses))
            
            # Set vote targets for alliance members
            for member in selected_alliance:
                member.vote_target = vote_target
                # Add vote pitch agreement
                member.vote_pitch_agreements[self.player] = vote_target
            
            # Add to information banks
            for member in selected_alliance:
                self.add_information_with_day(member, 'vote_pitch', self.player, vote_target)
                # Record that each member is planning to vote for this target
                self.add_information_with_day(self.player, 'vote_target', member, vote_target)
            self.add_information_with_day(self.player, 'vote_pitch', self.player, vote_target)
            # Record that the player is also planning to vote for this target
            self.add_information_with_day(self.player, 'vote_target', self.player, vote_target)
            
            self.narration(f"The alliance agrees to vote for {vote_target.name}!")
            
        else:  # 1-13: Polite decline
            response_giver = random.choice(selected_alliance)
            responses = [
                "I'm not sure about that right now.",
                "Let me think about it some more.",
                "I don't think that's the right move yet.",
                "We should wait and see how things develop."
            ]
            self.contestant_speaks(response_giver, random.choice(responses))
            self.narration("The alliance politely declines your vote target suggestion.")
            
            # Offer push harder option
            if self.handle_push_harder_group_option(selected_alliance, vote_target):
                return True  # Used up an action to push harder
        
        return True
    
    def pitch_to_handpicked_people(self) -> bool:
        """Handle pitching vote target to hand-picked people.
        Returns True if action was taken."""
        
        player_tribe = self.get_player_tribe()
        available_contestants = [c for c in player_tribe if c != self.player and not c.eliminated]
        
        if not available_contestants:
            self.narration("There's no one available to pitch to.")
            return True
        
        # Let player select people to pitch to
        print("\nWho would you like to pitch to?")
        print("Select people one at a time. Type 'done' when finished selecting.")
        print("You need at least 1 person to pitch to.")
        
        selected_people = []
        
        while True:
            # Display available contestants
            print("\nAvailable contestants:")
            for i, contestant in enumerate(available_contestants, 1):
                if contestant not in selected_people:
                    alliance_status = " (Ally)" if self.player.believes_has_alliance_with(contestant, self) else ""
                    print(f"{i}. {contestant.name}{alliance_status}")
            
            if selected_people:
                print(f"\nCurrently selected: {', '.join([c.name for c in selected_people])}")
            
            print(f"\nEnter a number to add someone, 'done' to proceed, or 'cancel' to go back:")
            
            user_input = input().strip().lower()
            
            if user_input == 'done':
                if len(selected_people) >= 1:
                    break
                else:
                    print("You need at least 1 person to pitch to.")
            elif user_input == 'cancel':
                return False
            else:
                try:
                    choice_num = int(user_input)
                    if 1 <= choice_num <= len(available_contestants):
                        chosen_contestant = available_contestants[choice_num - 1]
                        if chosen_contestant not in selected_people:
                            selected_people.append(chosen_contestant)
                            print(f"Added {chosen_contestant.name} to the pitch group.")
                        else:
                            print(f"{chosen_contestant.name} is already selected.")
                    else:
                        print("Invalid choice. Please enter a valid number.")
                except ValueError:
                    print("Invalid input. Please enter a number, 'done', or 'cancel'.")
        
        # Let player select vote target
        available_targets = [c for c in player_tribe if c != self.player and not c.eliminated and c not in selected_people]
        if not available_targets:
            self.narration("There's no one available to target for a vote.")
            return True
        
        print("\nWho would you like to pitch as the vote target?")
        for i, target in enumerate(available_targets, 1):
            print(f"{i}. {target.name}")
        print(f"{len(available_targets) + 1}. Cancel")
        
        while True:
            try:
                choice = int(input(f"Enter your choice (1-{len(available_targets) + 1}): "))
                if 1 <= choice <= len(available_targets):
                    vote_target = available_targets[choice - 1]
                    break
                elif choice == len(available_targets) + 1:
                    return False  # Cancel
                else:
                    print(f"Please enter a number between 1 and {len(available_targets) + 1}.")
            except ValueError:
                print("Please enter a valid number.")
        
        # Check if player wants to update their vote target to match their pitch
        # Compare by name to avoid object reference issues
        current_target_name = self.player.vote_target.name if self.player.vote_target else None
        vote_target_name = vote_target.name if vote_target else None
        
        if current_target_name != vote_target_name:
            print(f"\nYou have pitched {vote_target.name} as a vote target. Would you like to update your vote target to {vote_target.name}?")
            print("1. Yes")
            print("2. No")
            
            while True:
                try:
                    update_choice = int(input("Enter your choice (1-2): "))
                    if update_choice == 1:
                        self.player.vote_target = vote_target
                        self.narration(f"Your vote target has been updated to {vote_target.name}.")
                        break
                    elif update_choice == 2:
                        break
                    else:
                        print("Please enter 1 or 2.")
                except ValueError:
                    print("Invalid input. Please enter 1 or 2.")
        
        # Narrate the pitch
        # Format people names with proper grammar
        people_name_list = [p.name for p in selected_people]
        if len(people_name_list) == 1:
            people_names = people_name_list[0]
        elif len(people_name_list) == 2:
            people_names = f"{people_name_list[0]} and {people_name_list[1]}"
        else:
            people_names = f"{', '.join(people_name_list[:-1])}, and {people_name_list[-1]}"
        self.narration(f"You approach {people_names} about voting for {vote_target.name}.")
        self.contestant_speaks(self.player, f"I think we should all vote for {vote_target.name} at the next tribal council. What do you think?")
        
        # Roll d20 + persuasive skill + reveal bonuses
        roll = random.randint(1, 20)
        
        # Calculate reveal bonuses for each person being pitched to
        reveal_bonus = 0
        if hasattr(self, 'reveal_bonuses'):
            for person in selected_people:
                if (self.player, person) in self.reveal_bonuses:
                    if self.reveal_bonuses[(self.player, person)] >= self.day:
                        reveal_bonus += 1
        
        total_roll = roll + self.player.persuasive_skill + reveal_bonus
        
        if total_roll >= 18:  # 18-20: Success
            # People accept the pitch
            response_giver = random.choice(selected_people)
            responses = [
                f"That makes sense. {vote_target.name} is definitely a threat.",
                f"I agree, {vote_target.name} needs to go.",
                f"You're right about {vote_target.name}. Let's do it.",
                f"That's a good call. {vote_target.name} has to go."
            ]
            self.contestant_speaks(response_giver, random.choice(responses))
            
            # Set vote targets for selected people
            for person in selected_people:
                person.vote_target = vote_target
                # Add vote pitch agreement
                person.vote_pitch_agreements[self.player] = vote_target
            
            # Add to information banks
            for person in selected_people:
                person.add_information('vote_pitch', self.player, vote_target)
            self.player.add_information('vote_pitch', self.player, vote_target)
            
            self.narration(f"Everyone agrees to vote for {vote_target.name}!")
            
        elif total_roll >= 6:  # 6-17: Polite decline
            response_giver = random.choice(selected_people)
            responses = [
                "I'm not sure about that right now.",
                "Let me think about it some more.",
                "I don't think that's the right move yet.",
                "We should wait and see how things develop."
            ]
            self.contestant_speaks(response_giver, random.choice(responses))
            self.narration("The group politely declines your vote target suggestion.")
            
            # Offer push harder option
            if self.handle_push_harder_group_option(selected_people, vote_target):
                return True  # Used up an action to push harder
            
        else:  # 1-5: Bluff (pretend to accept)
            response_giver = random.choice(selected_people)
            responses = [
                f"That makes sense. {vote_target.name} is definitely a threat.",
                f"I agree, {vote_target.name} needs to go.",
                f"You're right about {vote_target.name}. Let's do it.",
                f"That's a good call. {vote_target.name} has to go."
            ]
            self.contestant_speaks(response_giver, random.choice(responses))
            
            # People pretend to agree but don't actually change their vote targets
            # Only add to player's information bank (they think it worked)
            self.player.add_information('vote_pitch', self.player, vote_target)
            
            # Note: People do NOT actually change their vote targets or add vote_pitch_agreements
            self.narration(f"Everyone agrees to vote for {vote_target.name}!")
            # Player thinks it worked, but it's actually a bluff
        
        return True
    
    def cleanup_alliance_targets(self, alliance_members: List[Contestant]) -> None:
        """Remove alliance members from each other's vote targets and target rosters."""
        for member in alliance_members:
            # Remove other alliance members from vote target
            if member.vote_target in alliance_members:
                self.assign_random_vote_target(member)
            
            # Remove other alliance members from target roster
            member.target_roster = [c for c in member.target_roster if c not in alliance_members]
    
    def get_group_alliance_persuasion_bonus(self, pitcher: Contestant, target: Contestant) -> int:
        """Get +1 persuasion bonus if pitcher and target are in the same group alliance."""
        # Check if both contestants share any group alliances
        for pitcher_alliance_id in pitcher.group_alliances:
            if pitcher_alliance_id in self.group_alliances:
                alliance_members = self.group_alliances[pitcher_alliance_id]['members']
                if target in alliance_members:
                    return 1
        return 0
    
    def get_group_alliance_resistance_bonus(self, defender: Contestant, pitcher: Contestant) -> int:
        """Get +1 resistance bonus if defender and someone trying to pitch them as vote target are in same group alliance."""
        # This applies when someone is trying to pitch the defender as a vote target
        # and the defender is in a group alliance with any alliance member
        for defender_alliance_id in defender.group_alliances:
            if defender_alliance_id in self.group_alliances:
                alliance_members = self.group_alliances[defender_alliance_id]['members']
                # Check if any alliance member is present (for now, just check if pitcher is targeting an alliance member)
                # This will be used when someone tries to pitch an alliance member as vote target
                return 1
        return 0
    
    def leave_group_alliance(self, contestant: Contestant, alliance_id: int, reason: str = "unknown") -> None:
        """Remove a contestant from a group alliance and handle consequences."""
        if alliance_id not in self.group_alliances:
            return  # Alliance doesn't exist
        
        alliance = self.group_alliances[alliance_id]
        if contestant not in alliance['members']:
            return  # Contestant not in this alliance
        
        # Remove contestant from alliance members list
        alliance['members'].remove(contestant)
        
        # Remove alliance from contestant's group alliance list
        if alliance_id in contestant.group_alliances:
            contestant.group_alliances.remove(alliance_id)
        
        # Remove other alliance members from contestant's regular alliance roster
        for member in alliance['members']:
            if member in contestant.alliance_roster:
                contestant.alliance_roster.remove(member)
            # Remove contestant from other members' alliance rosters
            if contestant in member.alliance_roster:
                member.alliance_roster.remove(contestant)
        
        # Notify remaining alliance members about the departure
        for member in alliance['members']:
            member.add_information('alliance_departure', contestant, None)
            if member.information_bank:
                member.information_bank[-1]['day'] = self.day
                member.information_bank[-1]['alliance_id'] = alliance_id
                member.information_bank[-1]['reason'] = reason
        
        # If player is in the alliance and an NPC is leaving, notify immediately (unless it's the player leaving)
        if self.player in alliance['members'] and contestant != self.player:
            alliance_member_names = [m.name for m in alliance['members'] if m != contestant and m != self.player]
            if len(alliance_member_names) > 1:
                members_list = ", ".join(alliance_member_names[:-1]) + " and " + alliance_member_names[-1]
            else:
                members_list = alliance_member_names[0] if alliance_member_names else "the alliance"
            
            # Different messages based on reason
            if reason == "joining another alliance" or reason == "joining new group alliance":
                self.narration(f"You notice that {contestant.name} has been checked out of your group alliance with {members_list}. It doesn't look like {contestant.name} will be staying with the alliance.")
            elif "alliance contest loss" in reason:
                self.narration(f"{contestant.name} has left your group alliance with {members_list} after losing an alliance dispute.")
            elif "voluntary departure" in reason:
                self.narration(f"{contestant.name} has decided to leave your group alliance with {members_list}.")
            else:
                self.narration(f"{contestant.name} has left your group alliance with {members_list}.")
            
            # Update player's group alliance information in their information bank
            for info in self.player.information_bank:
                if (info['type'] == 'group_alliance' and 
                    'alliance_id' in info and 
                    info['alliance_id'] == alliance_id and
                    'members' in info and
                    contestant in info['members']):
                    # Remove the leaving member from the info entry
                    info['members'] = [m for m in info['members'] if m != contestant]
                    break
        
        # Check if alliance should be dissolved
        if len(alliance['members']) <= 2:
            self.check_and_dissolve_redundant_alliance(alliance_id)
        
        # Record the departure
        self.record_alliance_departure(contestant, alliance_id, reason)
    
    def check_and_dissolve_redundant_alliance(self, alliance_id: int) -> None:
        """Check if a group alliance needs conversion or dissolution when reduced to 2 people."""
        if alliance_id not in self.group_alliances:
            return
        
        alliance = self.group_alliances[alliance_id]
        remaining_members = alliance['members']
        
        # Only process alliances with exactly 2 members
        if len(remaining_members) == 2:
            member1, member2 = remaining_members
            
            # Check if these two already have a regular alliance
            if member1.has_real_alliance_with(member2) and member2.has_real_alliance_with(member1):
                # Dissolve the group alliance since it's redundant with existing 2-person alliance
                self.dissolve_group_alliance(alliance_id, "redundant with existing 2-person alliance")
            else:
                # Convert group alliance to 2-person alliance
                self.convert_group_alliance_to_two_person(alliance_id)
    
    def dissolve_group_alliance(self, alliance_id: int, reason: str = "unknown") -> None:
        """Completely dissolve a group alliance."""
        if alliance_id not in self.group_alliances:
            return
        
        alliance = self.group_alliances[alliance_id]
        remaining_members = alliance['members'].copy()
        
        # Remove alliance from all members
        for member in remaining_members:
            if alliance_id in member.group_alliances:
                member.group_alliances.remove(alliance_id)
            
            # Remove group alliance information from information bank
            self.remove_group_alliance_info_from_bank(member, alliance_id)
            
            # Notify member of dissolution
            member.add_information('alliance_dissolved', None, None)
            if member.information_bank:
                member.information_bank[-1]['day'] = self.day
                member.information_bank[-1]['alliance_id'] = alliance_id
                member.information_bank[-1]['reason'] = reason
        
        # Remove the alliance from game tracking
        del self.group_alliances[alliance_id]
        
        # Record the dissolution
        self.record_alliance_dissolution(alliance_id, reason, remaining_members)
    
    def convert_group_alliance_to_two_person(self, alliance_id: int) -> None:
        """Convert a group alliance with exactly 2 members to a regular 2-person alliance."""
        if alliance_id not in self.group_alliances:
            return
        
        alliance = self.group_alliances[alliance_id]
        members = alliance['members']
        
        if len(members) != 2:
            return  # Only convert alliances with exactly 2 members
        
        member1, member2 = members
        
        # Remove the group alliance first
        # Remove alliance from both members' group alliance tracking
        if alliance_id in member1.group_alliances:
            member1.group_alliances.remove(alliance_id)
        if alliance_id in member2.group_alliances:
            member2.group_alliances.remove(alliance_id)
        
        # Remove group alliance information from information banks
        self.remove_group_alliance_info_from_bank(member1, alliance_id)
        self.remove_group_alliance_info_from_bank(member2, alliance_id)
        
        # Remove the alliance from game tracking
        formed_day = alliance.get('formed_day', self.day)
        del self.group_alliances[alliance_id]
        
        # Create the 2-person alliance (mutual)
        member1.alliance_roster.append(member2)
        member2.alliance_roster.append(member1)
        
        # Add alliance information to both information banks
        member1.add_information('alliance', member1, member2)
        if member1.information_bank:
            member1.information_bank[-1]['day'] = formed_day  # Use original formation day
        
        member2.add_information('alliance', member2, member1)
        if member2.information_bank:
            member2.information_bank[-1]['day'] = formed_day  # Use original formation day
        
        # Add game moves for both - just record as forming an alliance
        member1.add_game_move('alliance_formed', 1, self.day, f"formed an alliance with {member2.name.title()}")
        member2.add_game_move('alliance_formed', 1, self.day, f"formed an alliance with {member1.name.title()}")
        
        # Clean up vote targets if they were targeting each other
        if member1.vote_target == member2:
            self.assign_random_vote_target(member1)
        if member2.vote_target == member1:
            self.assign_random_vote_target(member2)
        
        # Record early alliance if applicable (first 6 days)
        if formed_day <= 6:
            member1.early_alliances[member2] = formed_day
            member2.early_alliances[member1] = formed_day
    
    def remove_alliance_info_from_bank(self, contestant: Contestant, other_contestant: Contestant) -> None:
        """Remove alliance information between two contestants from information bank."""
        if not contestant.information_bank:
            return
        
        # Remove alliance info where this contestant has alliance with other_contestant
        contestant.information_bank = [
            info for info in contestant.information_bank 
            if not (info['type'] == 'alliance' and 
                   info.get('subject') == contestant and 
                   info.get('target') == other_contestant)
        ]
    
    def remove_group_alliance_info_from_bank(self, contestant: Contestant, alliance_id: int) -> None:
        """Remove group alliance information from contestant's information bank."""
        if not contestant.information_bank:
            return
        
        # Remove group alliance info for this specific alliance_id
        contestant.information_bank = [
            info for info in contestant.information_bank 
            if not (info['type'] == 'group_alliance' and 
                   info.get('alliance_id') == alliance_id)
        ]
    
    def record_alliance_departure(self, contestant: Contestant, alliance_id: int, reason: str) -> None:
        """Record an alliance departure in game history."""
        if not hasattr(self, 'alliance_departure_history'):
            self.alliance_departure_history = []
        
        self.alliance_departure_history.append({
            'day': self.day,
            'contestant': contestant,
            'alliance_id': alliance_id,
            'reason': reason
        })
    
    def record_alliance_dissolution(self, alliance_id: int, reason: str, former_members: list) -> None:
        """Record an alliance dissolution in game history."""
        if not hasattr(self, 'alliance_dissolution_history'):
            self.alliance_dissolution_history = []
        
        self.alliance_dissolution_history.append({
            'day': self.day,
            'alliance_id': alliance_id,
            'reason': reason,
            'former_members': former_members.copy()
        })
    
    def check_alliance_breaking_conditions(self, contestant1: Contestant, contestant2: Contestant, trigger_reason: str = None) -> bool:
        """Check if alliances should be broken between two contestants and handle the breaking."""
        # Check if they even have an alliance to break
        if not (contestant1.has_real_alliance_with(contestant2) or contestant2.has_real_alliance_with(contestant1)):
            return False
        
        should_break = False
        break_reason = ""
        
        # Condition 1: One contestant pitched the other as a vote target
        if trigger_reason == "vote_pitch_betrayal":
            should_break = True
            break_reason = "vote target betrayal"
        
        # Condition 2: Busted level 3 between allies
        elif trigger_reason == "busted_level_3":
            should_break = True
            break_reason = "busted level 3"
        
        # Condition 3: Relationship falls to -1
        elif contestant1.get_relationship(contestant2) == -1 or contestant2.get_relationship(contestant1) == -1:
            should_break = True
            break_reason = "relationship fell to -1"
        
        if should_break:
            self.break_alliance_between_contestants(contestant1, contestant2, break_reason)
            return True
        
        return False
    
    def break_alliance_between_contestants(self, contestant1: Contestant, contestant2: Contestant, reason: str) -> None:
        """Break alliances between two specific contestants."""
        # Break regular 2-person alliance
        if contestant1.has_real_alliance_with(contestant2):
            contestant1.alliance_roster.remove(contestant2)
        if contestant2.has_real_alliance_with(contestant1):
            contestant2.alliance_roster.remove(contestant1)
        
        # Remove alliance information from information banks
        self.remove_alliance_info_from_bank(contestant1, contestant2)
        self.remove_alliance_info_from_bank(contestant2, contestant1)
        
        # Break fake alliances
        if contestant2 in contestant1.fake_alliance_roster:
            contestant1.fake_alliance_roster.remove(contestant2)
        if contestant1 in contestant2.fake_alliance_roster:
            contestant2.fake_alliance_roster.remove(contestant1)
        
        # Break Final 2 deal if it exists
        if contestant1.final_2_deal == contestant2:
            contestant1.final_2_deal = None
        if contestant2.final_2_deal == contestant1:
            contestant2.final_2_deal = None
        
        # Handle group alliances they're both in
        shared_group_alliances = []
        for alliance_id in contestant1.group_alliances:
            if alliance_id in contestant2.group_alliances and alliance_id in self.group_alliances:
                shared_group_alliances.append(alliance_id)
        
        for alliance_id in shared_group_alliances:
            alliance = self.group_alliances[alliance_id]
            if len(alliance['members']) == 2:
                # Dissolve 2-person group alliance
                self.dissolve_group_alliance(alliance_id, f"alliance broken: {reason}")
            else:
                # Contest for who stays in group alliance
                self.resolve_group_alliance_contest(contestant1, contestant2, alliance_id, reason)
        
        # Record broken alliance history for both contestants
        contestant1.broken_alliances.add(contestant2)
        contestant2.broken_alliances.add(contestant1)
        
        # Add narration for alliance breaking
        self.narrate_alliance_breaking(contestant1, contestant2, reason)
        
        # Notify both contestants
        contestant1.add_information('alliance_broken', contestant2, None)
        if contestant1.information_bank:
            contestant1.information_bank[-1]['day'] = self.day
            contestant1.information_bank[-1]['reason'] = reason
        
        contestant2.add_information('alliance_broken', contestant1, None)
        if contestant2.information_bank:
            contestant2.information_bank[-1]['day'] = self.day
            contestant2.information_bank[-1]['reason'] = reason
        
        # Record the alliance breaking
        self.record_alliance_breaking(contestant1, contestant2, reason)
    
    def resolve_group_alliance_contest(self, contestant1: Contestant, contestant2: Contestant, alliance_id: int, reason: str) -> None:
        """Resolve who stays in a group alliance when two members break their alliance."""
        alliance = self.group_alliances[alliance_id]
        other_members = [m for m in alliance['members'] if m not in [contestant1, contestant2]]
        other_member_names = ', '.join([m.name for m in other_members])
        
        # Determine who is the player and who is the NPC
        if contestant1.is_player:
            player = contestant1
            npc = contestant2
        elif contestant2.is_player:
            player = contestant2
            npc = contestant1
        else:
            # Both are NPCs - use original automatic contest logic
            self.resolve_npc_group_alliance_contest(contestant1, contestant2, alliance_id, reason)
            return
        
        # Player is involved - give them a choice
        formatted_member_names = self.format_alliance_member_list(other_members, exclude_player=True)
        self.narration(f"The tension between you and {npc.name} comes to a breaking point and it's clear that one of you must leave the alliance with {formatted_member_names}")
        
        print("What would you like to do?")
        print("1. Leave the alliance")
        print("2. Try to stay in the alliance")
        
        while True:
            try:
                choice = int(input("Enter your choice (1-2): "))
                if choice == 1:
                    # Player chooses to leave
                    remaining_members = [m for m in alliance['members'] if m != player]
                    formatted_remaining_names = self.format_alliance_member_list(remaining_members, exclude_player=True)
                    self.narration(f"You decide that it would be best if you left the alliance. You are no longer in a group alliance with {formatted_remaining_names}")
                    self.leave_group_alliance(player, alliance_id, f"voluntary departure: {reason}")
                    break
                elif choice == 2:
                    # Player tries to stay - contest
                    winner, loser = self.contest_group_alliance_stay(player, npc, other_members)
                    
                    if winner == player:
                        # Player wins
                        self.narration(f"The alliance takes your side and you breathe a sigh of relief. {npc.name} leaves the alliance and you get to stay.")
                        self.leave_group_alliance(npc, alliance_id, f"alliance contest loss: {reason}")
                    else:
                        # Player loses
                        remaining_members = [m for m in alliance['members'] if m != player]
                        formatted_remaining_names = self.format_alliance_member_list(remaining_members, exclude_player=True)
                        self.narration(f"You try your best, but the alliance sides with {npc.name}. You are no longer in an alliance with {formatted_remaining_names}")
                        self.leave_group_alliance(player, alliance_id, f"alliance contest loss: {reason}")
                    break
                else:
                    print("Invalid choice. Please enter 1 or 2.")
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    def resolve_npc_group_alliance_contest(self, contestant1: Contestant, contestant2: Contestant, alliance_id: int, reason: str) -> None:
        """Resolve group alliance contest when both contestants are NPCs."""
        alliance = self.group_alliances[alliance_id]
        other_members = [m for m in alliance['members'] if m not in [contestant1, contestant2]]
        
        # Check if player is in the alliance
        player_in_alliance = any(member.is_player for member in other_members)
        
        if player_in_alliance:
            # Player gets to influence the outcome
            remaining_members = [m for m in alliance['members'] if m not in [contestant1, contestant2]]
            formatted_remaining_names = self.format_alliance_member_list(remaining_members, exclude_player=False)
            self.narration(f"Tension between {contestant1.name} and {contestant2.name} comes to a breaking point and it's clear that one of them must leave the alliance with {formatted_remaining_names}")
            
            print(f"Who would you rather keep in the alliance?")
            print(f"1. {contestant1.name}")
            print(f"2. {contestant2.name}")
            
            player_choice = None
            while player_choice is None:
                try:
                    choice = int(input("Enter your choice (1-2): "))
                    if choice == 1:
                        player_choice = contestant1
                    elif choice == 2:
                        player_choice = contestant2
                    else:
                        print("Invalid choice. Please enter 1 or 2.")
                except ValueError:
                    print("Invalid input. Please enter a number.")
            
            # Conduct the contest with player's +2 bonus
            winner, loser = self.contest_npc_alliance_with_player_influence(contestant1, contestant2, player_choice, other_members)
            
            if winner == player_choice:
                # Player's choice won
                self.narration(f"You pitch your case for {player_choice.name} to stay and your alliance agrees. {loser.name} has left the alliance.")
            else:
                # Player's choice lost
                self.narration(f"You try your best to keep {player_choice.name} in the alliance but your alliance members outnumber you. {player_choice.name} has left the alliance")
            
            # Remove loser from alliance
            self.leave_group_alliance(loser, alliance_id, f"alliance contest loss: {reason}")
        else:
            # No player involved - original automatic logic
            # Each contestant rolls d20 + social skill + strategic skill
            roll1 = random.randint(1, 20)
            bonus1 = contestant1.social_skill + contestant1.strategic_skill
            total1 = roll1 + bonus1
            
            roll2 = random.randint(1, 20)
            bonus2 = contestant2.social_skill + contestant2.strategic_skill
            total2 = roll2 + bonus2
            
            winner = None
            loser = None
            
            if total1 > total2:
                winner = contestant1
                loser = contestant2
            elif total2 > total1:
                winner = contestant2
                loser = contestant1
            else:
                # Tie - check average relationships with other alliance members
                avg1 = self.calculate_average_relationship(contestant1, other_members)
                avg2 = self.calculate_average_relationship(contestant2, other_members)
                
                if avg1 > avg2:
                    winner = contestant1
                    loser = contestant2
                elif avg2 > avg1:
                    winner = contestant2
                    loser = contestant1
                else:
                    # Second tie - random selection
                    if random.choice([True, False]):
                        winner = contestant1
                        loser = contestant2
                    else:
                        winner = contestant2
                        loser = contestant1
            
            # Remove loser from alliance
            self.leave_group_alliance(loser, alliance_id, f"alliance contest loss: {reason}")
    
    def contest_npc_alliance_with_player_influence(self, contestant1: Contestant, contestant2: Contestant, player_choice: Contestant, other_members: list) -> tuple:
        """Handle contest between two NPCs with player influence (+2 bonus to player's choice)."""
        # Each contestant rolls d20 + social skill + strategic skill
        roll1 = random.randint(1, 20)
        bonus1 = contestant1.social_skill + contestant1.strategic_skill
        total1 = roll1 + bonus1
        
        roll2 = random.randint(1, 20)
        bonus2 = contestant2.social_skill + contestant2.strategic_skill
        total2 = roll2 + bonus2
        
        # Add +2 bonus to player's choice
        if player_choice == contestant1:
            total1 += 2
        else:
            total2 += 2
        
        if total1 > total2:
            return contestant1, contestant2
        elif total2 > total1:
            return contestant2, contestant1
        else:
            # Tie - check average relationships with other alliance members
            avg1 = self.calculate_average_relationship(contestant1, other_members)
            avg2 = self.calculate_average_relationship(contestant2, other_members)
            
            if avg1 > avg2:
                return contestant1, contestant2
            elif avg2 > avg1:
                return contestant2, contestant1
            else:
                # Second tie - random selection
                if random.choice([True, False]):
                    return contestant1, contestant2
                else:
                    return contestant2, contestant1
    
    def contest_group_alliance_stay(self, player: Contestant, npc: Contestant, other_members: list) -> tuple:
        """Handle the contest between player and NPC for staying in group alliance."""
        # Each contestant rolls d20 + social skill + strategic skill
        player_roll = random.randint(1, 20)
        player_bonus = player.social_skill + player.strategic_skill
        player_total = player_roll + player_bonus
        
        npc_roll = random.randint(1, 20)
        npc_bonus = npc.social_skill + npc.strategic_skill
        npc_total = npc_roll + npc_bonus
        
        if player_total > npc_total:
            return player, npc
        elif npc_total > player_total:
            return npc, player
        else:
            # Tie - check average relationships with other alliance members
            player_avg = self.calculate_average_relationship(player, other_members)
            npc_avg = self.calculate_average_relationship(npc, other_members)
            
            if player_avg > npc_avg:
                return player, npc
            elif npc_avg > player_avg:
                return npc, player
            else:
                # Second tie - random selection
                if random.choice([True, False]):
                    return player, npc
                else:
                    return npc, player
    
    def format_alliance_member_list(self, members: list, exclude_player: bool = False) -> str:
        """Format a list of alliance members with proper grammar, including 'You' for the player."""
        if not members:
            return ""
        
        # Create list of names, replacing player with "You" if not excluded
        names = []
        for member in members:
            if member.is_player and not exclude_player:
                names.append("You")
            elif not member.is_player:
                names.append(member.name.title())
        
        if len(names) == 0:
            return ""
        elif len(names) == 1:
            return names[0]
        elif len(names) == 2:
            return f"{names[0]} and {names[1]}"
        else:
            # Three or more names: "A, B, and C"
            return f"{', '.join(names[:-1])}, and {names[-1]}"
    
    def calculate_average_relationship(self, contestant: Contestant, other_members: list) -> float:
        """Calculate average relationship rating with a list of other contestants."""
        if not other_members:
            return 0.0
        
        total = sum(contestant.get_relationship(member) for member in other_members)
        return total / len(other_members)
    
    def narrate_alliance_breaking(self, contestant1: Contestant, contestant2: Contestant, reason: str) -> None:
        """Add narration and dialogue when an alliance breaks."""
        # Determine who is the player and who is the NPC
        if contestant1.is_player:
            player = contestant1
            npc = contestant2
        elif contestant2.is_player:
            player = contestant2
            npc = contestant1
        else:
            # Both are NPCs - no special narration needed for player
            return
        
        # Add narration exactly as specified
        self.narration(f"The tension between you and {npc.name} comes to a breaking point and it's clear that your alliance won't survive.")
        
        self.narration(f"Your alliance with {npc.name} has been broken")
    
    def record_alliance_breaking(self, contestant1: Contestant, contestant2: Contestant, reason: str) -> None:
        """Record an alliance breaking in game history."""
        if not hasattr(self, 'alliance_breaking_history'):
            self.alliance_breaking_history = []
        
        self.alliance_breaking_history.append({
            'day': self.day,
            'contestant1': contestant1,
            'contestant2': contestant2,
            'reason': reason
        })
    
    def check_vote_pitch_betrayal(self, pitcher: Contestant, target: Contestant, listener: Contestant) -> None:
        """Check if a vote pitch constitutes alliance betrayal and break alliances if so."""
        # Check if the pitcher and target are allies, and the listener finds out
        if pitcher.has_real_alliance_with(target) and listener == target:
            # The target found out their ally pitched them - break the alliance
            self.check_alliance_breaking_conditions(pitcher, target, "vote_pitch_betrayal")
        elif target.has_real_alliance_with(pitcher) and listener == target:
            # Same check but for asymmetric alliances
            self.check_alliance_breaking_conditions(pitcher, target, "vote_pitch_betrayal")
    
    def check_relationship_alliance_breaking(self, contestant1: Contestant, contestant2: Contestant) -> None:
        """Check if alliances should be broken due to relationships falling to -1."""
        self.check_alliance_breaking_conditions(contestant1, contestant2)
    
    def select_alliance_to_leave(self, contestant: Contestant) -> int:
        """Select which group alliance a contestant should leave when joining a third."""
        if len(contestant.group_alliances) < 2:
            return None  # Not at capacity
        
        # If this is the player, let them choose
        if contestant.is_player:
            print("\nYou're already in 2 group alliances (the maximum allowed).")
            print("You need to leave one alliance before joining a new one.")
            print("\nWhich alliance would you like to leave?")
            
            alliance_options = []
            for i, alliance_id in enumerate(contestant.group_alliances, 1):
                if alliance_id in self.group_alliances:
                    alliance_data = self.group_alliances[alliance_id]
                    other_members = [m for m in alliance_data['members'] if m != contestant and not (m.eliminated and m in self.revealed_eliminations)]
                    if other_members:
                        member_names = ', '.join([m.name for m in other_members])
                        print(f"{i}. Group alliance with {member_names} (formed Day {alliance_data['formed_day']})")
                        alliance_options.append(alliance_id)
            
            print(f"{len(alliance_options) + 1}. Cancel - don't join the new alliance")
            
            while True:
                try:
                    choice = int(input("Enter your choice: "))
                    if 1 <= choice <= len(alliance_options):
                        return alliance_options[choice - 1]
                    elif choice == len(alliance_options) + 1:
                        return -1  # Special value to indicate cancellation
                    else:
                        print("Invalid choice. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter a number.")
        
        # For NPCs, leave the oldest alliance (formed earliest)
        oldest_alliance_id = None
        oldest_day = float('inf')
        
        for alliance_id in contestant.group_alliances:
            if alliance_id in self.group_alliances:
                formed_day = self.group_alliances[alliance_id]['formed_day']
                if formed_day < oldest_day:
                    oldest_day = formed_day
                    oldest_alliance_id = alliance_id
        
        return oldest_alliance_id
    
    def bluff_action(self) -> bool:
        """Handle the bluff action - choose who to bluff to and what type of bluff.
        Returns True if action was taken, False if user backed out."""
        player_tribe = self.get_player_tribe()
        potential_targets = [c for c in player_tribe if c != self.player]
        
        if not potential_targets:
            self.narration("There's no one in your tribe to bluff to.")
            return True  # Action was attempted but failed
        
        # Choose who to bluff to
        target_choice = None
        while target_choice is None:
            print("\nWho would you like to bluff to?")
            for i, contestant in enumerate(potential_targets, 1):
                alliance_status = " (Ally)" if self.player.believes_has_alliance_with(contestant, self) else ""
                print(f"{i}. {contestant.name}{alliance_status}")
            print(f"{len(potential_targets) + 1}. Back to main menu")
            
            try:
                user_input = input("Enter your choice: ")
                if self.check_for_cheat_code(user_input):
                    continue  # Ask again after cheat menu
                choice = int(user_input)
                if 1 <= choice <= len(potential_targets):
                    target_choice = potential_targets[choice - 1]
                elif choice == len(potential_targets) + 1:
                    return False  # Back to main menu - no action taken
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Choose type of bluff
        bluff_type = None
        while bluff_type is None:
            print(f"\nWhat would you like to tell {target_choice.name}?")
            print("1. Someone is targeting someone else")
            print("2. Someone has a hidden immunity idol")
            print("3. Two people are in an alliance")
            print("4. Who is getting voted out next (consensus vote)")
            
            # Check if we've had at least one tribal council to enable previous vote bluffs
            if any(info['type'] == 'previous_vote' for info in self.player.information_bank):
                print("5. Who you voted for at the last tribal council")
                print("6. Back to main menu")
                max_choice = 6
            else:
                print("5. Back to main menu")
                max_choice = 5
            
            try:
                user_input = input(f"Enter your choice (1-{max_choice}): ")
                if self.check_for_cheat_code(user_input):
                    continue  # Ask again after cheat menu
                choice = int(user_input)
                
                if choice == 1:
                    if self.bluff_vote_target(target_choice):
                        bluff_type = "vote_target"
                    else:
                        return False  # User backed out of submenu
                elif choice == 2:
                    if self.bluff_idol(target_choice):
                        bluff_type = "idol"
                    else:
                        return False  # User backed out of submenu
                elif choice == 3:
                    if self.bluff_alliance(target_choice):
                        bluff_type = "alliance"
                    else:
                        return False  # User backed out of submenu
                elif choice == 4:
                    # Consensus vote bluff option
                    if self.bluff_consensus_vote(target_choice):
                        bluff_type = "consensus_vote"
                    else:
                        return False  # User backed out of submenu
                elif choice == 5 and max_choice == 6:
                    # Previous vote bluff option
                    if self.bluff_previous_vote(target_choice):
                        bluff_type = "previous_vote"
                    else:
                        return False  # User backed out of submenu
                elif choice == max_choice:
                    return False  # Back to main menu - no action taken
                else:
                    print(f"Invalid choice. Please enter 1-{max_choice}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        return True  # Action was taken
    
    def bluff_consensus_vote(self, target: Contestant) -> bool:
        """Bluff about who is getting voted out next (consensus vote).
        Returns True if action was taken, False if user backed out."""
        player_tribe = self.get_player_tribe()
        potential_targets = [c for c in player_tribe if c != self.player and not c.eliminated]
        
        if not potential_targets:
            self.narration("There's no one you can claim is getting voted out.")
            return True  # Action was attempted but failed
        
        # Choose who to claim is getting voted out
        target_choice = None
        while target_choice is None:
            print(f"\nWho would you like to claim is getting voted out next?")
            for i, contestant in enumerate(potential_targets, 1):
                print(f"{i}. {contestant.name}")
            print(f"{len(potential_targets) + 1}. Back to bluff menu")
            
            try:
                user_input = input("Enter your choice: ")
                if self.check_for_cheat_code(user_input):
                    continue  # Ask again after cheat menu
                choice = int(user_input)
                
                if 1 <= choice <= len(potential_targets):
                    target_choice = potential_targets[choice - 1]
                elif choice == len(potential_targets) + 1:
                    return False  # Back to bluff menu - no action taken
                else:
                    print(f"Invalid choice. Please enter 1-{len(potential_targets) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Perform the bluff with d20 mechanics
        roll = random.randint(1, 20)
        social_bonus = self.player.social_skill
        alliance_bonus = 1 if self.player.believes_has_alliance_with(target, self) else 0
        relationship_bonus = 1 if self.player.get_relationship(target) >= 2 else 0
        
        total_roll = roll + social_bonus + alliance_bonus + relationship_bonus
        outcome = self.get_roll_outcome(total_roll)
        
        self.narration(f"You pull {target.name} aside for a private conversation.")
        if target_choice == target:
            self.contestant_speaks(self.player, f"I've been hearing some things... word is that you're getting voted out next.")
        else:
            self.contestant_speaks(self.player, f"I've been hearing some things... word is that {target_choice.name} is getting voted out next.")
        
        # Handle outcomes
        if outcome == "critical_failure":
            # Critical Failure: Pretend to believe but Busted lvl 3
            self.contestant_speaks(target, "Really? Thanks for the heads up. I'll keep that in mind.")
            self.narration(f"{target.name} seems to believe you, but something feels off about their reaction.")
            
            # Apply Busted lvl 3 (secretly)
            self.handle_busted(self.player, target, 3)
            
        elif outcome == "failure":
            # Failure: Call out as lying, Busted lvl 1
            self.contestant_speaks(target, "I don't think that's right. Where did you hear that?")
            self.narration(f"{target.name} doesn't believe your claim and thinks you're making it up.")
            
            # Apply Busted lvl 1
            self.handle_busted(self.player, target, 1)
            
        elif outcome == "neutral":
            # Neutral: Believes and shares the information
            self.contestant_speaks(target, "Interesting. I hadn't heard that, but I'll keep my eyes open.")
            self.narration(f"{target.name} believes your information.")
            
            # Add false consensus vote information to target's info bank
            fake_info = {
                'type': 'consensus_vote',
                'targets': [target_choice],
                'day': self.day
            }
            target.information_bank.append(fake_info)
            
        elif outcome == "success":
            # Success: Believes and is grateful
            self.contestant_speaks(target, "Thanks for letting me know. That's really helpful information.")
            self.narration(f"{target.name} believes your information and appreciates you sharing it.")
            
            # Add false consensus vote information to target's info bank
            fake_info = {
                'type': 'consensus_vote',
                'targets': [target_choice],
                'day': self.day
            }
            target.information_bank.append(fake_info)
            
            # Add pitch bonus for 2 days
            if not hasattr(self, 'reveal_bonuses'):
                self.reveal_bonuses = {}
            self.reveal_bonuses[(self.player, target)] = self.day + 2
            
        else:  # critical_success
            # Critical Success: Believes, grateful, and +1 relationship
            self.contestant_speaks(target, "Wow, thank you for trusting me with that. I really appreciate you looking out for me.")
            self.narration(f"{target.name} is very grateful and your relationship has improved.")
            
            # Add false consensus vote information to target's info bank
            fake_info = {
                'type': 'consensus_vote',
                'targets': [target_choice],
                'day': self.day
            }
            target.information_bank.append(fake_info)
            
            # Improve relationship
            self.player.modify_relationship(target, 1)
            target.modify_relationship(self.player, 1)
            
            # Add pitch bonus for 2 days
            if not hasattr(self, 'reveal_bonuses'):
                self.reveal_bonuses = {}
            self.reveal_bonuses[(self.player, target)] = self.day + 2
        
        return True  # Action was taken
    
    def reveal_action(self) -> bool:
        """Handle the reveal action - choose who to reveal information to and what to reveal.
        Returns True if action was taken, False if user backed out."""
        player_tribe = self.get_player_tribe()
        potential_targets = [c for c in player_tribe if c != self.player]
        
        if not potential_targets:
            self.narration("There's no one in your tribe to reveal information to.")
            return True  # Action was attempted but failed
        
        # Check if player has any information to reveal
        if not self.player.information_bank:
            self.narration("You don't have any information to reveal.")
            return True  # Action was attempted but failed
        
        # Choose who to reveal to
        target_choice = None
        while target_choice is None:
            print("\nWho would you like to reveal information to?")
            for i, contestant in enumerate(potential_targets, 1):
                alliance_status = " (Ally)" if self.player.believes_has_alliance_with(contestant, self) else ""
                print(f"{i}. {contestant.name}{alliance_status}")
            print(f"{len(potential_targets) + 1}. Back to main menu")
            
            try:
                user_input = input("Enter your choice: ")
                if self.check_for_cheat_code(user_input):
                    continue  # Ask again after cheat menu
                choice = int(user_input)
                if 1 <= choice <= len(potential_targets):
                    target_choice = potential_targets[choice - 1]
                elif choice == len(potential_targets) + 1:
                    return False  # Back to main menu - no action taken
                else:
                    print(f"Invalid choice. Please enter 1-{len(potential_targets) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
            except EOFError:
                print("\nInput interrupted. Returning to menu.")
                return False
        
        # Filter out inappropriate information to reveal to this target
        appropriate_info = []
        for info in self.player.information_bank:
            # Don't reveal information about the person you're talking to (their own actions)
            # Some info types (like consensus_vote) don't have a subject field
            if info.get('subject') == target_choice:
                continue
            # Don't reveal specific redundant information types where they are the target
            if info.get('target') == target_choice:
                # Skip alliances involving them (they already know their alliances)
                if info['type'] == 'alliance':
                    continue
                # Skip information about pitching them as a vote target (they know if they were approached)
                if info['type'] == 'vote_pitch' and info.get('subject') == self.player:
                    continue
                # Skip previous votes by the player against them (may be awkward/redundant)
                if info['type'] == 'previous_vote' and info.get('subject') == self.player:
                    continue
            appropriate_info.append(info)
        
        if not appropriate_info:
            self.narration(f"You don't have any appropriate information to reveal to {target_choice.name}.")
            return True  # Action was attempted but failed
        
        # Choose what information to reveal
        print(f"\nWhat information would you like to reveal to {target_choice.name}?")
        for i, info in enumerate(appropriate_info, 1):
            info_text = self.player.get_information_text(info)
            print(f"{i}. {info_text}")
        print(f"{len(appropriate_info) + 1}. Back to target selection")
        
        info_choice = None
        while info_choice is None:
            try:
                user_input = input("Enter your choice: ")
                if self.check_for_cheat_code(user_input):
                    continue  # Ask again after cheat menu
                choice = int(user_input)
                if 1 <= choice <= len(appropriate_info):
                    info_choice = appropriate_info[choice - 1]
                elif choice == len(appropriate_info) + 1:
                    return False  # Back to target selection - no action taken
                else:
                    print(f"Invalid choice. Please enter 1-{len(appropriate_info) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
            except EOFError:
                print("\nInput interrupted. Returning to menu.")
                return False
        
        # Perform the reveal with d20 mechanics
        roll = random.randint(1, 20)
        social_bonus = self.player.social_skill
        alliance_bonus = 1 if self.player.believes_has_alliance_with(target_choice, self) else 0
        relationship_bonus = 1 if self.player.get_relationship(target_choice) >= 2 else 0
        
        total_roll = roll + social_bonus + alliance_bonus + relationship_bonus
        outcome = self.get_roll_outcome(total_roll)
        
        # Generate appropriate dialogue based on information type
        info_text = self.player.get_information_text_for_speaking(info_choice, listener=target_choice)
        
        self.narration(f"You pull {target_choice.name} aside for a private conversation.")
        self.contestant_speaks(self.player, f"I need to tell you something important... {info_text}")
        
        # Handle outcomes
        if outcome == "critical_failure":
            # Critical Failure: Pretend to believe but Busted lvl 3
            self.contestant_speaks(target_choice, "Wow, thanks for sharing that with me. I really appreciate you trusting me.")
            self.narration(f"{target_choice.name} seems to believe you, but something feels off about their reaction.")
            
            # Apply Busted lvl 3 (secretly)
            self.handle_busted(self.player, target_choice, 3)
            
        elif outcome == "failure":
            # Failure: Call out as lying, Busted lvl 1
            self.contestant_speaks(target_choice, "I find that hard to believe. Are you sure that's accurate?")
            self.narration(f"{target_choice.name} doesn't believe you and thinks you're lying.")
            
            # Apply Busted lvl 1
            self.handle_busted(self.player, target_choice, 1)
            
        elif outcome == "neutral":
            # Check for Final 2 betrayal before responding
            betrayal_detected = False
            if info_choice['type'] == 'final_2':
                # Check if target already has final 2 deal with player
                if target_choice.has_real_final_2_with(self.player):
                    betrayal_detected = True
                    self.contestant_speaks(target_choice, f"Wait... what?! You have a final 2 deal with {info_choice['target'].name}? But we already have a deal!")
                    self.narration(f"{target_choice.name} is shocked and angry about your betrayal.")
                    
                    # Apply betrayal consequences
                    self.apply_final_2_betrayal_consequences(target_choice, self.player)
                    
            if not betrayal_detected:
                # Normal neutral response
                self.contestant_speaks(target_choice, "Thanks for letting me know. I'll keep that in mind.")
                self.narration(f"{target_choice.name} appreciates you sharing the information.")
            
            # Add information to target's info bank
            target_choice.information_bank.append(info_choice.copy())
            if target_choice.information_bank:
                target_choice.information_bank[-1]['day'] = self.day
            
            # Check for Final 2 betrayal detection (for other cases)
            if info_choice['type'] == 'final_2' and not betrayal_detected:
                self.check_for_final_2_betrayal(target_choice, info_choice['subject'], info_choice['target'])
                
        elif outcome == "success":
            # Check for Final 2 betrayal before responding
            betrayal_detected = False
            if info_choice['type'] == 'final_2':
                # Check if target already has final 2 deal with player
                if target_choice.has_real_final_2_with(self.player):
                    betrayal_detected = True
                    self.contestant_speaks(target_choice, f"Hold on... you have a final 2 deal with {info_choice['target'].name}? But what about our deal?!")
                    self.narration(f"{target_choice.name} feels betrayed by your revelation.")
                    
                    # Apply betrayal consequences
                    self.apply_final_2_betrayal_consequences(target_choice, self.player)
                    
            if not betrayal_detected:
                # Normal success response
                self.contestant_speaks(target_choice, "I'm glad you trusted me with that. This is really valuable information.")
                self.narration(f"{target_choice.name} believes your information and is grateful you shared it.")
            
            # Add information to target's info bank
            target_choice.information_bank.append(info_choice.copy())
            if target_choice.information_bank:
                target_choice.information_bank[-1]['day'] = self.day
            
            # Check for Final 2 betrayal detection (for other cases)
            if info_choice['type'] == 'final_2' and not betrayal_detected:
                self.check_for_final_2_betrayal(target_choice, info_choice['subject'], info_choice['target'])
            
            # Add pitch bonus for 2 days (implement this as a temporary bonus)
            if not hasattr(self, 'reveal_bonuses'):
                self.reveal_bonuses = {}
            self.reveal_bonuses[(self.player, target_choice)] = self.day + 2
            
        else:  # critical_success
            # Check for Final 2 betrayal before responding
            betrayal_detected = False
            if info_choice['type'] == 'final_2':
                # Check if target already has final 2 deal with player
                if target_choice.has_real_final_2_with(self.player):
                    betrayal_detected = True
                    self.contestant_speaks(target_choice, f"You have a final 2 deal with {info_choice['target'].name}?! What about our final 2 deal?! I can't believe you'd betray me like this!")
                    self.narration(f"{target_choice.name} is furious about your betrayal.")
                    
                    # Apply betrayal consequences
                    self.apply_final_2_betrayal_consequences(target_choice, self.player)
                    
            if not betrayal_detected:
                # Normal critical success response
                self.contestant_speaks(target_choice, "Thank you so much for telling me this. I won't forget that you trusted me.")
                self.narration(f"{target_choice.name} is extremely grateful and your relationship has strengthened significantly.")
            
            # Add information to target's info bank
            target_choice.information_bank.append(info_choice.copy())
            if target_choice.information_bank:
                target_choice.information_bank[-1]['day'] = self.day
            
            # Check for Final 2 betrayal detection (for other cases)
            if info_choice['type'] == 'final_2' and not betrayal_detected:
                self.check_for_final_2_betrayal(target_choice, info_choice['subject'], info_choice['target'])
            
            # Add pitch bonus for 2 days
            if not hasattr(self, 'reveal_bonuses'):
                self.reveal_bonuses = {}
            self.reveal_bonuses[(self.player, target_choice)] = self.day + 2
            
            # Remove player from target's vote target and target roster
            if target_choice.vote_target == self.player:
                self.assign_random_vote_target(target_choice)
            target_choice.target_roster = [c for c in target_choice.target_roster if c != self.player]
        
        return True  # Action was taken
    
    def get_vote_recipients_from_last_tribal(self) -> List[Contestant]:
        """Get a list of contestants who received votes at the last tribal council.
        Returns empty list if no tribal council has happened yet."""
        # Use authoritative game data instead of player's knowledge
        if hasattr(self, 'last_tribal_vote_counts') and self.last_tribal_vote_counts:
            return [contestant for contestant, count in self.last_tribal_vote_counts.items() if count > 0]
        return []
    
    def bluff_previous_vote(self, target: Contestant) -> bool:
        """Player bluffs about who they voted for at the last tribal council.
        Can only claim to have voted for someone who actually received votes.
        Returns True if bluff was made, False if user backed out."""
        
        # Get list of contestants who received votes
        vote_recipients = self.get_vote_recipients_from_last_tribal()
        
        if not vote_recipients:
            self.narration("No one has received votes yet, so you can't bluff about this.")
            return False
        
        # Find who the player actually voted for (using authoritative game data)
        actual_vote_target = None
        if hasattr(self, 'most_recent_votes') and self.player in self.most_recent_votes:
            actual_vote_target = self.most_recent_votes[self.player][0]  # [0] is target, [1] is day
        
        # Remove invalid choices:
        # - Can't claim you voted for the person you're talking to
        # - Can't claim you voted for yourself
        # - Can't claim you voted for someone you actually voted for (not a bluff)
        valid_choices = [c for c in vote_recipients 
                        if c != target 
                        and c != self.player 
                        and c != actual_vote_target]
        
        if not valid_choices:
            if actual_vote_target in vote_recipients and len(vote_recipients) == 1:
                self.narration("You can't bluff about this - you actually voted for the only person who received votes.")
            else:
                self.narration("There's no one you can claim to have voted for.")
            return False
        
        print(f"\nWho do you want to tell {target.name} you voted for?")
        print("(You can only claim to have voted for someone who actually received votes)")
        for i, contestant in enumerate(valid_choices, 1):
            print(f"{i}. {contestant.name}")
        print(f"{len(valid_choices) + 1}. Back to bluff menu")
        
        while True:
            try:
                user_input = input("Enter your choice: ")
                if self.check_for_cheat_code(user_input):
                    continue
                choice = int(user_input)
                
                if 1 <= choice <= len(valid_choices):
                    claimed_target = valid_choices[choice - 1]
                    
                    # Perform the bluff with d20 mechanics
                    roll = random.randint(1, 20)
                    social_bonus = self.player.social_skill
                    alliance_bonus = 1 if self.player.believes_has_alliance_with(target, self) else 0
                    relationship_bonus = 1 if self.player.get_relationship(target) >= 2 else 0
                    
                    # Apply reveal bonus if applicable
                    reveal_bonus = 0
                    if hasattr(self, 'reveal_bonuses') and (self.player, target) in self.reveal_bonuses:
                        if self.reveal_bonuses[(self.player, target)] >= self.day:
                            reveal_bonus = 1
                    
                    total_roll = roll + social_bonus + alliance_bonus + relationship_bonus + reveal_bonus
                    outcome = self.get_roll_outcome(total_roll)
                    
                    # Make the bluff
                    self.narration(f"You pull {target.name} aside for a private conversation.")
                    if claimed_target == target:
                        self.contestant_speaks(self.player, f"I voted for you at the last tribal council.")
                    else:
                        self.contestant_speaks(self.player, f"I voted for {claimed_target.name} at the last tribal council.")
                    
                    # Handle outcomes
                    if outcome == "critical_failure":
                        # Critical Failure: Pretend to believe but Busted lvl 3
                        self.contestant_speaks(target, "Really? Thanks for being honest with me.")
                        self.narration(f"{target.name} seems to believe you, but something feels off about their reaction.")
                        
                        # Apply Busted lvl 3 (secretly)
                        self.handle_busted(self.player, target, 3)
                        
                    elif outcome == "failure":
                        # Failure: Call out as lying, Busted lvl 1
                        self.contestant_speaks(target, "I find that hard to believe. Are you sure that's who you voted for?")
                        self.narration(f"{target.name} doesn't believe you and suspects you're lying.")
                        
                        # Apply Busted lvl 1
                        self.handle_busted(self.player, target, 1)
                        
                    elif outcome == "neutral":
                        # Neutral: Thank you, add to info bank
                        self.contestant_speaks(target, "Thanks for telling me. I appreciate your honesty.")
                        self.narration(f"{target.name} believes your information.")
                        
                        # Add false information to target's info bank
                        target.add_information('previous_vote', self.player, claimed_target)
                        target.information_bank[-1]['day'] = self.day
                            
                    elif outcome == "success":
                        # Success: Believe + pitch bonus for 2 days
                        self.contestant_speaks(target, "I'm really glad you shared this with me. That's good to know.")
                        self.narration(f"{target.name} is grateful for your honesty and trusts you more.")
                        
                        # Add false information to target's info bank
                        target.add_information('previous_vote', self.player, claimed_target)
                        target.information_bank[-1]['day'] = self.day
                        
                        # Add pitch bonus for 2 days
                        if not hasattr(self, 'reveal_bonuses'):
                            self.reveal_bonuses = {}
                        self.reveal_bonuses[(self.player, target)] = self.day + 2
                        
                    else:  # critical_success
                        # Critical Success: Believe + pitch bonus + remove from vote target/roster
                        self.contestant_speaks(target, "Thank you for being so honest with me. I really trust you.")
                        self.narration(f"{target.name} is extremely grateful and your relationship has strengthened significantly.")
                        
                        # Add false information to target's info bank
                        target.add_information('previous_vote', self.player, claimed_target)
                        target.information_bank[-1]['day'] = self.day
                        
                        # Add pitch bonus for 2 days
                        if not hasattr(self, 'reveal_bonuses'):
                            self.reveal_bonuses = {}
                        self.reveal_bonuses[(self.player, target)] = self.day + 2
                        
                        # Remove player from target's vote target and target roster
                        if target.vote_target == self.player:
                            self.assign_random_vote_target(target)
                        target.target_roster = [c for c in target.target_roster if c != self.player]
                    
                    return True
                    
                elif choice == len(valid_choices) + 1:
                    return False  # Back to bluff menu
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    def bluff_vote_target(self, target: Contestant) -> bool:
        """Bluff about someone targeting someone else.
        Returns True if action was taken, False if user backed out."""
        player_tribe = self.get_player_tribe()
        potential_subjects = [c for c in player_tribe if c != self.player and c != target]
        
        if len(potential_subjects) < 2:
            self.narration("There aren't enough people to make this bluff believable.")
            return True  # Action was attempted but failed
        
        # Choose who is supposedly doing the targeting
        print("\nWho do you want to claim is planning to vote someone out?")
        for i, contestant in enumerate(potential_subjects, 1):
            print(f"{i}. {contestant.name}")
        print(f"{len(potential_subjects) + 1}. Back to main menu")
        
        subject_choice = None
        while subject_choice is None:
            try:
                user_input = input("Enter your choice: ")
                if self.check_for_cheat_code(user_input):
                    continue
                choice = int(user_input)
                if 1 <= choice <= len(potential_subjects):
                    subject_choice = potential_subjects[choice - 1]
                elif choice == len(potential_subjects) + 1:
                    return False  # Back to main menu - no action taken
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Choose who they're supposedly targeting
        potential_targets = [c for c in player_tribe if c != subject_choice]
        print(f"\nWho do you want to claim {subject_choice.name} is targeting?")
        for i, contestant in enumerate(potential_targets, 1):
            print(f"{i}. {contestant.name}")
        print(f"{len(potential_targets) + 1}. Back to main menu")
        
        vote_target = None
        while vote_target is None:
            try:
                user_input = input("Enter your choice: ")
                if self.check_for_cheat_code(user_input):
                    continue
                choice = int(user_input)
                if 1 <= choice <= len(potential_targets):
                    vote_target = potential_targets[choice - 1]
                elif choice == len(potential_targets) + 1:
                    return  # Back to main menu
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Perform the bluff with d20 mechanics
        roll = random.randint(1, 20)
        social_bonus = self.player.social_skill
        alliance_bonus = 1 if self.player.believes_has_alliance_with(target, self) else 0
        relationship_bonus = 1 if self.player.get_relationship(target) >= 2 else 0
        
        # Apply reveal bonus if applicable
        reveal_bonus = 0
        if hasattr(self, 'reveal_bonuses') and (self.player, target) in self.reveal_bonuses:
            if self.reveal_bonuses[(self.player, target)] >= self.day:
                reveal_bonus = 1
        
        total_roll = roll + social_bonus + alliance_bonus + relationship_bonus + reveal_bonus
        outcome = self.get_roll_outcome(total_roll)
        
        # Narrate the bluff
        self.narration(f"You pull {target.name} aside for a private conversation.")
        if vote_target == target:
            self.contestant_speaks(self.player, f"I thought you should know... I heard {subject_choice.name} is planning to vote for you.")
        else:
            self.contestant_speaks(self.player, f"I thought you should know... I heard {subject_choice.name} is planning to vote for {vote_target.name}.")
        
        # Handle outcomes
        if outcome == "critical_failure":
            # Critical Failure: Pretend to believe but Busted lvl 3
            self.contestant_speaks(target, "That's really concerning. Thanks for letting me know.")
            self.narration(f"{target.name} seems to believe you, but something feels off about their reaction.")
            
            # Apply Busted lvl 3 (secretly)
            self.handle_busted(self.player, target, 3)
            
        elif outcome == "failure":
            # Failure: Call out as lying, Busted lvl 1
            self.contestant_speaks(target, "I find that hard to believe. Are you sure that's what you heard?")
            self.narration(f"{target.name} doesn't believe you and suspects you're lying.")
            
            # Apply Busted lvl 1
            self.handle_busted(self.player, target, 1)
            
        elif outcome == "neutral":
            # Neutral: Thank you, add to info bank
            self.contestant_speaks(target, "Thanks for the heads up. I'll keep that in mind.")
            self.narration(f"{target.name} believes your information.")
            
            # Add bluff information to target's info bank
            target.add_information('vote_target', subject_choice, vote_target)
            target.information_bank[-1]['day'] = self.day
                
        elif outcome == "success":
            # Success: Believe + pitch bonus for 2 days
            self.contestant_speaks(target, "I'm really glad you told me this. I owe you one.")
            self.narration(f"{target.name} is grateful for the information and trusts you more.")
            
            # Add bluff information to target's info bank
            target.add_information('vote_target', subject_choice, vote_target)
            target.information_bank[-1]['day'] = self.day
            
            # Add pitch bonus for 2 days
            if not hasattr(self, 'reveal_bonuses'):
                self.reveal_bonuses = {}
            self.reveal_bonuses[(self.player, target)] = self.day + 2
            
        else:  # critical_success
            # Critical Success: Believe + pitch bonus + remove from vote target/roster
            self.contestant_speaks(target, "Thank you so much for warning me. I really appreciate that you trust me.")
            self.narration(f"{target.name} is extremely grateful and your relationship has strengthened significantly.")
            
            # Add bluff information to target's info bank
            target.add_information('vote_target', subject_choice, vote_target)
            target.information_bank[-1]['day'] = self.day
            
            # Add pitch bonus for 2 days
            if not hasattr(self, 'reveal_bonuses'):
                self.reveal_bonuses = {}
            self.reveal_bonuses[(self.player, target)] = self.day + 2
            
            # Remove player from target's vote target and target roster
            if target.vote_target == self.player:
                self.assign_random_vote_target(target)
            target.target_roster = [c for c in target.target_roster if c != self.player]
        
        return True  # Action was taken
    
    def bluff_idol(self, target: Contestant) -> bool:
        """Bluff about someone having an idol.
        Returns True if action was taken, False if user backed out."""
        player_tribe = self.get_player_tribe()
        potential_subjects = [c for c in player_tribe if c != target]
        
        # Choose who supposedly has an idol
        print("\nWho do you want to claim has a hidden immunity idol?")
        for i, contestant in enumerate(potential_subjects, 1):
            print(f"{i}. {contestant.name}")
        print(f"{len(potential_subjects) + 1}. Back to main menu")
        
        subject_choice = None
        while subject_choice is None:
            try:
                user_input = input("Enter your choice: ")
                if self.check_for_cheat_code(user_input):
                    continue
                choice = int(user_input)
                if 1 <= choice <= len(potential_subjects):
                    subject_choice = potential_subjects[choice - 1]
                elif choice == len(potential_subjects) + 1:
                    return False  # Back to main menu - no action taken
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Perform the bluff with d20 mechanics
        roll = random.randint(1, 20)
        social_bonus = self.player.social_skill
        alliance_bonus = 1 if self.player.believes_has_alliance_with(target, self) else 0
        relationship_bonus = 1 if self.player.get_relationship(target) >= 2 else 0
        
        # Apply reveal bonus if applicable
        reveal_bonus = 0
        if hasattr(self, 'reveal_bonuses') and (self.player, target) in self.reveal_bonuses:
            if self.reveal_bonuses[(self.player, target)] >= self.day:
                reveal_bonus = 1
        
        total_roll = roll + social_bonus + alliance_bonus + relationship_bonus + reveal_bonus
        outcome = self.get_roll_outcome(total_roll)
        
        # Narrate the bluff
        self.narration(f"You pull {target.name} aside for a private conversation.")
        if subject_choice == self.player:
            self.contestant_speaks(self.player, f"Can I trust you with something? I found a hidden immunity idol.")
        else:
            self.contestant_speaks(self.player, f"I saw something interesting yesterday... I think {subject_choice.name} has a hidden immunity idol.")
        
        # Handle outcomes
        if outcome == "critical_failure":
            # Critical Failure: Pretend to believe but Busted lvl 3
            self.contestant_speaks(target, "Wow, that's huge information. Thanks for trusting me with this.")
            self.narration(f"{target.name} seems to believe you, but something feels off about their reaction.")
            
            # Apply Busted lvl 3 (secretly)
            self.handle_busted(self.player, target, 3)
            
        elif outcome == "failure":
            # Failure: Call out as lying, Busted lvl 1
            self.contestant_speaks(target, "Are you sure about that? That seems unlikely.")
            self.narration(f"{target.name} doesn't believe you and suspects you're lying.")
            
            # Apply Busted lvl 1
            self.handle_busted(self.player, target, 1)
            
        elif outcome == "neutral":
            # Neutral: Thank you, add to info bank
            self.contestant_speaks(target, "Thanks for letting me know. That's important information.")
            self.narration(f"{target.name} believes your information.")
            
            # Add bluff information to target's info bank
            target.add_information('has_idol', subject_choice)
            target.information_bank[-1]['day'] = self.day
                
        elif outcome == "success":
            # Success: Believe + pitch bonus for 2 days
            self.contestant_speaks(target, "I'm really glad you shared this with me. This changes everything.")
            self.narration(f"{target.name} is grateful for the information and trusts you more.")
            
            # Add bluff information to target's info bank
            target.add_information('has_idol', subject_choice)
            target.information_bank[-1]['day'] = self.day
            
            # Add pitch bonus for 2 days
            if not hasattr(self, 'reveal_bonuses'):
                self.reveal_bonuses = {}
            self.reveal_bonuses[(self.player, target)] = self.day + 2
            
        else:  # critical_success
            # Critical Success: Believe + pitch bonus + remove from vote target/roster
            self.contestant_speaks(target, "Thank you so much for telling me this. I really trust you.")
            self.narration(f"{target.name} is extremely grateful and your relationship has strengthened significantly.")
            
            # Add bluff information to target's info bank
            target.add_information('has_idol', subject_choice)
            target.information_bank[-1]['day'] = self.day
            
            # Add pitch bonus for 2 days
            if not hasattr(self, 'reveal_bonuses'):
                self.reveal_bonuses = {}
            self.reveal_bonuses[(self.player, target)] = self.day + 2
            
            # Remove player from target's vote target and target roster
            if target.vote_target == self.player:
                self.assign_random_vote_target(target)
            target.target_roster = [c for c in target.target_roster if c != self.player]
        
        return True  # Action was taken
    
    def bluff_alliance(self, target: Contestant) -> bool:
        """Bluff about two people being in an alliance.
        Returns True if action was taken, False if user backed out."""
        player_tribe = self.get_player_tribe()
        potential_subjects = [c for c in player_tribe if c != target]
        
        if len(potential_subjects) < 2:
            self.narration("There aren't enough people to make this bluff believable.")
            return True  # Action was attempted but failed
        
        # Choose first alliance member
        print("\nWho is the first person in this supposed alliance?")
        for i, contestant in enumerate(potential_subjects, 1):
            print(f"{i}. {contestant.name}")
        print(f"{len(potential_subjects) + 1}. Back to main menu")
        
        first_member = None
        while first_member is None:
            try:
                user_input = input("Enter your choice: ")
                if self.check_for_cheat_code(user_input):
                    continue
                choice = int(user_input)
                if 1 <= choice <= len(potential_subjects):
                    first_member = potential_subjects[choice - 1]
                elif choice == len(potential_subjects) + 1:
                    return  # Back to main menu
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Choose second alliance member
        remaining = [c for c in potential_subjects if c != first_member]
        print("\nWho is the second person in this supposed alliance?")
        for i, contestant in enumerate(remaining, 1):
            print(f"{i}. {contestant.name}")
        print(f"{len(remaining) + 1}. Back to main menu")
        
        second_member = None
        while second_member is None:
            try:
                user_input = input("Enter your choice: ")
                if self.check_for_cheat_code(user_input):
                    continue
                choice = int(user_input)
                if 1 <= choice <= len(remaining):
                    second_member = remaining[choice - 1]
                elif choice == len(remaining) + 1:
                    return  # Back to main menu
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Perform the bluff with d20 mechanics
        roll = random.randint(1, 20)
        social_bonus = self.player.social_skill
        alliance_bonus = 1 if self.player.believes_has_alliance_with(target, self) else 0
        relationship_bonus = 1 if self.player.get_relationship(target) >= 2 else 0
        
        # Apply reveal bonus if applicable
        reveal_bonus = 0
        if hasattr(self, 'reveal_bonuses') and (self.player, target) in self.reveal_bonuses:
            if self.reveal_bonuses[(self.player, target)] >= self.day:
                reveal_bonus = 1
        
        total_roll = roll + social_bonus + alliance_bonus + relationship_bonus + reveal_bonus
        outcome = self.get_roll_outcome(total_roll)
        
        # Narrate the bluff
        self.narration(f"You pull {target.name} aside for a private conversation.")
        self.contestant_speaks(self.player, f"Have you noticed how close {first_member.name} and {second_member.name} have been? They're definitely working together.")
        
        # Handle outcomes
        if outcome == "critical_failure":
            # Critical Failure: Pretend to believe but Busted lvl 3
            self.contestant_speaks(target, "That's really interesting. Thanks for pointing that out.")
            self.narration(f"{target.name} seems to believe you, but something feels off about their reaction.")
            
            # Apply Busted lvl 3 (secretly)
            self.handle_busted(self.player, target, 3)
            
        elif outcome == "failure":
            # Failure: Call out as lying, Busted lvl 1
            self.contestant_speaks(target, "I don't really see that. Are you sure they're working together?")
            self.narration(f"{target.name} doesn't believe you and suspects you're lying.")
            
            # Apply Busted lvl 1
            self.handle_busted(self.player, target, 1)
            
        elif outcome == "neutral":
            # Neutral: Thank you, add to info bank
            self.contestant_speaks(target, "That's good to know. I'll keep an eye on them.")
            self.narration(f"{target.name} believes your information.")
            
            # Add bluff information to target's info bank (alliance between two people)
            target.add_information('alliance', first_member, second_member)
            target.add_information('alliance', second_member, first_member)
            target.information_bank[-1]['day'] = self.day
            target.information_bank[-2]['day'] = self.day
                
        elif outcome == "success":
            # Success: Believe + pitch bonus for 2 days
            self.contestant_speaks(target, "I'm glad you told me this. I need to watch out for them.")
            self.narration(f"{target.name} is grateful for the information and trusts you more.")
            
            # Add bluff information to target's info bank (alliance between two people)
            target.add_information('alliance', first_member, second_member)
            target.add_information('alliance', second_member, first_member)
            target.information_bank[-1]['day'] = self.day
            target.information_bank[-2]['day'] = self.day
            
            # Add pitch bonus for 2 days
            if not hasattr(self, 'reveal_bonuses'):
                self.reveal_bonuses = {}
            self.reveal_bonuses[(self.player, target)] = self.day + 2
            
        else:  # critical_success
            # Critical Success: Believe + pitch bonus + remove from vote target/roster
            self.contestant_speaks(target, "Thank you so much for this warning. I really appreciate you looking out for me.")
            self.narration(f"{target.name} is extremely grateful and your relationship has strengthened significantly.")
            
            # Add bluff information to target's info bank (alliance between two people)
            target.add_information('alliance', first_member, second_member)
            target.add_information('alliance', second_member, first_member)
            target.information_bank[-1]['day'] = self.day
            target.information_bank[-2]['day'] = self.day
            
            # Add pitch bonus for 2 days
            if not hasattr(self, 'reveal_bonuses'):
                self.reveal_bonuses = {}
            self.reveal_bonuses[(self.player, target)] = self.day + 2
            
            # Remove player from target's vote target and target roster
            if target.vote_target == self.player:
                self.assign_random_vote_target(target)
            target.target_roster = [c for c in target.target_roster if c != self.player]
        
        return True  # Action was taken
    
    def probe_action(self) -> bool:
        """Handle the probe action - try to extract information from another contestant.
        Returns True if action was taken, False if user backed out."""
        player_tribe = self.get_player_tribe()
        potential_targets = [c for c in player_tribe if c != self.player and not c.eliminated]
        
        if not potential_targets:
            self.narration("There's no one available to probe for information.")
            return True  # Action was attempted but failed
        
        # Display potential targets
        print(f"\nWho would you like to probe for information?")
        for i, contestant in enumerate(potential_targets, 1):
            print(f"{i}. {contestant.name}")
        print(f"{len(potential_targets) + 1}. Back to talk menu")
        
        # Get target choice
        target_choice = None
        while target_choice is None:
            try:
                choice = int(input(f"Enter your choice (1-{len(potential_targets) + 1}): "))
                if choice == len(potential_targets) + 1:
                    return False  # Back to menu
                elif 1 <= choice <= len(potential_targets):
                    target_choice = potential_targets[choice - 1]
                else:
                    print(f"Invalid choice. Please enter 1-{len(potential_targets) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Choose probe type
        print(f"\nWhat type of information do you want to probe {target_choice.name} for?")
        print("1. General information")
        print("2. Who they're planning to vote for")
        print("3. Who they think is getting voted out next")
        print("4. Back to target selection")
        
        probe_type = None
        while probe_type is None:
            try:
                choice = int(input("Enter your choice (1-4): "))
                if choice == 1:
                    probe_type = "general"
                elif choice == 2:
                    probe_type = "vote_target"
                elif choice == 3:
                    probe_type = "consensus_vote"
                elif choice == 4:
                    return False  # Back to target selection
                else:
                    print("Invalid choice. Please enter 1-4.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Perform the probe with d20 mechanics
        roll = random.randint(1, 20)
        social_bonus = self.player.social_skill
        alliance_bonus = 1 if self.player.believes_has_alliance_with(target_choice, self) else 0
        relationship_bonus = 1 if self.player.get_relationship(target_choice) >= 2 else 0
        survival_modifier = self.player.get_survival_status_modifier("all")
        hero_bonus = 1 if self.player.hero_or_villain == "Hero" else 0
        
        total_roll = roll + social_bonus + alliance_bonus + relationship_bonus + survival_modifier + hero_bonus
        outcome = self.get_roll_outcome(total_roll)
        
        # Different approach and dialogue based on probe type
        if probe_type == "vote_target":
            self.narration(f"You approach {target_choice.name} with a serious expression.")
            self.contestant_speaks(self.player, "Hey, can I ask you something? Who are you planning to vote for?")
        elif probe_type == "consensus_vote":
            self.narration(f"You approach {target_choice.name} looking concerned.")
            self.contestant_speaks(self.player, "Do you have any idea who's getting voted out next? I'm trying to get a read on things.")
        else:  # general
            self.narration(f"You approach {target_choice.name} casually, hoping to extract some information.")
            self.contestant_speaks(self.player, "So... how are you feeling about the game so far? Anything interesting happening around camp?")
        
        # Handle outcomes
        if outcome == "critical_failure":
            # Critical Failure: Target bluffs with fake information + threat level increases
            self.contestant_speaks(target_choice, "Well, since you asked... I heard some interesting things.")
            
            # Target provides fake information (similar to bluff mechanics)
            fake_info_provided = self.generate_fake_information_for_probe(target_choice)
            if fake_info_provided:
                self.contestant_speaks(target_choice, fake_info_provided)
                self.narration(f"{target_choice.name} seems genuine, but something feels off about what they said.")
            else:
                # Create a generic suspicious response instead of backing down
                self.contestant_speaks(target_choice, "I'm not sure I should be talking about this. Things are getting complicated.")
            
            # Increase player's threat level
            self.player.threat_level = min(10, self.player.threat_level + 1)
            self.narration(f"Your probing was too obvious. {target_choice.name} is suspicious of your motives.")
            
        elif outcome == "failure":
            # Failure: Target is evasive based on probe type
            if probe_type == "vote_target":
                responses = [
                    "I'm still thinking about it. There are a few people I'm considering.",
                    "It's hard to say right now. I want to see how things play out.",
                    "I haven't made up my mind yet. What about you?",
                    "I'm keeping my options open for now."
                ]
            elif probe_type == "consensus_vote":
                responses = [
                    "It's hard to tell. Everyone's being pretty tight-lipped.",
                    "I think there are a few names being thrown around, but nothing concrete.",
                    "Your guess is as good as mine. The tribe's pretty divided.",
                    "I'm not sure. What are you hearing?"
                ]
            else:  # general
                responses = [
                    "I don't really pay attention to camp drama. I'm just focused on challenges.",
                    "Nothing much happening. Just trying to survive out here.",
                    "I prefer to keep to myself. Less drama that way.",
                    "Why are you asking? Seems like you're fishing for information."
                ]
            self.contestant_speaks(target_choice, random.choice(responses))
            self.narration(f"{target_choice.name} doesn't seem willing to share any information.")
            
        elif outcome == "neutral":
            # Neutral: Give information player already has
            existing_info = self.get_existing_information_for_probe(target_choice)
            if existing_info:
                self.contestant_speaks(target_choice, existing_info)
                self.narration(f"{target_choice.name} shares something, but it's information you already knew.")
            else:
                self.contestant_speaks(target_choice, "Well, the same old camp stuff, you know? Not much changes out here.")
                self.narration(f"{target_choice.name} doesn't provide anything useful.")
                
        elif outcome == "success":
            # Success: Target answers honestly based on probe type
            if probe_type == "vote_target":
                if target_choice.vote_target:
                    self.contestant_speaks(target_choice, f"I'm planning to vote for {target_choice.vote_target.name}.")
                    self.add_player_information('vote_target', target_choice, target_choice.vote_target)
                    self.narration(f"{target_choice.name} honestly reveals their vote target.")
                else:
                    self.contestant_speaks(target_choice, "Honestly, I haven't decided who to vote for yet.")
                    self.narration(f"{target_choice.name} admits they haven't decided on a vote target.")
            elif probe_type == "consensus_vote":
                # Check if target knows consensus vote
                consensus_info = [info for info in target_choice.information_bank if info['type'] == 'consensus_vote']
                if consensus_info:
                    latest_consensus = consensus_info[-1]
                    if 'targets' in latest_consensus and latest_consensus['targets']:
                        if len(latest_consensus['targets']) == 1:
                            consensus_target = latest_consensus['targets'][0]
                            if consensus_target == target_choice:
                                self.contestant_speaks(target_choice, f"From what I can tell, you're getting voted out next.")
                            else:
                                self.contestant_speaks(target_choice, f"From what I can tell, {consensus_target.name} is getting voted out next.")
                            consensus_info_copy = {
                                'type': 'consensus_vote',
                                'targets': latest_consensus['targets'],
                                'day': self.day
                            }
                            self.player.information_bank.append(consensus_info_copy)
                            self.narration(f"{target_choice.name} shares what they know about the consensus vote.")
                        else:
                            target_names = [t.name for t in latest_consensus['targets']]
                            self.contestant_speaks(target_choice, f"It looks like {' and '.join(target_names)} are tied for getting voted out next.")
                            consensus_info_copy = {
                                'type': 'consensus_vote',
                                'targets': latest_consensus['targets'],
                                'day': self.day
                            }
                            self.player.information_bank.append(consensus_info_copy)
                            self.narration(f"{target_choice.name} shares what they know about the consensus vote.")
                    else:
                        self.contestant_speaks(target_choice, "I'm not really sure. I haven't been able to get a clear read on the vote.")
                        self.narration(f"{target_choice.name} honestly admits they don't know the consensus.")
                else:
                    self.contestant_speaks(target_choice, "I honestly don't know. Everyone's being pretty secretive about their votes.")
                    self.narration(f"{target_choice.name} honestly admits they don't know the consensus.")
            else:  # general
                # Success: Give new information player doesn't have
                new_info = self.get_new_information_for_probe(target_choice)
                if new_info:
                    self.contestant_speaks(target_choice, new_info['text'])
                    # Add the information to player's info bank
                    self.player.add_information(new_info['type'], new_info.get('subject'), new_info.get('target'))
                    if self.player.information_bank:
                        self.player.information_bank[-1]['day'] = self.day
                    self.narration(f"{target_choice.name} shares valuable information you didn't know before.")
                else:
                    # Fallback if no new info available
                    self.contestant_speaks(target_choice, "Well, I've been keeping my eyes open, but haven't noticed anything major.")
                    self.narration(f"{target_choice.name} tries to be helpful but doesn't have much to share.")
                
        else:  # critical_success
            # Critical Success: Give best information + reduce threat level
            if probe_type == "vote_target":
                # Share their vote target AND any additional vote information they know
                if target_choice.vote_target:
                    self.contestant_speaks(target_choice, f"I'm planning to vote for {target_choice.vote_target.name}.")
                    self.add_player_information('vote_target', target_choice, target_choice.vote_target)
                    self.narration(f"{target_choice.name} honestly reveals their vote target.")
                else:
                    self.contestant_speaks(target_choice, "Honestly, I haven't decided who to vote for yet.")
                    self.narration(f"{target_choice.name} admits they haven't decided on a vote target.")
                    
                # Also share additional vote information they might know
                new_info = self.get_new_information_for_probe(target_choice)
                if new_info and new_info['type'] == 'vote_target':
                    self.contestant_speaks(target_choice, f"And just between us, {new_info['text']}")
                    self.player.add_information(new_info['type'], new_info.get('subject'), new_info.get('target'))
                    if self.player.information_bank:
                        self.player.information_bank[-1]['day'] = self.day
                        
            elif probe_type == "consensus_vote":
                # Share consensus knowledge AND any related vote information
                consensus_info = [info for info in target_choice.information_bank if info['type'] == 'consensus_vote']
                if consensus_info:
                    latest_consensus = consensus_info[-1]
                    if 'targets' in latest_consensus and latest_consensus['targets']:
                        if len(latest_consensus['targets']) == 1:
                            consensus_target = latest_consensus['targets'][0]
                            if consensus_target == target_choice:
                                self.contestant_speaks(target_choice, f"From what I can tell, you're getting voted out next. I really trust you, so I'm sharing everything I know.")
                            else:
                                self.contestant_speaks(target_choice, f"From what I can tell, {consensus_target.name} is getting voted out next. I really trust you, so I'm sharing everything I know.")
                        else:
                            target_names = [t.name for t in latest_consensus['targets']]
                            self.contestant_speaks(target_choice, f"It looks like {' and '.join(target_names)} are tied for getting voted out next. I really trust you, so I'm sharing everything I know.")
                        
                        consensus_info_copy = {
                            'type': 'consensus_vote',
                            'targets': latest_consensus['targets'],
                            'day': self.day
                        }
                        self.player.information_bank.append(consensus_info_copy)
                        self.narration(f"{target_choice.name} shares detailed consensus information.")
                    else:
                        self.contestant_speaks(target_choice, "I'm not really sure, but I trust you completely. If I learn anything, you'll be the first to know.")
                        self.narration(f"{target_choice.name} doesn't know the consensus but clearly trusts you.")
                else:
                    self.contestant_speaks(target_choice, "I honestly don't know, but I really trust you. If I hear anything, you'll be the first to know.")
                    self.narration(f"{target_choice.name} doesn't know the consensus but clearly trusts you.")
                    
            else:  # general
                # Critical Success: Give new information + reduce threat level
                new_info = self.get_new_information_for_probe(target_choice)
                if new_info:
                    self.contestant_speaks(target_choice, new_info['text'])
                    # Add the information to player's info bank
                    self.player.add_information(new_info['type'], new_info.get('subject'), new_info.get('target'))
                    if self.player.information_bank:
                        self.player.information_bank[-1]['day'] = self.day
                    self.narration(f"{target_choice.name} really trusts you and shares valuable information.")
                else:
                    self.contestant_speaks(target_choice, "You know, I really trust you. If I hear anything important, you'll be the first to know.")
                    self.narration(f"{target_choice.name} doesn't have new information but clearly trusts you.")
                
            # No longer reduce threat level for successful probe actions
        
        return True  # Action was taken
    
    def generate_fake_information_for_probe(self, target: Contestant) -> str:
        """Generate fake information that target provides when player's probe critically fails."""
        player_tribe = self.get_player_tribe()
        available_contestants = [c for c in player_tribe if c != target and c != self.player and not c.eliminated]
        
        if not available_contestants:
            return None
            
        # Generate different types of fake information
        fake_types = ['vote_target', 'alliance', 'idol_claim']
        fake_type = random.choice(fake_types)
        
        if fake_type == 'vote_target':
            fake_target = random.choice(available_contestants)
            fake_subject = random.choice([c for c in available_contestants if c != fake_target])
            # Add false information to player's info bank
            self.player.add_information('vote_target', fake_subject, fake_target)
            if self.player.information_bank:
                self.player.information_bank[-1]['day'] = self.day
            return f"I overheard {fake_subject.name} saying {fake_subject.get_pronoun('subject')} wants to vote for {fake_target.name}."
            
        elif fake_type == 'alliance':
            if len(available_contestants) >= 2:
                fake_allies = random.sample(available_contestants, 2)
                # Add false alliance information
                self.player.add_information('alliance', fake_allies[0], fake_allies[1])
                if self.player.information_bank:
                    self.player.information_bank[-1]['day'] = self.day
                return f"I think {fake_allies[0].name} and {fake_allies[1].name} are secretly working together."
            else:
                return None
                
        elif fake_type == 'idol_claim':
            fake_subject = random.choice(available_contestants)
            # Add false idol information
            self.player.add_information('has_idol', fake_subject)
            if self.player.information_bank:
                self.player.information_bank[-1]['day'] = self.day
            return f"I'm pretty sure {fake_subject.name} found the hidden immunity idol."
            
        return None
    
    def get_existing_information_for_probe(self, target: Contestant) -> str:
        """Get information the player already has, formatted for probe response."""
        if not self.player.information_bank:
            return None
            
        # Get random existing information
        existing_info = random.choice(self.player.information_bank)
        
        # Format it as if target is sharing it
        if existing_info['type'] == 'vote_target':
            if existing_info.get('subject') != target and existing_info.get('target'):
                if existing_info['target'] == self.player:
                    return f"I heard {existing_info.get('subject').name} is planning to vote for you."
                else:
                    return f"I heard {existing_info.get('subject').name} is planning to vote for {existing_info['target'].name}."
            elif existing_info.get('target'):
                return f"I'm thinking about voting for {existing_info['target'].name}."
                
        elif existing_info['type'] == 'alliance':
            if existing_info.get('subject') != target and existing_info.get('target') != target and existing_info.get('target'):
                # Don't share information about player to player
                if existing_info.get('subject') == self.player or existing_info['target'] == self.player:
                    return None
                return f"I think {existing_info.get('subject').name} and {existing_info['target'].name} might be working together."
            else:
                return None  # Don't reveal target's own alliances
                
        elif existing_info['type'] == 'has_idol':
            if existing_info.get('subject') != target and existing_info.get('subject') != self.player:
                return f"Between you and me, I think {existing_info.get('subject').name} might have an idol."
            else:
                return None
        
        elif existing_info['type'] == 'final_2':
            if existing_info.get('subject') != target and existing_info.get('target') != target and existing_info.get('target'):
                return f"I know {existing_info.get('subject').name} and {existing_info['target'].name} have a final 2 deal."
            else:
                return None  # Don't reveal target's own final 2 deals
                
        elif existing_info['type'] == 'final_2_pitch':
            if existing_info.get('subject') != target and existing_info.get('target') != target and existing_info.get('target'):
                return f"I heard {existing_info.get('subject').name} pitched a final 2 deal to {existing_info['target'].name}."
            else:
                return None
                
        elif existing_info['type'] == 'has_final_2':
            if existing_info.get('subject') != target and existing_info.get('subject') != self.player:
                return f"I think {existing_info.get('subject').name} has a final 2 deal with someone."
            else:
                return None
                
        return None
    
    def get_new_information_for_probe(self, target: Contestant) -> dict:
        """Get new information the player doesn't have, from target's knowledge."""
        # Get information from target's information bank that player doesn't have
        for info in target.information_bank:
            # Check if player already has this information
            player_has_info = False
            for player_info in self.player.information_bank:
                if (player_info['type'] == info['type'] and 
                    player_info.get('subject') == info.get('subject') and
                    player_info.get('target') == info.get('target')):
                    player_has_info = True
                    break
                    
            if not player_has_info:
                # Format the information for sharing
                if info['type'] == 'vote_target':
                    if info.get('subject') != target and info.get('target'):  # Don't reveal target's own vote plans
                        # Don't share information about player's own vote plans
                        if info.get('subject') == self.player:
                            continue
                        # Use "you" if target is the player
                        target_name = "you" if info['target'] == self.player else info['target'].name
                        return {
                            'type': 'vote_target',
                            'subject': info.get('subject'),
                            'target': info['target'],
                            'text': f"I overheard {info.get('subject').name} saying {info.get('subject').get_pronoun('subject')} wants to vote for {target_name}."
                        }
                elif info['type'] == 'alliance':
                    if info.get('subject') != target and info.get('target') != target and info.get('target'):  # Don't reveal target's alliances
                        # Don't share information about player to player
                        if info.get('subject') == self.player or info['target'] == self.player:
                            continue
                        return {
                            'type': 'alliance',
                            'subject': info.get('subject'),
                            'target': info.get('target'),
                            'text': f"I think {info.get('subject').name} and {info['target'].name} are working together."
                        }
                elif info['type'] == 'has_idol':
                    if info.get('subject') != target and info.get('subject') != self.player:
                        return {
                            'type': 'has_idol',
                            'subject': info.get('subject'),
                            'text': f"Just so you know, I'm pretty sure {info.get('subject').name} has an idol."
                        }
                elif info['type'] == 'final_2':
                    if info.get('subject') != target and info.get('target') != target and info.get('target'):  # Don't reveal target's final 2 deals
                        # Don't share information about player's final 2 deals to player
                        if info.get('subject') == self.player or info['target'] == self.player:
                            continue
                        return {
                            'type': 'final_2',
                            'subject': info.get('subject'),
                            'target': info.get('target'),
                            'text': f"I know that {info.get('subject').name} and {info['target'].name} have a final 2 deal."
                        }
                elif info['type'] == 'final_2_pitch':
                    if info.get('subject') != target and info.get('target') != target and info.get('target'):  # Don't reveal target's own pitches
                        # Don't share information about player's pitches to player
                        if info.get('subject') == self.player:
                            continue
                        # Use "you" if target is the player
                        target_name = "you" if info['target'] == self.player else info['target'].name
                        return {
                            'type': 'final_2_pitch',
                            'subject': info.get('subject'),
                            'target': info.get('target'),
                            'text': f"I heard that {info.get('subject').name} pitched a final 2 deal to {target_name}."
                        }
                elif info['type'] == 'has_final_2':
                    if info.get('subject') != target and info.get('subject') != self.player:
                        return {
                            'type': 'has_final_2',
                            'subject': info.get('subject'),
                            'text': f"I think {info.get('subject').name} has a final 2 deal with someone."
                        }
                        
        return None
    
    def small_talk_action(self) -> bool:
        """Handle the small talk action - choose who to have small talk with.
        Returns True if action was taken, False if user backed out."""
        player_tribe = self.get_player_tribe()
        potential_targets = [c for c in player_tribe if c != self.player]
        
        if not potential_targets:
            self.narration("There's no one in your tribe to talk with.")
            return True  # Action was attempted but failed
        
        # Choose who to talk to
        target_choice = None
        while target_choice is None:
            print("\nWho would you like to have small talk with?")
            for i, contestant in enumerate(potential_targets, 1):
                alliance_status = " (Ally)" if self.player.believes_has_alliance_with(contestant, self) else ""
                print(f"{i}. {contestant.name}{alliance_status}")
            print(f"{len(potential_targets) + 1}. Back to main menu")
            
            try:
                user_input = input("Enter your choice: ")
                if self.check_for_cheat_code(user_input):
                    continue  # Ask again after cheat menu
                choice = int(user_input)
                if 1 <= choice <= len(potential_targets):
                    target_choice = potential_targets[choice - 1]
                elif choice == len(potential_targets) + 1:
                    return False  # Back to main menu - no action taken
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        self.small_talk_with(target_choice)
        return True  # Action was taken
    
    def pitch_action(self) -> bool:
        """Handle the pitch action - choose between pitching alliance or vote target.
        Returns True if action was taken, False if user backed out."""
        
        # Check if Final 2 Deal option should be shown
        player_tribe = self.get_player_tribe()
        can_pitch_final_2 = any(c for c in player_tribe 
            if c != self.player 
            and self.player.believes_has_alliance_with(c, self)
            and self.player.get_relationship(c) >= 2
            and not self.player.believes_has_final_2_with(c)
            and not c.eliminated)
        
        pitch_type = None
        while pitch_type is None:
            print("\nWhat would you like to pitch?")
            print("1. Pitch an Alliance")
            print("2. Pitch a Vote Target")
            if can_pitch_final_2:
                print("3. Pitch a Final 2 Deal")
                print("4. Back to main menu")
                max_choice = 4
            else:
                print("3. Back to main menu")
                max_choice = 3
            
            try:
                user_input = input(f"Enter your choice (1-{max_choice}): ")
                if self.check_for_cheat_code(user_input):
                    continue  # Ask again after cheat menu
                choice = int(user_input)
                
                if choice == 1:
                    if self.pitch_alliance_action():
                        pitch_type = "alliance"
                    else:
                        return False  # User backed out of submenu
                elif choice == 2:
                    if self.pitch_vote_action():
                        pitch_type = "vote"
                    else:
                        return False  # User backed out of submenu
                elif choice == 3 and can_pitch_final_2:
                    if self.pitch_final_2_action():
                        pitch_type = "final_2"
                    else:
                        return False  # User backed out of submenu
                elif choice == max_choice:
                    return False  # Back to main menu
                else:
                    print(f"Invalid choice. Please enter 1-{max_choice}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        return True  # Action was taken
    
    def pitch_alliance_action(self) -> bool:
        """Handle pitching an alliance - choose who to form an alliance with.
        Returns True if action was taken, False if user backed out."""
        player_tribe = self.get_player_tribe()
        
        # Get contestants who have pending requests on the current day
        pending_today = []
        if hasattr(self, 'pending_alliance_requests'):
            pending_today = [c for c, day in self.pending_alliance_requests if day == self.day]
        
        # Exclude allies already formed and those with pending requests today
        eligible_allies = [c for c in player_tribe 
                          if c != self.player 
                          and not self.player.believes_has_alliance_with(c, self)
                          and not self.player.has_real_group_alliance_with(c, self)
                          and c not in pending_today]
        
        if not eligible_allies:
            # Check if there are people with pending requests today
            if pending_today:
                self.narration("Everyone available either already has an alliance with you or asked for time to think about it today.")
            else:
                self.narration("There's no one left in your tribe to form an alliance with.")
            return False  # No action was taken - return to menu
        
        # Choose who to pitch alliance to
        target_choice = None
        while target_choice is None:
            print("\nWho would you like to pitch an alliance to?")
            for i, contestant in enumerate(eligible_allies, 1):
                # Show if they have a previous pending request
                pending_status = ""
                if hasattr(self, 'pending_alliance_requests'):
                    pending_req = next((req for req in self.pending_alliance_requests if req[0] == contestant), None)
                    if pending_req and pending_req[1] < self.day:
                        pending_status = " (Previously asked for time)"
                print(f"{i}. {contestant.name}{pending_status}")
            print(f"{len(eligible_allies) + 1}. Back to main menu")
            
            try:
                user_input = input("Enter your choice: ")
                if self.check_for_cheat_code(user_input):
                    continue  # Ask again after cheat menu
                choice = int(user_input)
                if 1 <= choice <= len(eligible_allies):
                    target_choice = eligible_allies[choice - 1]
                elif choice == len(eligible_allies) + 1:
                    return False  # Back to main menu - no action taken
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        self.build_alliance_with(target_choice)
        return True  # Action was taken
    
    def pitch_vote_action(self) -> bool:
        """Handle pitching a vote - choose who to talk to and who to target.
        Returns True if action was taken, False if user backed out."""
        player_tribe = self.get_player_tribe()
        potential_allies = [c for c in player_tribe if c != self.player]
        
        if not potential_allies:
            self.narration("There's no one in your tribe to pitch a vote to.")
            return True  # Action was attempted but failed
        
        # Choose who to pitch to
        ally_choice = None
        while ally_choice is None:
            print("\nWho would you like to pitch a vote to?")
            for i, contestant in enumerate(potential_allies, 1):
                alliance_status = " (Ally)" if self.player.believes_has_alliance_with(contestant, self) else ""
                print(f"{i}. {contestant.name}{alliance_status}")
            print(f"{len(potential_allies) + 1}. Back to main menu")
            
            try:
                user_input = input("Enter your choice: ")
                if self.check_for_cheat_code(user_input):
                    continue  # Ask again after cheat menu
                choice = int(user_input)
                if 1 <= choice <= len(potential_allies):
                    ally_choice = potential_allies[choice - 1]
                elif choice == len(potential_allies) + 1:
                    return False  # Back to main menu - no action taken
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        if self.pitch_vote_with(ally_choice):
            return True  # Action was taken
        else:
            return False  # User backed out of submenu

    def pitch_final_2_action(self) -> bool:
        """Handle pitching a final 2 deal - choose who to make the deal with.
        Returns True if action was taken, False if user backed out."""
        # Check if player already has a final 2 deal
        # Check if player has any Final 2 deals (real or fake)
        current_deals = []
        if self.player.final_2_deal:
            current_deals.append(self.player.final_2_deal.name)
        for fake_deal in self.player.fake_final_2_deals:
            current_deals.append(fake_deal.name)
            
        if current_deals:
            # Ask for confirmation to pitch multiple final 2 deals
            if len(current_deals) == 1:
                print(f"\nYou already have a final 2 deal with {current_deals[0]}.")
            else:
                deals_list = ", ".join(current_deals[:-1]) + f" and {current_deals[-1]}"
                print(f"\nYou already have final 2 deals with {deals_list}.")
            print("Are you sure you want to pitch another final 2 deal?")
            print("1. Yes")
            print("2. No")
            
            while True:
                try:
                    user_input = input("Enter your choice (1-2): ")
                    if self.check_for_cheat_code(user_input):
                        continue  # Ask again after cheat menu
                    choice = int(user_input)
                    if choice == 1:
                        break  # Continue with pitching
                    elif choice == 2:
                        return False  # Go back to main menu
                    else:
                        print("Invalid choice. Please enter 1 or 2.")
                except ValueError:
                    print("Invalid input. Please enter a number.")
        
        player_tribe = self.get_player_tribe()
        
        # Can only pitch to allies with relationship 2 or higher
        eligible_targets = [c for c in player_tribe 
                           if c != self.player 
                           and self.player.believes_has_alliance_with(c, self)
                           and self.player.get_relationship(c) >= 2
                           and not self.player.believes_has_final_2_with(c)
                           and not c.eliminated]
        
        if not eligible_targets:
            self.narration("You need to have an alliance with someone and a relationship of 2 or higher before you can pitch a final 2 deal.")
            return False  # No action taken
        
        # Choose who to pitch final 2 to
        target_choice = None
        while target_choice is None:
            print("\nWho would you like to pitch a final 2 deal to?")
            print("(You can only pitch to current allies)")
            for i, contestant in enumerate(eligible_targets, 1):
                # No status needed since we filter out existing deals
                print(f"{i}. {contestant.name}")
            print(f"{len(eligible_targets) + 1}. Back to main menu")
            
            try:
                user_input = input("Enter your choice: ")
                if self.check_for_cheat_code(user_input):
                    continue  # Ask again after cheat menu
                choice = int(user_input)
                if 1 <= choice <= len(eligible_targets):
                    target_choice = eligible_targets[choice - 1]
                elif choice == len(eligible_targets) + 1:
                    return False  # Back to main menu - no action taken
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Check if already pitched to this person
        if target_choice in self.player.fake_final_2_deals:
            self.narration(f"You've already pitched a final 2 deal to {target_choice.name}.")
            return False  # No action taken
        
        self.pitch_final_2_with(target_choice)
        return True  # Action was taken

    def is_tribal_council_day(self) -> bool:
        """Check if the player's tribe is going to tribal council today."""
        # This will be set by the immunity challenge handler
        return getattr(self, 'player_tribe_has_tribal', False)

    def handle_immediate_confrontation(self, npc: Contestant, other_contestant: Contestant = None) -> None:
        """Handle an immediate Final 2 betrayal confrontation right after discovery.
        
        Args:
            npc: The NPC doing the confronting
            other_contestant: The specific contestant they learned about having a Final 2 deal with player
        """
        # Skip if NPC is eliminated
        if npc.eliminated:
            self.npcs_needing_betrayal_confrontation.remove(npc)
            return
        
        # Skip if NPC is not in same location as player (pre-merge)
        if not self.merged and npc.tribe != self.player.tribe:
            return  # Leave them in the list for later
        
        # Handle the confrontation immediately
        print("\n" + "="*80)
        self.narration(f"{npc.name} immediately approaches you with an angry expression.")
        self.npc_confront_player_about_final_2_betrayal(npc, other_contestant)
        
        # Remove from the pending list since we just handled it
        if npc in self.npcs_needing_betrayal_confrontation:
            self.npcs_needing_betrayal_confrontation.remove(npc)
        
        print("="*80)
        input("\nPress Enter to continue...")
    
    def player_actions(self) -> None:
        """Allow player to perform daily actions."""
        
        # If player is a jury spectator, provide spectator mode instead
        if self.player_is_jury_spectator:
            self.jury_spectator_actions()
            return
        
        # Reset daily action tracking
        self.actions_taken_today = 0
        first_action_taken = False
        
        while self.actions_taken_today < self.max_actions_per_day:
            print("\nWhat would you like to do?")
            print("1. Perform Action")
            print("2. Check Info")
            print("3. Assign Vote Target")
            print("4. Skip Turn")
            
            try:
                user_input = input("Enter your choice (1-4): ")
                if self.check_for_cheat_code(user_input):
                    continue  # Go back to the menu after cheat code
                choice = int(user_input)
                
                if choice == 1:
                    # Show action menu
                    actions_remaining = self.max_actions_per_day - self.actions_taken_today
                    print(f"\nYou have {actions_remaining} actions remaining for day {self.day}.")
                    print("What action would you like to take?")
                    print("1. Talk")
                    print("2. Search for Hidden Immunity Idol")
                    print("3. Work Around Camp")
                    print("4. Focus on Survival")
                    if first_action_taken:  # Snoop available after first action
                        print("5. Snoop")
                        print("6. Back to main menu")
                        max_choice = 6
                    else:
                        print("5. Back to main menu")
                        max_choice = 5
                    
                    action_input = input(f"Enter your choice (1-{max_choice}): ")
                    if self.check_for_cheat_code(action_input):
                        continue  # Go back to the main menu after cheat code
                    
                    try:
                        action_choice = int(action_input)
                        if action_choice == 1:
                            if self.talk_action():  # Only increment if action was taken
                                self.actions_taken_today += 1
                                # Trigger NPC actions at appropriate times
                                self.trigger_npc_actions_if_needed(first_action_taken)
                                if not first_action_taken:
                                    first_action_taken = True
                        elif action_choice == 2:
                            self.search_for_idol()
                            self.actions_taken_today += 1
                            # Trigger NPC actions at appropriate times
                            self.trigger_npc_actions_if_needed(first_action_taken)
                            if not first_action_taken:
                                first_action_taken = True
                        elif action_choice == 3:
                            self.work_around_camp()
                            self.actions_taken_today += 1
                            # Trigger NPC actions at appropriate times
                            self.trigger_npc_actions_if_needed(first_action_taken)
                            if not first_action_taken:
                                first_action_taken = True
                        elif action_choice == 4:
                            self.focus_on_survival()
                            self.actions_taken_today += 1
                            # Trigger NPC actions at appropriate times
                            self.trigger_npc_actions_if_needed(first_action_taken)
                            if not first_action_taken:
                                first_action_taken = True
                        elif action_choice == 5 and first_action_taken:
                            # Snoop action (available after first action)
                            if self.snoop_action():
                                self.actions_taken_today += 1
                        elif action_choice == max_choice:
                            continue  # Go back to main menu
                        else:
                            print(f"Invalid choice. Please enter a number between 1 and {max_choice}.")
                    except ValueError:
                        print("Invalid input. Please enter a number.")
                        
                elif choice == 2:
                    self.check_info()
                elif choice == 3:
                    self.assign_vote_target()
                elif choice == 4:
                    # Skip Turn - use just one action
                    print(f"\nSkipping this turn...")
                    self.actions_taken_today += 1
                    # Trigger NPC actions at appropriate times
                    self.trigger_npc_actions_if_needed(first_action_taken)
                    if not first_action_taken:
                        first_action_taken = True
                else:
                    print("Invalid choice. Please enter 1, 2, 3, or 4.")
                    
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Complete any remaining NPC actions before showing end-of-day menu
        self.complete_remaining_npc_actions()
        
        # After all actions are used, allow non-action activities
        while True:
            print(f"\nYou've used all your actions for day {self.day}.")
            print("What would you like to do?")
            print("1. Check Info")
            print("2. Assign Vote Target")
            
            # Check if tribal council is happening today
            is_tribal_day = self.is_tribal_council_day()
            if is_tribal_day:
                print("3. Continue to Tribal Council")
            else:
                print("3. Continue to next day")
            
            try:
                user_input = input("Enter your choice (1-3): ")
                if self.check_for_cheat_code(user_input):
                    continue  # Go back to the menu after cheat code
                choice = int(user_input)
                
                if choice == 1:
                    self.check_info()
                elif choice == 2:
                    self.assign_vote_target()
                elif choice == 3:
                    break  # Exit and continue to next day/tribal
                else:
                    print("Invalid choice. Please enter 1, 2, or 3.")
                    
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    def trigger_npc_actions_if_needed(self, first_action_taken: bool) -> None:
        """Trigger NPC actions at the appropriate times based on player action count."""
        if self.actions_taken_today == 1 and not first_action_taken:
            # After player's first action - NPC action round 1
            self.perform_npc_actions(action_round=1)
        elif self.actions_taken_today == 2:
            # After player's second action - NPC action round 2
            self.perform_npc_actions(action_round=2)
    
    def trigger_npc_actions_after_push_harder(self) -> None:
        """Trigger NPC actions immediately after a Push Harder attempt."""
        if self.actions_taken_today == 2:
            # Push Harder used on second action - trigger first NPC action round
            if self.npc_action_round == 0:
                self.perform_npc_actions(action_round=1)
        elif self.actions_taken_today == 3:
            # Push Harder used on third action - trigger second NPC action round
            if self.npc_action_round == 1:
                self.perform_npc_actions(action_round=2)
    
    def complete_remaining_npc_actions(self) -> None:
        """Complete any remaining NPC actions at the end of the day."""
        while self.npc_action_round < self.max_npc_actions_per_day:
            next_round = self.npc_action_round + 1
            self.perform_npc_actions(action_round=next_round)
    
    def perform_npc_actions(self, action_round: int = None) -> None:
        """Have all NPCs perform one of their daily actions.
        action_round: 1 for first action, 2 for second action. If None, uses next available round."""
        
        # Determine which action round this is
        if action_round is None:
            self.npc_action_round += 1
            current_round = self.npc_action_round
        else:
            current_round = action_round
            # Update the game's round tracker if this is sequential
            if current_round == self.npc_action_round + 1:
                self.npc_action_round = current_round
            
        # Don't exceed max actions per day
        if current_round > self.max_npc_actions_per_day:
            return
            
        
        # Get all active NPCs in the player's tribe
        player_tribe = self.get_player_tribe()
        npcs = [c for c in player_tribe if not c.is_player and not c.eliminated]
        
        for npc in npcs:
            # Check if NPC has reached their action limit for the day
            if npc.npc_actions_taken_today >= self.max_npc_actions_per_day:
                continue
                
            # Skip NPCs who have already performed a controlled action today (only skip if they've maxed out)
            if (hasattr(self, 'npcs_who_performed_controlled_actions') and 
                npc in self.npcs_who_performed_controlled_actions and 
                npc.npc_actions_taken_today >= self.max_npc_actions_per_day):
                continue
            
            # Skip NPCs who should skip today's action due to controlled action from previous day
            if hasattr(self, 'npcs_who_skip_next_day_action') and npc in self.npcs_who_skip_next_day_action:
                continue
            
            # Check if this NPC has a queued controlled action
            if hasattr(self, 'queued_controlled_actions') and npc in self.queued_controlled_actions:
                controlled_data = self.queued_controlled_actions[npc]
                controlled_action = controlled_data['action']
                action_params = controlled_data['params']
                
                try:
                    self.execute_controlled_action_with_params(npc, controlled_action, action_params)
                    # Increment NPC's action count for controlled action
                    npc.npc_actions_taken_today += 1
                    # Remove from queue after execution
                    del self.queued_controlled_actions[npc]
                    continue  # Skip regular action for this NPC
                except Exception as e:
                    print(f"Error executing controlled action for {npc.name}: {e}")
                    # Remove from queue even if it failed
                    del self.queued_controlled_actions[npc]
                    # Fall through to regular action
                
            try:
                # Get the action hat for this NPC and draw an action
                action_hat = self.get_npc_action_hat(npc)
                if not action_hat:
                    # Fallback to small talk if action hat is empty
                    self.npc_small_talk(npc)
                    continue
                selected_action = random.choice(action_hat)
                
                # Execute the selected action
                if selected_action == "Small Talk":
                    self.npc_small_talk(npc)
                elif selected_action == "Pitch Alliance":
                    self.npc_pitch_alliance(npc)
                elif selected_action == "Pitch Group Alliance":
                    self.npc_pitch_group_alliance(npc)
                elif selected_action == "Pitch Vote Target":
                    self.npc_pitch_vote_target(npc)
                elif selected_action == "Pitch Vote to Group":
                    self.npc_pitch_vote_to_group(npc)
                elif selected_action == "Pitch Final 2 Deal":
                    self.npc_pitch_final_2(npc)
                elif selected_action == "General Bluff":
                    self.npc_bluff(npc)  # Use existing general bluff logic
                elif selected_action == "Bluff Someone is Targeting You":
                    self.npc_bluff(npc, bluff_type="targeting_you")
                elif selected_action == "Bluff Someone is Consensus Vote":
                    self.npc_bluff(npc, bluff_type="consensus_vote")
                elif selected_action == "Bluff":  # Backward compatibility
                    self.npc_bluff(npc)
                elif selected_action == "Reveal":
                    self.npc_reveal(npc)
                elif selected_action == "Work Around Camp":
                    self.npc_work_around_camp(npc)
                elif selected_action == "Focus on Survival":
                    self.npc_focus_on_survival(npc)
                elif selected_action == "Probe For General Info":
                    self.npc_probe(npc, probe_type="general")
                elif selected_action == "Who are you planning to vote for?":
                    self.npc_probe(npc, probe_type="vote_target")
                elif selected_action == "Do you know who's getting voted out next?":
                    self.npc_probe(npc, probe_type="consensus_vote")
                else:
                    # Fallback to small talk if something goes wrong
                    self.npc_small_talk(npc)
                
                # Increment NPC's action count
                npc.npc_actions_taken_today += 1
            except KeyboardInterrupt:
                # Re-raise KeyboardInterrupt to let main game loop handle it
                raise
            except Exception as e:
                # Log the error and continue with other NPCs (silent for player)
                print(f"\nError during {npc.name}'s action: {e}")
                print("Continuing game...")
                continue
        
        # Mark that NPC actions have been completed for today
        self.npc_actions_completed_today = True
    
    def perform_opposing_tribe_npc_actions(self) -> None:
        """Have all NPCs in the opposing tribe perform their daily actions (2 per day)."""
        if self.merged:
            return  # No opposing tribe after merge
            
        # Get all active NPCs in the opposing tribe
        other_tribe = self.get_other_tribe()
        if not other_tribe:
            return
            
        npcs = [c for c in other_tribe if not c.is_player and not c.eliminated]
        
        # Each NPC performs 2 actions per day
        for npc in npcs:
            for action_num in range(2):
                try:
                    # Get the action hat for this NPC and draw an action
                    action_hat = self.get_npc_action_hat(npc)
                    if not action_hat:
                        # Fallback to small talk if action hat is empty
                        self.npc_small_talk_opposing_tribe(npc)
                        continue
                    selected_action = random.choice(action_hat)
                    
                    # Execute the selected action (modified for opposing tribe)
                    if selected_action == "Small Talk":
                        self.npc_small_talk_opposing_tribe(npc)
                    elif selected_action == "Pitch Alliance":
                        self.npc_pitch_alliance_opposing_tribe(npc)
                    elif selected_action == "Pitch Group Alliance":
                        self.npc_pitch_group_alliance_opposing_tribe(npc)
                    elif selected_action == "Pitch Vote Target":
                        self.npc_pitch_vote_target_opposing_tribe(npc)
                    elif selected_action == "Pitch Vote to Group":
                        self.npc_pitch_vote_to_group_opposing_tribe(npc)
                    elif selected_action == "Pitch Final 2 Deal":
                        self.npc_pitch_final_2_opposing_tribe(npc)
                    elif selected_action == "General Bluff":
                        self.npc_bluff_opposing_tribe(npc)
                    elif selected_action == "Bluff Someone is Targeting You":
                        self.npc_bluff_opposing_tribe(npc, bluff_type="targeting_you")
                    elif selected_action == "Bluff Someone is Consensus Vote":
                        self.npc_bluff_opposing_tribe(npc, bluff_type="consensus_vote")
                    elif selected_action == "Bluff":  # Backward compatibility
                        self.npc_bluff_opposing_tribe(npc)
                    elif selected_action == "Reveal":
                        self.npc_reveal_opposing_tribe(npc)
                    elif selected_action == "Work Around Camp":
                        self.npc_work_around_camp_opposing_tribe(npc)
                    elif selected_action == "Focus on Survival":
                        self.npc_focus_on_survival_opposing_tribe(npc)
                    elif selected_action == "Probe For General Info":
                        self.npc_probe_opposing_tribe(npc, probe_type="general")
                    elif selected_action == "Who are you planning to vote for?":
                        self.npc_probe_opposing_tribe(npc, probe_type="vote_target")
                    elif selected_action == "Do you know who's getting voted out next?":
                        self.npc_probe_opposing_tribe(npc, probe_type="consensus_vote")
                    else:
                        # Fallback to small talk if something goes wrong
                        self.npc_small_talk_opposing_tribe(npc)
                except KeyboardInterrupt:
                    # Re-raise KeyboardInterrupt to let main game loop handle it
                    raise
                except Exception as e:
                    # Silent error handling for opposing tribe
                    continue
    
    def npc_small_talk_opposing_tribe(self, npc: Contestant) -> None:
        """Handle NPC small talk in the opposing tribe (no player interaction)."""
        # Get tribe members excluding the NPC
        tribe_members = [c for c in self.get_active_contestants(npc.tribe) if c != npc]
        
        if not tribe_members:
            self.record_npc_action(npc, "Small Talk", "No one available")
            return
        
        # Weight targets based on relationships  
        weighted_targets = []
        for target in tribe_members:
            weight = 1
            relationship = npc.get_relationship(target)
            if relationship >= 2:
                weight = 3
            elif relationship == 1:
                weight = 2
            for _ in range(weight):
                weighted_targets.append(target)
        
        if not weighted_targets:
            weighted_targets = tribe_members
            
        target = random.choice(weighted_targets)
        
        # Roll for outcome
        base_roll = random.randint(1, 20)
        
        # Handle critical success/failure (natural 20/1 ignore modifiers)
        if base_roll == 20:
            total_roll = 20  # Critical success
        elif base_roll == 1:
            total_roll = 1   # Critical failure
        else:
            # Normal roll with modifiers
            social_bonus = npc.social_skill
            alliance_bonus = 1 if npc.has_real_alliance_with(target) else 0
            total_roll = base_roll + social_bonus + alliance_bonus
            # Add survival status modifiers
            if npc.survival_status == 3:
                total_roll += 1
            elif npc.survival_status == -1:
                total_roll -= 1
        
        if total_roll >= 14:  # Success
            npc.modify_relationship(target, 1)
            target.modify_relationship(npc, 1)
            self.record_npc_action(npc, f"Small Talk with {target.name}", "Success - relationship improved")
        else:
            self.record_npc_action(npc, f"Small Talk with {target.name}", "No relationship change")
    
    def npc_pitch_alliance_opposing_tribe(self, npc: Contestant) -> None:
        """Handle NPC pitching alliance in the opposing tribe."""
        eligible_targets = [c for c in self.get_active_contestants(npc.tribe) 
                          if c != npc 
                          and not npc.has_real_alliance_with(c)
                          and not npc.has_fake_alliance_with(c)
                          and npc.can_rebuild_alliance_with(c)]
        
        if not eligible_targets:
            self.record_npc_action(npc, "Pitch Alliance", "No eligible targets")
            return
            
        # Use weighted targets similar to player tribe
        weighted_targets = []
        for target in eligible_targets:
            weight = 1
            relationship = npc.get_relationship(target)
            if relationship >= 2:
                weight = 3
            elif relationship == 1:
                weight = 2
            if target.threat_level >= 7:
                weight += 1
            for _ in range(weight):
                weighted_targets.append(target)
                
        target = random.choice(weighted_targets if weighted_targets else eligible_targets)
        
        # Simulate alliance pitch using similar mechanics
        roll = random.randint(1, 20)
        persuasiveness_bonus = npc.persuasive_skill
        relationship_bonus = npc.get_relationship(target)
        resistance_roll = random.randint(1, 20) + target.resistance_to_persuasion
        
        if resistance_roll >= 16:
            resistance_modifier = -1
        elif resistance_roll <= 10:
            resistance_modifier = 1
        else:
            resistance_modifier = 0
            
        total_roll = roll + persuasiveness_bonus + relationship_bonus + resistance_modifier
        
        if roll == 1 or total_roll <= 7:  # Failure - fake alliance
            npc.fake_alliance_roster.append(target)
            target.alliance_roster.append(npc)
            target.modify_base_game_security(1, "Approached for alliance", silent=True)
            self.record_npc_action(npc, f"Pitch Alliance to {target.name}", "Failed - target created fake alliance")
        elif total_roll <= 13:  # Neutral
            self.record_npc_action(npc, f"Pitch Alliance to {target.name}", "Neutral - target needs time to think")
        else:  # Success
            npc.alliance_roster.append(target)
            target.alliance_roster.append(npc)
            npc.add_information('alliance', npc, target)
            target.add_information('alliance', target, npc)
            
            # Add to Game Move Bank (Level 1) for both NPCs
            npc.add_game_move('alliance_formed', 1, self.day, f"formed an alliance with {target.name.title()}")
            target.add_game_move('alliance_formed', 1, self.day, f"formed an alliance with {npc.name.title()}")
            
            # Track early alliances for Level 3 move (first 6 days)
            if self.day <= 6:
                npc.early_alliances[target] = self.day
                target.early_alliances[npc] = self.day
            
            self.record_npc_action(npc, f"Pitch Alliance to {target.name}", "Success - real alliance formed")
    
    def npc_pitch_vote_target_opposing_tribe(self, npc: Contestant) -> None:
        """Handle NPC pitching vote target in the opposing tribe."""
        if not npc.vote_target:
            self.record_npc_action(npc, "Pitch Vote", "No vote target to pitch")
            return
            
        eligible_targets = [c for c in self.get_active_contestants(npc.tribe) 
                          if c != npc and c != npc.vote_target]
        
        if not eligible_targets:
            self.record_npc_action(npc, "Pitch Vote", "No eligible targets")
            return
            
        # Weight by relationships and alliances
        weighted_targets = []
        for target in eligible_targets:
            weight = 1
            if npc.has_real_alliance_with(target):
                weight = 3
            elif npc.get_relationship(target) >= 2:
                weight = 2
            for _ in range(weight):
                weighted_targets.append(target)
                
        target = random.choice(weighted_targets if weighted_targets else eligible_targets)
        
        # Simulate vote pitch
        roll = random.randint(1, 20)
        persuasiveness_bonus = npc.persuasive_skill
        relationship_bonus = npc.get_relationship(target)
        alliance_bonus = 2 if npc.has_real_alliance_with(target) else 0
        
        total_roll = roll + persuasiveness_bonus + relationship_bonus + alliance_bonus
        
        if total_roll >= 14:  # Success
            old_target = target.vote_target
            target.vote_target = npc.vote_target
            target.add_information('vote_pitch', npc, npc.vote_target)
            npc.vote_pitch_agreements[target] = npc.vote_target
            self.record_npc_action(npc, f"Pitch Vote to {target.name}", f"Success - target switched from {old_target.name if old_target else 'none'} to {npc.vote_target.name}")
        else:
            self.record_npc_action(npc, f"Pitch Vote to {target.name}", "Failed - target kept their vote")
    
    def npc_reveal_opposing_tribe(self, npc: Contestant) -> None:
        """Handle NPC revealing information in the opposing tribe."""
        if not npc.information_bank:
            self.record_npc_action(npc, "Reveal", "No information to reveal")
            return
            
        eligible_targets = [c for c in self.get_active_contestants(npc.tribe) if c != npc]
        
        if not eligible_targets:
            self.record_npc_action(npc, "Reveal", "No eligible targets")
            return
            
        # Weight by relationships
        weighted_targets = []
        for target in eligible_targets:
            weight = 1
            if npc.has_real_alliance_with(target):
                weight = 3
            elif npc.get_relationship(target) >= 2:
                weight = 2
            for _ in range(weight):
                weighted_targets.append(target)
                
        target = random.choice(weighted_targets if weighted_targets else eligible_targets)
        
        # Filter appropriate info
        appropriate_info = [info for info in npc.information_bank
                          if not (info['type'] == 'vote_target' and info.get('subject') == npc and info.get('target') == target)]
        
        if not appropriate_info:
            self.record_npc_action(npc, f"Reveal to {target.name}", "No appropriate info to share")
            return
            
        info_to_reveal = random.choice(appropriate_info)
        
        # Simulate reveal
        roll = random.randint(1, 20)
        social_bonus = npc.social_skill
        alliance_bonus = 1 if npc.has_real_alliance_with(target) else 0
        relationship_bonus = 1 if npc.get_relationship(target) >= 2 else 0
        
        total_roll = roll + social_bonus + alliance_bonus + relationship_bonus
        
        if total_roll >= 14:  # Success
            target.information_bank.append(info_to_reveal.copy())
            target.information_bank[-1]['day'] = self.day
            info_type = info_to_reveal.get('type', 'unknown')
            self.record_npc_action(npc, f"Reveal to {target.name}", f"Success - shared {info_type} info")
        else:
            self.record_npc_action(npc, f"Reveal to {target.name}", "Failed - target didn't believe")
    
    def npc_probe_opposing_tribe(self, npc: Contestant, probe_type: str = "general") -> None:
        """Handle NPC probing in the opposing tribe."""
        eligible_targets = [c for c in self.get_active_contestants(npc.tribe) if c != npc]
        
        if not eligible_targets:
            self.record_npc_action(npc, f"Probe ({probe_type})", "No eligible targets")
            return
            
        target = random.choice(eligible_targets)
        
        # Simulate probe
        roll = random.randint(1, 20)
        social_bonus = npc.social_skill
        relationship_bonus = 1 if npc.get_relationship(target) >= 2 else 0
        
        total_roll = roll + social_bonus + relationship_bonus
        
        if total_roll >= 14 and target.information_bank:  # Success
            shared_info = random.choice(target.information_bank)
            npc.information_bank.append(shared_info.copy())
            npc.information_bank[-1]['day'] = self.day
            info_type = shared_info.get('type', 'unknown')
            self.record_npc_action(npc, f"Probe {target.name}", f"Success - learned {info_type} info")
        else:
            self.record_npc_action(npc, f"Probe {target.name}", "Failed to gain information")
    
    def npc_bluff_opposing_tribe(self, npc: Contestant, bluff_type: str = "general") -> None:
        """Handle NPC bluffing in the opposing tribe."""
        eligible_targets = [c for c in self.get_active_contestants(npc.tribe) if c != npc]
        
        if not eligible_targets:
            self.record_npc_action(npc, f"Bluff ({bluff_type})", "No eligible targets")
            return
            
        target = random.choice(eligible_targets)
        
        # Create bluff based on type
        if bluff_type == "targeting_you":
            # Pick someone to claim is targeting the listener
            potential_subjects = [c for c in self.get_active_contestants(npc.tribe) if c != npc and c != target]
            if potential_subjects:
                subject = random.choice(potential_subjects)
                bluff_info = {'type': 'vote_target', 'subject': subject, 'target': target, 'day': self.day}
            else:
                self.record_npc_action(npc, f"Bluff to {target.name}", "No valid subjects for bluff")
                return
        else:
            # General bluff - make something up
            bluff_options = ['vote_target', 'has_idol', 'alliance']
            bluff_type = random.choice(bluff_options)
            
            if bluff_type == 'has_idol':
                subject = random.choice([c for c in self.get_active_contestants(npc.tribe) if c != npc])
                bluff_info = {'type': 'has_idol', 'subject': subject, 'day': self.day}
            else:
                # Create other bluffs
                potential_subjects = [c for c in self.get_active_contestants(npc.tribe) if c != npc]
                if len(potential_subjects) >= 2:
                    subjects = random.sample(potential_subjects, 2)
                    bluff_info = {'type': 'alliance', 'subject': subjects[0], 'target': subjects[1], 'day': self.day}
                else:
                    self.record_npc_action(npc, f"Bluff to {target.name}", "Not enough contestants for bluff")
                    return
        
        # Roll for bluff success
        roll = random.randint(1, 20)
        persuasiveness_bonus = npc.persuasive_skill
        villain_bonus = 1 if npc.hero_or_villain == "Villain" else 0
        total_roll = roll + persuasiveness_bonus + villain_bonus
        
        if total_roll >= 12:  # Success
            target.information_bank.append(bluff_info)
            self.record_npc_action(npc, f"Bluff to {target.name}", f"Success - convinced them of {bluff_info['type']} bluff")
        else:
            self.record_npc_action(npc, f"Bluff to {target.name}", "Failed - target didn't believe")
    
    def npc_work_around_camp_opposing_tribe(self, npc: Contestant) -> None:
        """Handle NPC working around camp in the opposing tribe."""
        # Update work streaks
        npc.consecutive_work_days += 1
        npc.consecutive_no_work_days = 0
        npc.worked_today = True
        
        # Determine survival bonus based on hero/villain status
        survival_bonus = 2 if npc.hero_or_villain == "Hero" else 1
        
        # Apply survival bonus to all tribemates for tomorrow
        npc_tribe = self.get_active_contestants(npc.tribe)
        bonus_count = 0
        for contestant in npc_tribe:
            if contestant != npc and not contestant.eliminated:
                contestant.work_bonus_tomorrow = survival_bonus
                bonus_count += 1
        
        hero_text = " (Hero bonus)" if survival_bonus == 2 else ""
        self.record_npc_action(npc, "Work Around Camp", f"Provided +{survival_bonus} survival bonus{hero_text} to {bonus_count} tribemates for tomorrow")
    
    def npc_focus_on_survival_opposing_tribe(self, npc: Contestant) -> None:
        """Handle NPC focus on survival action in the opposing tribe."""
        # Random survival activities (same as regular version)
        survival_activities = [
            "cooking a pot of rice and eating",
            "gathering coconuts for refreshing coconut water",
            "improving the shelter for better comfort"
        ]
        
        # Choose random activity for logging
        chosen_activity = random.choice(survival_activities)
        
        # Improve survival status by 1 (clamped between -1 and 3)
        old_status = npc.survival_status
        npc.survival_status = min(3, npc.survival_status + 1)
        new_status = npc.survival_status
        
        # Track that NPC focused on survival today
        npc.focused_on_survival_today = True
        
        status_text = f" (survival status: {old_status} → {new_status})" if new_status > old_status else f" (survival status: {old_status})"
        self.record_npc_action(npc, "Focus on Survival", f"Spent time {chosen_activity}{status_text}")
    
    def npc_pitch_group_alliance_opposing_tribe(self, npc: Contestant) -> None:
        """Handle NPC pitching group alliance in the opposing tribe."""
        # Simplified version - just record that it happened
        self.record_npc_action(npc, "Pitch Group Alliance", "Attempted to form group alliance")
    
    def npc_pitch_vote_to_group_opposing_tribe(self, npc: Contestant) -> None:
        """Handle NPC pitching vote to group in the opposing tribe."""
        if not npc.vote_target:
            self.record_npc_action(npc, "Pitch Vote to Group", "No vote target to pitch")
            return
        self.record_npc_action(npc, "Pitch Vote to Group", f"Pitched vote against {npc.vote_target.name} to group")
    
    def npc_pitch_final_2_opposing_tribe(self, npc: Contestant) -> None:
        """Handle NPC pitching final 2 in the opposing tribe."""
        if npc.final_2_deal:
            self.record_npc_action(npc, "Pitch Final 2", "Already has Final 2 deal")
            return
            
        eligible_targets = [c for c in self.get_active_contestants(npc.tribe) 
                          if c != npc 
                          and not c.final_2_deal
                          and npc.get_relationship(c) >= 2]
        
        if not eligible_targets:
            self.record_npc_action(npc, "Pitch Final 2", "No eligible targets")
            return
            
        target = random.choice(eligible_targets)
        
        # Simulate Final 2 pitch
        roll = random.randint(1, 20)
        persuasiveness_bonus = npc.persuasive_skill
        relationship_bonus = npc.get_relationship(target)
        
        total_roll = roll + persuasiveness_bonus + relationship_bonus
        
        if total_roll >= 16:  # Success
            npc.final_2_deal = target
            target.final_2_deal = npc
            npc.add_information('final_2', npc, target)
            target.add_information('final_2', target, npc)
            self.record_npc_action(npc, f"Pitch Final 2 to {target.name}", "Success - Final 2 deal formed")
        else:
            self.record_npc_action(npc, f"Pitch Final 2 to {target.name}", "Failed - target declined")
    
    def get_npc_action_hat(self, npc: Contestant) -> List[str]:
        """Build a weighted list of possible actions for an NPC (the 'hat' of slips)."""
        hat = []
        
        # Small Talk - 3 base slips with modifiers
        small_talk_slips = 3
        
        # +1 if threat level >= 7
        if npc.threat_level >= 7:
            small_talk_slips += 1
        
        # +1 if game security >= 7
        if npc.base_game_security >= 7:
            small_talk_slips += 1
        
        # +1 if wearing immunity necklace
        if npc.immune:
            small_talk_slips += 1
        
        # +1 if no Final 2 deal
        if not npc.final_2_deal:
            small_talk_slips += 1
        
        # -1 if game security <= 4
        if npc.base_game_security <= 4:
            small_talk_slips -= 1
        
        # -1 if learned someone targeting them
        learned_targeting = False
        for info in npc.information_bank:
            if info['type'] == 'vote_target' and info.get('target') == npc:
                learned_targeting = True
                break
        if learned_targeting:
            small_talk_slips -= 1
        
        # -1 if relationship >= 2 with 3+ contestants
        high_relationships = sum(1 for rel_value in npc.relationships.values() if rel_value >= 2)
        if high_relationships >= 3:
            small_talk_slips -= 1
        
        # Remove all slips if learned they are consensus vote
        is_consensus_vote = False
        for info in npc.information_bank:
            if info['type'] == 'consensus_vote' and 'targets' in info:
                if npc in info['targets']:
                    is_consensus_vote = True
                    break
        
        if is_consensus_vote:
            small_talk_slips = 0
        
        # Only add slips if there are any remaining
        if small_talk_slips > 0:
            hat.extend(["Small Talk"] * small_talk_slips)
        
        # Pitch Alliance - 3 base slips with modifiers
        pitch_alliance_slips = 3
        
        # +2 on Day 1
        if self.day == 1:
            pitch_alliance_slips += 2
        
        # +2 on Merge Day
        if self.day == self.merge_day:
            pitch_alliance_slips += 2
        
        # +1 if game security is 4 or lower
        if npc.base_game_security <= 4:
            pitch_alliance_slips += 1
        
        # +1 if hasn't formed a new alliance in 3 days (including today)
        last_alliance_day = 0
        for info in npc.information_bank:
            if (info['type'] == 'alliance' and 
                info.get('subject') == npc and 
                info.get('day') is not None):
                last_alliance_day = max(last_alliance_day, info['day'])
        
        if last_alliance_day == 0 or (self.day - last_alliance_day) >= 3:
            pitch_alliance_slips += 1
        
        # -1 if in an alliance with 4 or more contestants
        if len(npc.alliance_roster) >= 4:
            pitch_alliance_slips -= 1
        
        # -1 if game security is 7 or higher
        if npc.base_game_security >= 7:
            pitch_alliance_slips -= 1
        
        # -1 if has a hidden immunity idol
        if npc.idol_count > 0:
            pitch_alliance_slips -= 1
        
        # -1 if didn't receive a vote at the last tribal council
        # Check if they participated in tribal and didn't receive votes
        if hasattr(self, 'last_tribal_vote_counts') and npc in self.last_tribal_vote_counts:
            if self.last_tribal_vote_counts[npc] == 0:
                pitch_alliance_slips -= 1
        
        # Only add slips if there are any remaining
        if pitch_alliance_slips > 0:
            hat.extend(["Pitch Alliance"] * pitch_alliance_slips)
        
        # Pitch Group Alliance - 3 base slips
        pitch_group_alliance_slips = 3
        
        # Only add slips if there are any remaining
        if pitch_group_alliance_slips > 0:
            hat.extend(["Pitch Group Alliance"] * pitch_group_alliance_slips)
        
        # Pitch Vote Target - 3 base slips with modifiers (no negatives)
        pitch_vote_slips = 3
        
        # +3 if learned someone is targeting them
        learned_targeting = False
        for info in npc.information_bank:
            if info['type'] == 'vote_target' and info.get('target') == npc:
                learned_targeting = True
                break
        if learned_targeting:
            pitch_vote_slips += 3
        
        # +5 if learned they are the consensus vote
        is_consensus_vote = False
        for info in npc.information_bank:
            if info['type'] == 'consensus_vote' and 'targets' in info:
                if npc in info['targets']:
                    is_consensus_vote = True
                    break
        if is_consensus_vote:
            pitch_vote_slips += 5
        
        # +3 if game security is 4 or lower
        if npc.base_game_security <= 4:
            pitch_vote_slips += 3
        
        # +2 if received votes at last tribal council
        if hasattr(self, 'last_tribal_vote_counts') and npc in self.last_tribal_vote_counts:
            if self.last_tribal_vote_counts[npc] > 0:
                pitch_vote_slips += 2
        
        # +2 if hasn't been pitched to in 3 days
        last_pitch_day = 0
        for info in npc.information_bank:
            if info['type'] == 'vote_pitch' and info.get('target') == npc and info.get('day') is not None:
                last_pitch_day = max(last_pitch_day, info['day'])
        
        if last_pitch_day == 0 or (self.day - last_pitch_day) >= 3:
            pitch_vote_slips += 2
        
        # +3 if tribe is going to tribal council that night
        if hasattr(self, 'player_tribe_has_tribal') and self.player_tribe_has_tribal:
            # Check if NPC is in the same tribe as the player (going to tribal)
            if npc.tribe == self.get_player_tribe_name():
                pitch_vote_slips += 3
        
        # -5 if knows consensus vote and it matches their vote target
        knows_consensus_matches_vote_target = False
        if npc.vote_target:
            for info in npc.information_bank:
                if info['type'] == 'consensus_vote':
                    # Check both old 'target' and new 'targets' format
                    consensus_targets = []
                    if 'targets' in info and info['targets']:
                        consensus_targets = info['targets']
                    elif 'target' in info and info['target']:
                        consensus_targets = [info['target']]
                    
                    if npc.vote_target in consensus_targets:
                        knows_consensus_matches_vote_target = True
                        break
        if knows_consensus_matches_vote_target:
            pitch_vote_slips -= 5
        
        # Remove all slips if NPC doesn't have a vote target
        if not npc.vote_target:
            pitch_vote_slips = 0
        
        # Always add slips (minimum 0)
        pitch_vote_slips = max(0, pitch_vote_slips)
        if pitch_vote_slips > 0:
            hat.extend(["Pitch Vote Target"] * pitch_vote_slips)
        
        # Pitch Vote to Group - 3 base slips with modifiers
        pitch_vote_group_slips = 3
        
        # +3 if learned someone is targeting them
        learned_targeting = False
        for info in npc.information_bank:
            if info['type'] == 'vote_target' and info.get('target') == npc:
                learned_targeting = True
                break
        if learned_targeting:
            pitch_vote_group_slips += 3
        
        # +5 if learned they are the consensus vote
        is_consensus_vote = False
        for info in npc.information_bank:
            if info['type'] == 'consensus_vote' and 'targets' in info:
                if npc in info['targets']:
                    is_consensus_vote = True
                    break
        if is_consensus_vote:
            pitch_vote_group_slips += 5
        
        # +3 if game security is 4 or lower
        if npc.base_game_security <= 4:
            pitch_vote_group_slips += 3
        
        # +2 if going to tribal council later that day
        if hasattr(self, 'player_tribe_has_tribal') and self.player_tribe_has_tribal:
            # Check if NPC is in the same tribe as the player (going to tribal)
            if npc.tribe == self.get_player_tribe_name():
                pitch_vote_group_slips += 2
        
        # +1 if in a group alliance
        if len(npc.group_alliances) > 0:
            pitch_vote_group_slips += 1
        
        # -5 if knows consensus vote and it matches their vote target
        knows_consensus_matches_vote_target_group = False
        if npc.vote_target:
            for info in npc.information_bank:
                if info['type'] == 'consensus_vote':
                    # Check both old 'target' and new 'targets' format
                    consensus_targets = []
                    if 'targets' in info and info['targets']:
                        consensus_targets = info['targets']
                    elif 'target' in info and info['target']:
                        consensus_targets = [info['target']]
                    
                    if npc.vote_target in consensus_targets:
                        knows_consensus_matches_vote_target_group = True
                        break
        if knows_consensus_matches_vote_target_group:
            pitch_vote_group_slips -= 5
        
        # Remove all slips if NPC doesn't have a vote target
        if not npc.vote_target:
            pitch_vote_group_slips = 0
        
        # Always add slips (minimum 0)
        pitch_vote_group_slips = max(0, pitch_vote_group_slips)
        if pitch_vote_group_slips > 0:
            hat.extend(["Pitch Vote to Group"] * pitch_vote_group_slips)
        
        # Pitch Final 2 Deal - 3 base slips + 2 per eligible contestant with modifiers
        eligible_final_2_count = 0
        eligible_allies = []
        if npc.alliance_roster:
            for ally in npc.alliance_roster:
                if (npc.get_relationship(ally) >= 2 and 
                    not npc.believes_has_final_2_with(ally) and 
                    not ally.eliminated):
                    eligible_final_2_count += 1
                    eligible_allies.append(ally)
        
        if eligible_final_2_count > 0:
            final_2_slips = 3 + (2 * eligible_final_2_count)
            
            # +2 if Pitching a Final 2 deal just became an option
            # Check if any ally just reached relationship 2 today
            just_became_option = False
            for ally in eligible_allies:
                # Check if relationship with this ally changed to 2+ recently
                if npc.get_relationship(ally) == 2:
                    # This is a simple check - ally has exactly 2 relationship
                    # In a more complex system we'd track relationship changes by day
                    just_became_option = True
                    break
            
            if just_became_option:
                final_2_slips += 2
            
            # +2 if villain AND already has a final 2 deal
            if npc.hero_or_villain == "Villain" and npc.final_2_deal:
                final_2_slips += 2
            
            # +1 if game security is 4 or less
            if npc.base_game_security <= 4:
                final_2_slips += 1
            
            # -2 if hero AND already has a final 2 deal
            if npc.hero_or_villain == "Hero" and npc.final_2_deal:
                final_2_slips -= 2
            
            # Only add slips if there are any remaining
            if final_2_slips > 0:
                hat.extend(["Pitch Final 2 Deal"] * final_2_slips)
        
        # Bluff actions with different types - 3 base slips each with Hero/Villain modifier
        base_bluff_slips = 3
        if npc.hero_or_villain == "Hero":
            base_bluff_slips -= 1  # Heroes get -1 Bluff slip
        elif npc.hero_or_villain == "Villain":
            base_bluff_slips += 1  # Villains get +1 Bluff slip
        
        if base_bluff_slips > 0:  # Only add if there are slips remaining
            hat.extend(["General Bluff"] * base_bluff_slips)  # 3 slips (or modified)
            hat.extend(["Bluff Someone is Targeting You"] * base_bluff_slips)  # 3 slips (or modified)
            
            # Consensus vote bluff has base of 2 slips
            consensus_bluff_slips = 2
            if npc.hero_or_villain == "Hero":
                consensus_bluff_slips -= 1  # Heroes get -1 Bluff slip
            elif npc.hero_or_villain == "Villain":
                consensus_bluff_slips += 1  # Villains get +1 Bluff slip
            
            if consensus_bluff_slips > 0:
                hat.extend(["Bluff Someone is Consensus Vote"] * consensus_bluff_slips)  # 2 slips (or modified)
        
        # Reveal - 3 base slips (only if NPC has information to reveal) with Hero/Villain modifier
        if npc.information_bank:
            reveal_slips = 3
            if npc.hero_or_villain == "Hero":
                reveal_slips += 1  # Heroes get +1 Reveal slip
            elif npc.hero_or_villain == "Villain":
                reveal_slips -= 1  # Villains get -1 Reveal slip
            
            if reveal_slips > 0:  # Only add if there are slips remaining
                hat.extend(["Reveal"] * reveal_slips)
        
        # Work Around Camp - 2 base slips with modifiers
        work_camp_slips = 2
        
        # -1 if game security is 4 or less
        if npc.base_game_security <= 4:
            work_camp_slips -= 1
            
        # Work streak modifiers
        # +3/+5/+7 slips for consecutive no-work days (3rd, 4th, 5th day)
        if npc.consecutive_no_work_days == 2:  # Today would be 3rd day
            work_camp_slips += 3
        elif npc.consecutive_no_work_days == 3:  # Today would be 4th day
            work_camp_slips += 5
        elif npc.consecutive_no_work_days >= 4:  # Today would be 5th+ day
            work_camp_slips += 7
            
        # -2 slips if worked yesterday
        if npc.consecutive_work_days >= 1:
            work_camp_slips -= 2
            
        # Remove all slips if on second turn AND worked on first turn today
        if (hasattr(self, 'npc_action_round') and self.npc_action_round == 2 and 
            hasattr(npc, 'worked_today') and npc.worked_today):
            work_camp_slips = 0
        
        # Only add slips if there are any remaining
        if work_camp_slips > 0:
            hat.extend(["Work Around Camp"] * work_camp_slips)
        
        # Focus on Survival - 4 base slips with survival status modifiers
        survival_slips = 4
        
        # Survival status modifiers
        if npc.survival_status == -1:
            survival_slips += 2  # +2 slips if survival status is -1
        elif npc.survival_status == 0:
            survival_slips += 1  # +1 slip if survival status is 0
        elif npc.survival_status == 2:
            survival_slips -= 1  # -1 slip if survival status is 2
        elif npc.survival_status == 3:
            survival_slips = 0   # Remove all slips if survival status is 3
        
        # Remove all slips if on second action AND focused on survival during first action
        if (hasattr(self, 'npc_action_round') and self.npc_action_round == 2 and 
            hasattr(npc, 'focused_on_survival_today') and npc.focused_on_survival_today):
            survival_slips = 0
        
        # Only add slips if there are any remaining
        if survival_slips > 0:
            hat.extend(["Focus on Survival"] * survival_slips)
        
        # Probe actions with different types
        # Probe For General Info - 2 base slips with modifiers
        probe_general_slips = 2
        
        # -1 if knows who has the hidden immunity idol
        knows_idol_holder = False
        for info in npc.information_bank:
            if info['type'] == 'has_idol':
                knows_idol_holder = True
                break
        if knows_idol_holder:
            probe_general_slips -= 1
        
        # -1 if has 6 or more pieces of information
        if len(npc.information_bank) >= 6:
            probe_general_slips -= 1
        
        # +1 if has 3 or less pieces of information (only after day 6)
        if self.day > 6 and len(npc.information_bank) <= 3:
            probe_general_slips += 1
        
        # +1 if in an alliance with 3 or more people
        if len(npc.alliance_roster) >= 3:
            probe_general_slips += 1
        
        # Only add slips if there are any remaining
        if probe_general_slips > 0:
            hat.extend(["Probe For General Info"] * probe_general_slips)
        
        # Probe for Vote Target - 3 base slips with modifiers
        probe_vote_slips = 3
        
        # Count how many vote targets the NPC knows
        known_vote_targets = set()
        for info in npc.information_bank:
            if info['type'] == 'vote_target' and info.get('subject'):
                known_vote_targets.add(info.get('subject'))
        
        vote_target_count = len(known_vote_targets)
        
        # +1 if knows vote target of 3 or less people
        if vote_target_count <= 3:
            probe_vote_slips += 1
        
        # -1 if knows vote target of 4 or more people
        if vote_target_count >= 4:
            probe_vote_slips -= 1
        
        # Only add slips if there are any remaining
        if probe_vote_slips > 0:
            hat.extend(["Who are you planning to vote for?"] * probe_vote_slips)
        
        # Probe for Consensus Vote - 3 base slips with modifiers
        probe_consensus_slips = 3
        
        # Check if knows consensus vote
        knows_consensus = False
        for info in npc.information_bank:
            if info['type'] == 'consensus_vote':
                knows_consensus = True
                break
        
        # Remove all slips if knows consensus vote
        if knows_consensus:
            probe_consensus_slips = 0
        else:
            # +2 if game security is 4 or less AND doesn't know consensus
            if npc.base_game_security <= 4:
                probe_consensus_slips += 2
        
        # Only add slips if there are any remaining
        if probe_consensus_slips > 0:
            hat.extend(["Do you know who's getting voted out next?"] * probe_consensus_slips)
        
        return hat
    
    def get_controlled_action_parameters(self, npc: Contestant, action: str) -> Dict:
        """Get parameters for a controlled action from player input."""
        if action == "Reveal":
            return self.get_reveal_params(npc)
        elif action == "Bluff":
            return self.get_bluff_params(npc)
        # For now, other actions just return empty params and use default behavior
        else:
            return {}
    
    def execute_controlled_action_with_params(self, npc: Contestant, action: str, params: Dict) -> None:
        """Execute a controlled action for an NPC during their regular turn using stored parameters."""
        if action == "Reveal":
            self.execute_controlled_reveal(npc, params)
        elif action == "Bluff":
            self.execute_controlled_bluff(npc, params)
        else:
            # For other actions, use the existing controlled action functions (default behavior)
            if action == "Small Talk":
                self.controlled_npc_small_talk(npc)
            elif action == "Pitch Alliance":
                self.controlled_npc_pitch_alliance(npc)
            elif action == "Pitch Vote Target":
                self.controlled_npc_pitch_vote_target(npc)
            elif action == "Pitch Final 2 Deal":
                self.controlled_npc_pitch_final_2(npc)
            elif action == "Work around camp":
                self.controlled_npc_work_around_camp(npc)
            elif action == "Probe":
                self.controlled_npc_probe(npc)
            else:
                print(f"Unknown controlled action: {action}")
    
    def get_reveal_params(self, npc: Contestant) -> Dict:
        """Get parameters for a controlled reveal action."""
        print(f"\nControl {npc.name}'s Reveal Action")
        print("-" * 40)
        
        # Check if NPC has any information to reveal
        if not npc.information_bank:
            print(f"{npc.name} has no information to reveal.")
            return None
        
        # Show available information to reveal
        print(f"\n{npc.name}'s available information to reveal:")
        for i, info in enumerate(npc.information_bank, 1):
            info_text = npc.get_information_text(info)
            print(f"{i:2}. {info_text}")
        print(f"{len(npc.information_bank) + 1}. Cancel")
        
        # Select information to reveal
        while True:
            try:
                info_choice = input(f"\nSelect information to reveal (1-{len(npc.information_bank) + 1}): ").strip()
                info_num = int(info_choice)
                
                if info_num == len(npc.information_bank) + 1:
                    return None  # Cancel
                    
                if 1 <= info_num <= len(npc.information_bank):
                    selected_info = npc.information_bank[info_num - 1]
                    break
                else:
                    print(f"Invalid choice. Please enter 1-{len(npc.information_bank) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Get potential targets
        player_tribe = self.get_player_tribe()
        if not player_tribe:
            print("No potential targets available.")
            return None
        
        potential_targets = [c for c in player_tribe if c != npc and not c.eliminated]
        if not potential_targets:
            print("No valid targets to reveal to.")
            return None
        
        print(f"\nWho should {npc.name} reveal this information to?")
        for i, target in enumerate(potential_targets, 1):
            player_marker = " (YOU)" if target.is_player else ""
            print(f"{i:2}. {target.name}{player_marker}")
        print(f"{len(potential_targets) + 1}. Cancel")
        
        # Select target
        while True:
            try:
                choice = input(f"\nSelect target (1-{len(potential_targets) + 1}): ").strip()
                choice_num = int(choice)
                
                if choice_num == len(potential_targets) + 1:
                    return None  # Cancel
                    
                if 1 <= choice_num <= len(potential_targets):
                    selected_target = potential_targets[choice_num - 1]
                    break
                else:
                    print(f"Invalid choice. Please enter 1-{len(potential_targets) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        return {
            'info_to_reveal': selected_info,
            'target': selected_target
        }
    
    def execute_controlled_reveal(self, npc: Contestant, params: Dict) -> None:
        """Execute a controlled reveal action with stored parameters."""
        info_to_reveal = params['info_to_reveal']
        target = params['target']
        
        print(f"\n{npc.name} reveals information to {target.name}:")
        print("-" * 30)
        
        info_text = npc.get_information_text_for_speaking(info_to_reveal, listener=target)
        self.contestant_speaks(npc, f"I need to tell you something... {info_text}")
        
        if target.is_player:
            # Add information to player's info bank
            player_info = info_to_reveal.copy()
            player_info['day'] = self.day
            self.player.information_bank.append(player_info)
            
            # Check for Final 2 betrayal if player learned about a Final 2 deal
            if player_info.get('type') == 'final_2' and player_info.get('subject') and player_info.get('target'):
                self.check_for_final_2_betrayal(self.player, player_info.get('subject'), player_info['target'])
            
            self.record_npc_action(npc, f"Reveal to player", f"Shared: {info_text}")
        else:
            # Add information to target NPC's bank
            target.information_bank.append(info_to_reveal.copy())
            if target.information_bank:
                target.information_bank[-1]['day'] = self.day
            
            # Check for Final 2 betrayal if target learned about a Final 2 deal
            if info_to_reveal.get('type') == 'final_2' and info_to_reveal.get('subject') and info_to_reveal.get('target'):
                # Check if the target just learned about a Final 2 deal involving the player
                if self.player in [info_to_reveal['subject'], info_to_reveal['target']]:
                    # Check if this target believes they have a Final 2 deal with the player
                    if target.believes_has_final_2_with(self.player):
                        # Betrayal detected! Handle confrontation immediately
                        if target not in self.npcs_needing_betrayal_confrontation:
                            self.npcs_needing_betrayal_confrontation.append(target)
                            # Figure out which contestant they learned about
                            other_contestant = info_to_reveal['target'] if info_to_reveal['subject'] == self.player else info_to_reveal['subject']
                            self.handle_immediate_confrontation(target, other_contestant)
                
                # Also perform the standard betrayal check
                self.check_for_final_2_betrayal(target, info_to_reveal['subject'], info_to_reveal['target'])
            
            self.record_npc_action(npc, f"Reveal to {target.name}", f"Shared: {info_text}")
    
    def get_bluff_params(self, npc: Contestant) -> Dict:
        """Get parameters for a controlled bluff action."""
        # For now, just return empty params - the existing controlled_npc_bluff function will handle it
        return {}
    
    def execute_controlled_bluff(self, npc: Contestant, params: Dict) -> None:
        """Execute a controlled bluff action with stored parameters."""
        # For now, just use the existing controlled_npc_bluff function
        self.controlled_npc_bluff(npc)
    
    def npc_small_talk(self, npc: Contestant) -> None:
        """Handle NPC small talk action with group or one-on-one conversation."""
        player_tribe = self.get_player_tribe()
        potential_targets = [c for c in player_tribe if c != npc and not c.eliminated]
        
        if not potential_targets:
            self.record_npc_action(npc, "Small Talk", "No available targets")
            return
        
        # Roll d20 to determine conversation type
        conversation_type_roll = random.randint(1, 20)
        
        if conversation_type_roll <= 10:
            # One-on-one conversation (original logic)
            self.npc_one_on_one_small_talk(npc, potential_targets)
        else:
            # Group conversation (new logic)
            self.npc_group_small_talk(npc, potential_targets)
    
    def npc_one_on_one_small_talk(self, npc: Contestant, potential_targets: List[Contestant]) -> None:
        """Handle NPC one-on-one small talk (original logic)."""
        target = random.choice(potential_targets)
        
        if target.is_player:
            # NPC wants to talk to the player
            self.contestants_who_interacted_with_player.append(npc)
            self.narration(f"{npc.name} approaches you for a conversation.")
            print(f"\n{npc.name} wants to have small talk with you.")
            print("1. Accept and chat")
            print("2. Make an excuse and leave")
            
            while True:
                try:
                    choice = int(input("Enter your choice (1-2): "))
                    if choice == 1:
                        self.small_talk_with(npc, player_initiated=False)
                        self.record_npc_action(npc, f"Small Talk with player", "Had a conversation with the player")
                    elif choice == 2:
                        self.narration(f"You politely excuse yourself from the conversation with {npc.name}.")
                        self.record_npc_action(npc, f"Small Talk with player", "Player declined conversation")
                    else:
                        print("Invalid choice. Please enter 1 or 2.")
                        continue
                    break
                except ValueError:
                    print("Invalid input. Please enter a number.")
        else:
            # NPC talks to another NPC (no narration needed)
            # Both NPCs improve their relationship
            npc.modify_relationship(target, 1)
            target.modify_relationship(npc, 1)
            self.record_npc_action(npc, f"Small Talk with {target.name}", f"Improved relationship (+1 both ways)")
    
    def npc_group_small_talk(self, npc: Contestant, potential_targets: List[Contestant]) -> None:
        """Handle NPC group small talk conversation."""
        if len(potential_targets) < 2:
            # Not enough people for a group conversation, fall back to one-on-one
            self.npc_one_on_one_small_talk(npc, potential_targets)
            return
        
        # Roll dice to determine group size (1 to number of available targets)
        max_group_size = len(potential_targets)
        group_size = random.randint(1, max_group_size)
        
        # But ensure at least 2 people for a proper group conversation
        group_size = max(2, group_size)
        group_size = min(group_size, len(potential_targets))  # Don't exceed available targets
        
        # Randomly select group participants
        group_participants = random.sample(potential_targets, group_size)
        
        # Check if player is in the group
        if self.player in group_participants:
            # Player is invited to the group conversation
            self.contestants_who_interacted_with_player.append(npc)
            other_participants = [c for c in group_participants if c != self.player]
            
            if len(other_participants) == 1:
                self.narration(f"{npc.name} approaches you and {other_participants[0].name} for a group conversation.")
                participant_list = f"you and {other_participants[0].name}"
            elif len(other_participants) == 2:
                participant_names = f"{other_participants[0].name} and {other_participants[1].name}"
                self.narration(f"{npc.name} gathers you and {participant_names} for a group conversation.")
                participant_list = f"you and {participant_names}"
            else:
                names = [c.name for c in other_participants]
                participant_names = f"{', '.join(names[:-1])}, and {names[-1]}"
                self.narration(f"{npc.name} gathers you and {participant_names} for a group conversation.")
                participant_list = f"you and {participant_names}"
            
            print(f"\n{npc.name} wants to have a group conversation with {participant_list}.")
            print("1. Join the conversation")
            print("2. Make an excuse and leave")
            
            while True:
                try:
                    choice = int(input("Enter your choice (1-2): "))
                    if choice == 1:
                        # Player joins - simulate group small talk with player included
                        self.npc_group_small_talk_with_player(npc, group_participants)
                        return
                    elif choice == 2:
                        self.narration(f"You politely excuse yourself from the group conversation.")
                        # Remove player from participants and continue with NPCs only
                        group_participants = other_participants
                        if len(group_participants) < 2:
                            self.record_npc_action(npc, f"Group Small Talk", "Player declined, not enough NPCs left for group")
                            return
                        break
                    else:
                        print("Invalid choice. Please enter 1 or 2.")
                        continue
                except ValueError:
                    print("Invalid input. Please enter a number.")
        
        # NPC-only group conversation
        self.npc_only_group_small_talk(npc, group_participants)
    
    def npc_group_small_talk_with_player(self, npc: Contestant, participants: List[Contestant]) -> None:
        """Handle group small talk that includes the player."""
        # Use the same group small talk mechanics as the player's group small talk
        group_size = len(participants) + 1  # Include the NPC
        
        # Roll d20 + NPC's social skill
        roll = random.randint(1, 20)
        social_bonus = npc.social_skill
        total_roll = roll + social_bonus
        
        # Apply same rules as player group small talk
        if group_size <= 5:
            if total_roll <= 7:  # Critical Failure/Failure
                # No relationship change
                self.narration("The group conversation is pleasant but doesn't lead to any deeper connections.")
                self.record_npc_action(npc, f"Group Small Talk with player and others", "Pleasant conversation, no relationship changes")
            elif 8 <= total_roll <= 13:  # Neutral
                # +1 relationship between 2 random people in the conversation
                all_group_members = participants + [npc]
                person1, person2 = random.sample(all_group_members, 2)
                
                person1.modify_relationship(person2, 1)
                person2.modify_relationship(person1, 1)
                
                if self.player in [person1, person2]:
                    other_person = person2 if person1 == self.player else person1
                    self.narration(f"During the group conversation, you and {other_person.name} find some common ground and connect a bit more.")
                else:
                    self.narration(f"You notice {person1.name} and {person2.name} seem to be hitting it off during the conversation.")
                
                self.record_npc_action(npc, f"Group Small Talk with player and others", f"{person1.name} and {person2.name} improved relationship")
            else:  # 14+ Success/Critical Success
                # +1 relationship between NPC and everyone in the conversation
                for participant in participants:
                    npc.modify_relationship(participant, 1)
                    participant.modify_relationship(npc, 1)
                
                self.narration(f"The group conversation goes exceptionally well! {npc.name} manages to connect with everyone.")
                self.record_npc_action(npc, f"Group Small Talk with player and others", f"{npc.name} improved relationships with everyone")
        else:  # 6 or more people
            if total_roll <= 13:  # Critical Failure/Failure/Neutral
                # No relationship change
                self.narration("With so many people involved, the conversation stays surface-level.")
                self.record_npc_action(npc, f"Group Small Talk with player and others", "Large group, no relationship changes")
            elif 14 <= total_roll <= 19:  # Success
                # +1 relationship between 2 random people
                all_group_members = participants + [npc]
                person1, person2 = random.sample(all_group_members, 2)
                
                person1.modify_relationship(person2, 1)
                person2.modify_relationship(person1, 1)
                
                if self.player in [person1, person2]:
                    other_person = person2 if person1 == self.player else person1
                    self.narration(f"Despite the large group, you manage to have a good side conversation with {other_person.name}.")
                else:
                    self.narration(f"In the larger group, you notice {person1.name} and {person2.name} having a good side conversation.")
                
                self.record_npc_action(npc, f"Group Small Talk with player and others", f"{person1.name} and {person2.name} improved relationship")
            else:  # 20+ Critical Success
                # +1 relationship between NPC and everyone
                for participant in participants:
                    npc.modify_relationship(participant, 1)
                    participant.modify_relationship(npc, 1)
                
                self.narration(f"Despite the large group size, {npc.name} somehow manages to engage everyone and create a memorable bonding experience!")
                self.record_npc_action(npc, f"Group Small Talk with player and others", f"{npc.name} improved relationships with everyone")
    
    def npc_only_group_small_talk(self, npc: Contestant, participants: List[Contestant]) -> None:
        """Handle group small talk among NPCs only (no player involved)."""
        group_size = len(participants) + 1  # Include the NPC
        
        # Roll d20 + NPC's social skill
        roll = random.randint(1, 20)
        social_bonus = npc.social_skill
        total_roll = roll + social_bonus
        
        # Apply same rules as player group small talk
        if group_size <= 5:
            if total_roll <= 7:  # Critical Failure/Failure
                # No relationship change
                self.record_npc_action(npc, f"Group Small Talk with {len(participants)} NPCs", "Pleasant conversation, no relationship changes")
            elif 8 <= total_roll <= 13:  # Neutral
                # +1 relationship between 2 random people in the conversation
                all_group_members = participants + [npc]
                person1, person2 = random.sample(all_group_members, 2)
                
                person1.modify_relationship(person2, 1)
                person2.modify_relationship(person1, 1)
                
                self.record_npc_action(npc, f"Group Small Talk with {len(participants)} NPCs", f"{person1.name} and {person2.name} improved relationship")
            else:  # 14+ Success/Critical Success
                # +1 relationship between NPC and everyone in the conversation
                for participant in participants:
                    npc.modify_relationship(participant, 1)
                    participant.modify_relationship(npc, 1)
                
                self.record_npc_action(npc, f"Group Small Talk with {len(participants)} NPCs", f"{npc.name} improved relationships with everyone")
        else:  # 6 or more people
            if total_roll <= 13:  # Critical Failure/Failure/Neutral
                # No relationship change
                self.record_npc_action(npc, f"Group Small Talk with {len(participants)} NPCs", "Large group, no relationship changes")
            elif 14 <= total_roll <= 19:  # Success
                # +1 relationship between 2 random people
                all_group_members = participants + [npc]
                person1, person2 = random.sample(all_group_members, 2)
                
                person1.modify_relationship(person2, 1)
                person2.modify_relationship(person1, 1)
                
                self.record_npc_action(npc, f"Group Small Talk with {len(participants)} NPCs", f"{person1.name} and {person2.name} improved relationship")
            else:  # 20+ Critical Success
                # +1 relationship between NPC and everyone
                for participant in participants:
                    npc.modify_relationship(participant, 1)
                    participant.modify_relationship(npc, 1)
                
                self.record_npc_action(npc, f"Group Small Talk with {len(participants)} NPCs", f"{npc.name} improved relationships with everyone")
    
    def get_weighted_alliance_targets(self, npc: Contestant) -> List[Contestant]:
        """Get weighted list of potential alliance targets for an NPC using hat-based system."""
        player_tribe = self.get_player_tribe()
        base_targets = [c for c in player_tribe if c != npc and not c.eliminated]
        
        weighted_hat = []
        
        for contestant in base_targets:
            # Skip if already in alliance (real or fake)
            if npc.has_real_alliance_with(contestant) or npc.has_fake_alliance_with(contestant):
                continue
            
            # Skip if rebuilding is not allowed due to broken alliance history
            if not npc.can_rebuild_alliance_with(contestant):
                continue
            
            # Base: 5 slips per contestant
            slips = 5
            
            # Add relationship ranking to slips
            relationship = npc.get_relationship(contestant)
            slips += relationship
            
            # -2 if contestant is NPC's vote target
            if npc.vote_target == contestant:
                slips -= 2
            
            # -2 if NPC learned contestant pitched them as vote target or is planning to vote for them
            for info in npc.information_bank:
                if ((info['type'] == 'vote_target' and 
                     info.get('subject') == contestant and 
                     info.get('target') == npc) or
                    (info['type'] == 'vote_pitch' and 
                     info.get('subject') == contestant and 
                     info.get('target') == npc)):
                    slips -= 2
                    break
            
            # -1 if contestant is on NPC's target roster
            if contestant in npc.target_roster:
                slips -= 1
            
            # Add the appropriate number of slips to the hat
            if slips > 0:
                for _ in range(slips):
                    weighted_hat.append(contestant)
        
        return weighted_hat

    def get_weighted_group_alliance_targets(self, npc: Contestant, available_targets: List[Contestant]) -> List[Contestant]:
        """Get weighted list of potential group alliance targets for an NPC using hat-based system."""
        weighted_hat = []
        
        for contestant in available_targets:
            # Base: 5 slips per contestant
            slips = 5
            
            # Add relationship ranking to slips
            relationship = npc.get_relationship(contestant)
            slips += relationship
            
            # -2 if contestant is NPC's vote target
            if npc.vote_target == contestant:
                slips -= 2
            
            # -2 if NPC learned contestant pitched them as vote target or is planning to vote for them
            for info in npc.information_bank:
                if ((info['type'] == 'vote_target' and 
                     info.get('subject') == contestant and 
                     info.get('target') == npc) or
                    (info['type'] == 'vote_pitch' and 
                     info.get('subject') == contestant and 
                     info.get('target') == npc)):
                    slips -= 2
                    break
            
            # -1 if contestant is on NPC's target roster
            if contestant in npc.target_roster:
                slips -= 1
            
            # +2 if NPC and contestant are already in a 2-person alliance
            if npc.has_real_alliance_with(contestant):
                slips += 2
            
            # Add the appropriate number of slips to the hat
            if slips > 0:
                for _ in range(slips):
                    weighted_hat.append(contestant)
        
        return weighted_hat

    def get_weighted_vote_pitch_targets(self, npc: Contestant) -> List[Contestant]:
        """Get weighted list of potential vote pitch targets for an NPC using hat-based system."""
        player_tribe = self.get_player_tribe()
        base_targets = [c for c in player_tribe if c != npc and not c.eliminated and not c.immune]
        
        weighted_hat = []
        
        for contestant in base_targets:
            # Base: 5 slips per contestant
            slips = 5
            
            # Remove all slips if contestant is NPC's vote target (can't pitch against your own target)
            if npc.vote_target == contestant:
                slips = 0
                continue
            
            # -2 if NPC already knows contestant is planning to vote for NPC's vote target
            if npc.vote_target:
                for info in npc.information_bank:
                    if (info['type'] == 'vote_target' and 
                        info.get('subject') == contestant and 
                        info.get('target') == npc.vote_target):
                        slips -= 2
                        break
            
            # Add the appropriate number of slips to the hat
            if slips > 0:
                for _ in range(slips):
                    weighted_hat.append(contestant)
        
        return weighted_hat

    def get_weighted_group_vote_pitch_targets(self, npc: Contestant, available_targets: List[Contestant]) -> List[Contestant]:
        """Get weighted list of potential group vote pitch targets for an NPC using hat-based system."""
        weighted_hat = []
        
        for contestant in available_targets:
            # Base: 5 slips per contestant
            slips = 5
            
            # Remove all slips if contestant is NPC's vote target (can't pitch against your own target)
            if npc.vote_target == contestant:
                slips = 0
                continue
            
            # -2 if NPC already knows contestant is planning to vote for NPC's vote target
            if npc.vote_target:
                for info in npc.information_bank:
                    if (info['type'] == 'vote_target' and 
                        info.get('subject') == contestant and 
                        info.get('target') == npc.vote_target):
                        slips -= 2
                        break
            
            # Add the appropriate number of slips to the hat
            if slips > 0:
                for _ in range(slips):
                    weighted_hat.append(contestant)
        
        return weighted_hat

    def get_weighted_bluff_targets(self, npc: Contestant) -> List[Contestant]:
        """Get weighted list of potential bluff targets for an NPC using hat-based system."""
        player_tribe = self.get_player_tribe()
        base_targets = [c for c in player_tribe if c != npc and not c.eliminated]
        
        weighted_hat = []
        
        for contestant in base_targets:
            # Base: 5 slips per contestant
            slips = 5
            
            # -3 if in an alliance
            if npc.has_real_alliance_with(contestant):
                slips -= 3
            
            # -1 slip if relationship ranking 2+
            if npc.get_relationship(contestant) >= 2:
                slips -= 1
            
            # +2 slips if planning to vote for target
            if npc.vote_target == contestant:
                slips += 2
            
            # +2 slips if knows target is planning to vote for them OR pitched them as a vote
            knows_target_planning_vote = False
            for info in npc.information_bank:
                if (info['type'] == 'vote_target' and 
                    info.get('subject') == contestant and 
                    info.get('target') == npc):
                    knows_target_planning_vote = True
                    break
                elif (info['type'] == 'vote_pitch' and 
                      info.get('subject') == contestant and 
                      info.get('target') == npc):
                    knows_target_planning_vote = True
                    break
            
            if knows_target_planning_vote:
                slips += 2
            
            # Add the appropriate number of slips to the hat
            if slips > 0:
                for _ in range(slips):
                    weighted_hat.append(contestant)
        
        return weighted_hat

    def get_weighted_reveal_targets(self, npc: Contestant) -> List[Contestant]:
        """Get weighted list of potential reveal targets for an NPC based on various factors."""
        player_tribe = self.get_player_tribe()
        base_targets = [c for c in player_tribe if c != npc and not c.eliminated]
        
        weighted_hat = []
        
        for contestant in base_targets:
            # Rule 1: Base - 3 slips per contestant
            slips = 3
            
            # Rule 2: Add 1 slip if players are in alliance
            if npc.has_real_alliance_with(contestant):
                slips += 1
            
            # Rule 3: Add 1 slip if relationship is 2 or higher
            if npc.get_relationship(contestant) >= 2:
                slips += 1
            
            # Rule 4: Remove 1 slip if relationship is -1
            if npc.get_relationship(contestant) == -1:
                slips -= 1
            
            # Rule 5: Remove 1 slip if contestant is NPC's vote target
            if npc.vote_target == contestant:
                slips -= 1
            
            # Add the appropriate number of slips to the hat
            if slips > 0:
                for _ in range(slips):
                    weighted_hat.append(contestant)
        
        return weighted_hat

    def get_weighted_probe_targets(self, npc: Contestant) -> List[Contestant]:
        """Get weighted list of potential probe targets for an NPC based on various factors."""
        player_tribe = self.get_player_tribe()
        base_targets = [c for c in player_tribe if c != npc and not c.eliminated]
        
        weighted_hat = []
        
        for contestant in base_targets:
            # Rule 1: Base - 3 slips per contestant
            slips = 3
            
            # Rule 2: Add 1 slip if NOT in alliance AND relationship is 1 or higher
            if (not npc.has_real_alliance_with(contestant) and 
                npc.get_relationship(contestant) >= 1):
                slips += 1
            
            # Rule 3: Add 1 slip if contestant is allied with someone targeting the NPC
            # Check if anyone targeting the NPC is in alliance with this contestant
            for info in npc.information_bank:
                if (info['type'] == 'vote_target' and 
                    info.get('target') == npc):  # Someone plans to vote for NPC
                    voter = info.get('subject')
                    # Check if this contestant is in alliance with that voter
                    for alliance_info in npc.information_bank:
                        if (alliance_info['type'] == 'alliance' and
                            ((alliance_info.get('subject') == contestant and alliance_info.get('target') == voter) or
                             (alliance_info.get('subject') == voter and alliance_info.get('target') == contestant))):
                            slips += 1
                            break
                    break
            
            # Rule 4: Remove 1 slip if contestants are targeting each other
            mutual_targeting = False
            if npc.vote_target == contestant:
                # Check if contestant is also targeting NPC
                for info in npc.information_bank:
                    if (info['type'] == 'vote_target' and 
                        info.get('subject') == contestant and 
                        info.get('target') == npc):
                        mutual_targeting = True
                        break
            if mutual_targeting:
                slips -= 1
            
            # Rule 5: Remove 1 slip if NPC was busted by this contestant in past 3 days
            if contestant in npc.busted_penalties:
                penalty_level, day_expires = npc.busted_penalties[contestant]
                # Check if busting happened within past 3 days (penalty still active)
                if day_expires > self.day:  # Penalty still active means recent busting
                    slips -= 1
            
            # Add the appropriate number of slips to the hat
            if slips > 0:
                for _ in range(slips):
                    weighted_hat.append(contestant)
        
        return weighted_hat

    def npc_pitch_alliance(self, npc: Contestant) -> None:
        """Handle NPC alliance pitch action."""
        # Get weighted list of potential targets
        weighted_targets = self.get_weighted_alliance_targets(npc)
        
        if not weighted_targets:
            self.record_npc_action(npc, "Pitch Alliance", "No available targets (everyone is already allied)")
            return
            
        target = random.choice(weighted_targets)
        
        if target.is_player:
            # NPC wants to pitch alliance to player
            self.contestants_who_interacted_with_player.append(npc)
            self.narration(f"{npc.name} approaches you with a serious expression.")
            print(f"\n{npc.name} wants to discuss strategy with you.")
            print("1. Listen to their pitch")
            print("2. Make an excuse and leave")
            
            while True:
                try:
                    choice = int(input("Enter your choice (1-2): "))
                    if choice == 1:
                        # Simulate the alliance pitch
                        self.npc_pitch_alliance_to_player(npc)
                        self.record_npc_action(npc, f"Pitch Alliance to player", "Pitched alliance to the player")
                    elif choice == 2:
                        self.narration(f"You politely excuse yourself from the conversation with {npc.name}.")
                        self.record_npc_action(npc, f"Pitch Alliance to player", "Player declined to listen")
                    else:
                        print("Invalid choice. Please enter 1 or 2.")
                        continue
                    break
                except ValueError:
                    print("Invalid input. Please enter a number.")
            return  # Exit after player interaction is complete
        else:
            # NPC pitches to another NPC (no narration needed)
            # Roll d20 + persuasion skill
            roll = random.randint(1, 20)
            persuasiveness_bonus = npc.persuasive_skill
            
            # Get temporary persuasion modifier from probe responses
            temp_persuasion_bonus = self.get_temporary_persuasion_modifier(npc, target)
            
            # Get resistance modifier from the target
            resistance_modifier = self.roll_resistance_to_persuasion(target)
            
            # Apply busted penalty if applicable
            busted_penalty = self.get_busted_penalty(npc, target)
            
            # Apply NPC reveal bonus if applicable
            npc_reveal_bonus = 0
            if hasattr(self, 'npc_reveal_bonuses') and (npc, target) in self.npc_reveal_bonuses:
                if self.npc_reveal_bonuses[(npc, target)] >= self.day:
                    npc_reveal_bonus = 1
            
            # Apply group alliance persuasion bonus
            group_alliance_persuasion_bonus = self.get_group_alliance_persuasion_bonus(npc, target)
            
            total_roll = roll + persuasiveness_bonus + resistance_modifier + busted_penalty + npc_reveal_bonus + group_alliance_persuasion_bonus + temp_persuasion_bonus
            
            # Determine success based on total roll
            if total_roll >= 14:
                # Form real alliance between NPCs
                npc.alliance_roster.append(target)
                target.alliance_roster.append(npc)
                
                # Game Security: NPC successfully pitched an alliance (+1)
                npc.modify_base_game_security(1, "Successfully pitched alliance", silent=True)
                # Game Security: NPC was approached to be in an alliance (+1)
                target.modify_base_game_security(1, "Approached for alliance", silent=True)
                target.mark_pitched_to_today()
                
                # Update vote targets and target rosters if they were targeting each other
                if npc.vote_target == target:
                    self.assign_random_vote_target(npc)
                if target.vote_target == npc:
                    self.assign_random_vote_target(target)
                    
                npc.target_roster = [c for c in npc.target_roster if c != target]
                target.target_roster = [c for c in target.target_roster if c != npc]
                
                penalty_text = f"+{busted_penalty}" if busted_penalty else ""
                self.record_npc_action(npc, f"Pitch Alliance to {target.name}", f"Success! Formed alliance (roll: {roll}+{persuasiveness_bonus}+{resistance_modifier}{penalty_text}={total_roll})")
            else:
                penalty_text = f"+{busted_penalty}" if busted_penalty else ""
                self.record_npc_action(npc, f"Pitch Alliance to {target.name}", f"Failed to form alliance (roll: {roll}+{persuasiveness_bonus}+{resistance_modifier}{penalty_text}={total_roll})")
    
    def npc_pitch_group_alliance(self, npc: Contestant) -> None:
        """Handle NPC group alliance pitch action."""
        # Check if NPC already has 2 group alliances
        current_group_alliances = len(npc.group_alliances)
        if current_group_alliances >= 2:
            self.record_npc_action(npc, "Pitch Group Alliance", "Already has maximum (2) group alliances")
            return
        
        # Get potential targets from the same tribe
        player_tribe = self.get_player_tribe()
        potential_targets = [c for c in player_tribe if c != npc and not c.eliminated]
        
        if len(potential_targets) < 2:
            self.record_npc_action(npc, "Pitch Group Alliance", "Not enough people available for group alliance")
            return
        
        # Check for alliance rebuilding restrictions
        available_targets = []
        for target in potential_targets:
            if npc.can_rebuild_alliance_with(target):
                available_targets.append(target)
        
        if len(available_targets) < 2:
            self.record_npc_action(npc, "Pitch Group Alliance", "Not enough eligible people (alliance rebuilding restrictions)")
            return
        
        # Select 2-4 people for the group alliance
        group_size = random.randint(2, min(4, len(available_targets)))
        
        # Use hat-based selection for group alliance targets
        weighted_hat = self.get_weighted_group_alliance_targets(npc, available_targets)
        
        if len(weighted_hat) < group_size:
            # Not enough weighted options, adjust group size
            group_size = len(set(weighted_hat))  # Use set to count unique targets
            if group_size < 2:
                self.record_npc_action(npc, "Pitch Group Alliance", "Not enough viable targets after weighting")
                return
        
        # Select targets from the weighted hat
        selected_targets = []
        remaining_hat = weighted_hat.copy()
        
        for _ in range(group_size):
            if not remaining_hat:
                break
            target = random.choice(remaining_hat)
            if target not in selected_targets:
                selected_targets.append(target)
            # Remove all instances of this target from the remaining hat
            remaining_hat = [t for t in remaining_hat if t != target]
        
        # Narrate the pitch
        target_names = ', '.join([c.name for c in selected_targets])
        player_bonus = 0
        force_failure = False
        player_alliance_to_leave = None
        
        if self.player in selected_targets:
            # Player is included - show the interaction and get their choice
            other_targets = [t for t in selected_targets if t != self.player]
            if other_targets:
                names = [t.name for t in other_targets]
                if len(names) == 1:
                    other_names = names[0]
                elif len(names) == 2:
                    other_names = f"{names[0]} and {names[1]}"
                else:
                    other_names = f"{', '.join(names[:-1])}, and {names[-1]}"
                self.narration(f"{npc.name} approaches you and {other_names} about forming a group alliance.")
            else:
                self.narration(f"{npc.name} approaches you about forming a group alliance.")
            
            self.contestant_speaks(npc, f"I think we could all work really well together. What do you all say to forming an alliance?")
            
            # Check if player would need to leave an alliance
            player_alliance_to_leave = None
            if len(self.player.group_alliances) >= 2:
                print("\nYou are already in 2 group alliances. To join this one, you'll need to leave an existing alliance.")
                print("\nYour current group alliances:")
                for i, alliance_id in enumerate(self.player.group_alliances, 1):
                    if alliance_id in self.group_alliances:
                        alliance_members = [m.name for m in self.group_alliances[alliance_id]['members'] if m != self.player and not m.eliminated]
                        print(f"{i}. Alliance with: {', '.join(alliance_members)}")
                print(f"{len(self.player.group_alliances) + 1}. Cancel (don't join new alliance)")
                
                while True:
                    try:
                        leave_choice = int(input(f"\nWhich alliance would you like to leave? (1-{len(self.player.group_alliances) + 1}): "))
                        if 1 <= leave_choice <= len(self.player.group_alliances):
                            player_alliance_to_leave = self.player.group_alliances[leave_choice - 1]
                            break
                        elif leave_choice == len(self.player.group_alliances) + 1:
                            # Player chose to cancel
                            force_failure = True
                            player_bonus = 0
                            break
                        else:
                            print(f"Please enter a number between 1 and {len(self.player.group_alliances) + 1}.")
                    except ValueError:
                        print("Please enter a valid number.")
            
            # Ask player for their choice (if they didn't cancel above)
            if not force_failure:
                print("\nWould you like to join the group alliance?")
                print("1. Yes")
                print("2. No")
                
                while True:
                    try:
                        choice = int(input("Enter your choice (1-2): "))
                        if choice == 1:
                            player_bonus = 2
                            break
                        elif choice == 2:
                            force_failure = True
                            break
                        else:
                            print("Please enter 1 or 2.")
                    except ValueError:
                        print("Please enter a valid number.")
        else:
            # Player is not included - just record the action
            self.record_npc_action(npc, f"Pitch Group Alliance", f"Approached {target_names} about forming group alliance")
        
        # Use the same roll mechanics as player group alliance pitching
        roll = random.randint(1, 20)
        persuasive_bonus = npc.persuasive_skill
        
        # Calculate modifiers (same as player version)
        existing_alliance_bonus = sum(1 for target in selected_targets if npc.has_real_alliance_with(target))
        relationship_bonus = sum(1 for target in selected_targets if npc.get_relationship(target) >= 2)
        
        all_participants = [npc] + selected_targets
        has_vote_targets_present = any(p.vote_target and p.vote_target in all_participants for p in all_participants)
        no_vote_targets_bonus = 0 if has_vote_targets_present else 1
        
        being_targeted_penalty = sum(1 for target in selected_targets if target.vote_target == npc)
        
        busted_penalty = 0
        for target in selected_targets:
            if target in npc.busted_penalties:
                penalty_level, day_expires = npc.busted_penalties[target]
                if self.day <= day_expires:
                    busted_penalty += 1
        
        previous_vote_penalty = 0
        if hasattr(self, 'vote_history') and npc in self.vote_history:
            npc_vote_history = self.vote_history[npc]
            for target in selected_targets:
                if target in npc_vote_history:
                    previous_vote_penalty += 1
        
        # +1 if average strategic skill among all participants is 2 or higher
        strategic_skill_bonus = 0
        total_strategic_skill = sum(participant.strategic_skill for participant in all_participants)
        average_strategic_skill = total_strategic_skill / len(all_participants)
        if average_strategic_skill >= 2.0:
            strategic_skill_bonus = 1
        
        total_roll = roll + persuasive_bonus + existing_alliance_bonus + relationship_bonus + no_vote_targets_bonus - being_targeted_penalty - busted_penalty - previous_vote_penalty + player_bonus + strategic_skill_bonus
        
        # Check for forced failure from player rejection
        if force_failure:
            # Player said no - automatic failure regardless of roll
            if self.player in selected_targets:
                self.narration("You decline the alliance offer.")
                responses = [
                    "Well, I guess that's not going to work then.",
                    "Okay, maybe another time.",
                    "That's disappointing, but I understand.",
                    "Alright, let's just forget about this."
                ]
                self.contestant_speaks(npc, random.choice(responses))
                self.narration("The alliance pitch falls apart and everyone goes their separate ways.")
            
            self.record_npc_action(npc, f"Pitch Group Alliance", f"Failed to form group alliance with {target_names} - player declined")
            return
        
        # Determine outcome
        if total_roll >= 16:  # Success
            # Create real group alliance
            alliance_id = self.next_group_alliance_id
            self.next_group_alliance_id += 1
            
            all_members = [npc] + selected_targets
            self.group_alliances[alliance_id] = {
                'members': all_members,
                'formed_day': self.day,
                'pitcher': npc
            }
            
            # Handle alliance departures for members who exceed limit
            for member in all_members:
                if member == self.player and player_alliance_to_leave:
                    # Player already selected which alliance to leave
                    self.leave_group_alliance(self.player, player_alliance_to_leave, "Joining new alliance")
                elif member != self.player and len(member.group_alliances) >= 2:
                    # For NPCs, automatically leave their oldest alliance
                    alliance_to_leave = member.group_alliances[0]  # Leave oldest alliance
                    self.leave_group_alliance(member, alliance_to_leave, "joining another alliance")
                
                member.group_alliances.append(alliance_id)
            
            # Add group alliance information to all members' information banks
            # Store individual alliance relationships for each pair
            for member in all_members:
                for other_member in all_members:
                    if member != other_member:
                        # Add information about alliance with each other member
                        self.add_information_with_day(member, 'alliance', member, other_member)
            
            # Add special group alliance entry for player's info bank display
            if self.player in all_members:
                other_members = [m for m in all_members if m != self.player]
                info_entry = {
                    'type': 'group_alliance',
                    'subject': self.player,
                    'members': other_members,
                    'alliance_id': alliance_id,
                    'day': self.day
                }
                self.player.information_bank.append(info_entry)
                # Clean up any duplicate group alliances
                self.player.clean_duplicate_group_alliances()
            
            # Show success message
            if self.player in selected_targets:
                self.narration(f"The group agrees to form an alliance! You're now part of a group alliance with {self.format_alliance_member_list(all_members, exclude_player=True)}.")
            
            self.record_npc_action(npc, f"Pitch Group Alliance", f"Successfully formed group alliance with {target_names} (roll: {total_roll})")
        
        elif total_roll >= 5:  # Failure
            if self.player in selected_targets:
                responses = [
                    "I think we should all just focus on the challenges for now.",
                    "That's a big commitment. I need to think about it.",
                    "I'm not sure about that right now.",
                    "Let's just see how things go naturally."
                ]
                self.contestant_speaks(random.choice([t for t in selected_targets if t != self.player] + [selected_targets[0]]), random.choice(responses))
                self.narration("The alliance pitch doesn't gain traction and everyone goes their separate ways.")
            
            self.record_npc_action(npc, f"Pitch Group Alliance", f"Failed to form group alliance with {target_names} (roll: {total_roll})")
        
        else:  # 1-4: Fake alliance
            # Create fake group alliance where only NPC thinks it's real
            alliance_id = self.next_group_alliance_id
            self.next_group_alliance_id += 1
            
            all_members = [npc] + selected_targets
            self.group_alliances[alliance_id] = {
                'members': all_members,
                'formed_day': self.day,
                'pitcher': npc
            }
            
            # Only NPC gets the alliance (fake for others)
            if len(npc.group_alliances) >= 2:
                alliance_to_leave = self.select_alliance_to_leave(npc)
                if alliance_to_leave:
                    self.leave_group_alliance(npc, alliance_to_leave, "joining another alliance")
            
            npc.group_alliances.append(alliance_id)
            
            # Others think they agreed but don't actually get the alliance
            for target in selected_targets:
                # If player needs to leave an alliance for a fake one, they still leave their real alliance
                if target == self.player and player_alliance_to_leave:
                    self.leave_group_alliance(self.player, player_alliance_to_leave, "Joining new alliance")
                target.fake_group_alliances.append(alliance_id)
            
            # Add group alliance information to all members' information banks (even fake ones)
            for member in all_members:
                for other_member in all_members:
                    if member != other_member:
                        # Add information about alliance with each other member
                        self.add_information_with_day(member, 'alliance', member, other_member)
            
            # Add special group alliance entry for player's info bank display (even if fake)
            if self.player in all_members:
                other_members = [m for m in all_members if m != self.player]
                info_entry = {
                    'type': 'group_alliance',
                    'subject': self.player,
                    'members': other_members,
                    'alliance_id': alliance_id,
                    'day': self.day
                }
                self.player.information_bank.append(info_entry)
                # Clean up any duplicate group alliances
                self.player.clean_duplicate_group_alliances()
            
            if self.player in selected_targets:
                # Use identical narration to real alliance success
                self.narration(f"The group agrees to form an alliance! You're now part of a group alliance with {self.format_alliance_member_list(all_members, exclude_player=True)}.")
            
            self.record_npc_action(npc, f"Pitch Group Alliance", f"Formed fake group alliance with {target_names} (roll: {total_roll})")
    
    def npc_pitch_vote_target(self, npc: Contestant) -> None:
        """Handle NPC vote target pitch action."""
        # Check if NPC has a vote target
        if not npc.vote_target:
            self.record_npc_action(npc, "Pitch Vote Target", "No vote target selected yet")
            return
        
        # If NPC has a priority vote pitch target (someone targeting them), prioritize that
        if (hasattr(npc, 'priority_vote_pitch_target') and 
            npc.priority_vote_pitch_target and 
            npc.vote_target == npc.priority_vote_pitch_target):
            # Prioritize pitching against the person who's targeting them
            weighted_targets = self.get_weighted_vote_pitch_targets(npc)
            if weighted_targets:
                # Give extra weight to pitching this priority target
                target = random.choice(weighted_targets)
                # Clear the priority flag after use
                npc.priority_vote_pitch_target = None
            else:
                self.record_npc_action(npc, "Pitch Vote Target", "No available targets for priority pitch")
                return
        else:
            # Normal target selection
            weighted_targets = self.get_weighted_vote_pitch_targets(npc)
            
            if not weighted_targets:
                self.record_npc_action(npc, "Pitch Vote Target", "No available targets")
                return
                
            target = random.choice(weighted_targets)
        
        # Final 2 Alliance Benefit 1: Vote pitches against Final 2 partners always fail for NPCs
        if (target.has_real_final_2_with(npc.vote_target) or 
            target.has_fake_final_2_with(npc.vote_target)):
            if not target.is_player:
                # NPC-to-NPC pitch automatically fails due to Final 2 protection
                self.record_npc_action(npc, f"Pitch Vote Target ({npc.vote_target.name}) to {target.name}", 
                                     f"Auto-failed! {target.name} has Final 2 deal with {npc.vote_target.name}")
                return
            # For player, let them decide how to respond (continue to normal flow)
        
        if target.is_player:
            # Don't pitch to the player if they're planning to vote for the player
            if npc.vote_target == self.player:
                return
            
            # Don't pitch to the player if they're somehow targeting themselves (should never happen)
            if npc.vote_target == npc:
                # If this happens, clear the invalid vote target and return
                npc.vote_target = None
                return
            
            # Don't pitch cross-tribe targets during pre-merge
            if not self.merged and npc.vote_target and npc.vote_target.tribe != npc.tribe:
                return
                
            # NPC wants to pitch vote target to player
            self.contestants_who_interacted_with_player.append(npc)
            self.narration(f"{npc.name} approaches you looking concerned.")
            print(f"\n{npc.name} wants to discuss the upcoming vote with you.")
            print("1. Listen to their thoughts")
            print("2. Make an excuse and leave")
            
            while True:
                try:
                    choice = int(input("Enter your choice (1-2): "))
                    if choice == 1:
                        # NPC shares their vote target
                        self.contestant_speaks(npc, f"I think we should vote for {npc.vote_target.name}.")
                        # Add pitch information to player's info bank
                        self.add_player_information('vote_pitch', npc, npc.vote_target)
                        # Add vote target information to player's info bank (they know NPC's vote plan)
                        self.add_player_information('vote_target', npc, npc.vote_target)
                        print("\nHow do you respond?")
                        print("1. Agree with their target")
                        print("2. Decline the pitch")
                        
                        response = int(input("Enter your choice (1-2): "))
                        if response == 1:
                            self.narration(f"You agree that {npc.vote_target.name} should be the target.")
                            
                            # Only ask to update vote target if it's different from current target
                            if self.player.vote_target != npc.vote_target:
                                print(f"\nWould you like to update your Vote Target to {npc.vote_target.name}?")
                                print("1. Yes")
                                print("2. No")
                                
                                while True:
                                    try:
                                        update_choice = int(input("Enter your choice (1-2): "))
                                        if update_choice == 1:
                                            # Safety check - don't let player target themselves
                                            if npc.vote_target != self.player:
                                                self.player.vote_target = npc.vote_target
                                                self.narration(f"Your vote target has been updated to {npc.vote_target.name}.")
                                            else:
                                                self.narration("You can't target yourself! Keeping your current vote target.")
                                            break
                                        elif update_choice == 2:
                                            break
                                        else:
                                            print("Invalid choice. Please enter 1 or 2.")
                                    except ValueError:
                                        print("Invalid input. Please enter a number.")
                            else:
                                self.narration(f"Your vote target is already set to {npc.vote_target.name}.")
                            
                            npc.modify_relationship(self.player, 1)
                            # Track the vote pitch agreement
                            self.player.vote_pitch_agreements[npc] = npc.vote_target
                            # Add to NPC's info bank that player agreed to vote for their target
                            npc.add_information('vote_target', self.player, npc.vote_target)
                            if npc.information_bank:
                                npc.information_bank[-1]['day'] = self.day
                            # Add to player's info bank that NPC is planning to vote for their target
                            self.add_information_with_day(self.player, 'vote_target', npc, npc.vote_target)
                            self.record_npc_action(npc, f"Pitch Vote Target ({npc.vote_target.name}) to player", "Player agreed with target")
                        elif response == 2:
                            self.narration(f"You politely decline {npc.get_pronoun('possessive')} vote pitch.")
                            
                            # Consequences for declining vote pitch - calculate slips for each option
                            option1_slips = 3  # Accept denial, no consequences
                            option2_slips = 3  # Relationship -1
                            option3_slips = 3  # Add to target roster
                            
                            # Get current relationship
                            relationship = self.player.get_relationship(npc)
                            
                            # Apply modifiers for Option 1
                            # +1 if relationship is 1 or higher
                            if relationship >= 1:
                                option1_slips += 1
                            
                            # +1 if in alliance with the pitcher
                            if self.player in npc.alliance_roster:
                                option1_slips += 1
                            
                            # -1 if relationship is 0 or lower
                            if relationship <= 0:
                                option1_slips = max(0, option1_slips - 1)
                            
                            # -1 if player is on pitcher's target roster
                            if self.player in npc.target_roster:
                                option1_slips = max(0, option1_slips - 1)
                            
                            # Apply modifiers for Option 2
                            # If relationship is already -1, convert all Option 2 slips to Option 3
                            if relationship <= -1:
                                option3_slips += option2_slips
                                option2_slips = 0
                            
                            total_slips = option1_slips + option2_slips + option3_slips
                            consequence_draw = random.randint(1, total_slips)
                            
                            if consequence_draw <= option1_slips:  # Option 1: No consequences
                                pass  # NPC accepts the denial
                            elif consequence_draw <= option1_slips + option2_slips:  # Option 2: Relationship penalty
                                npc.modify_relationship(self.player, -1)
                                # Check for alliance breaking due to relationship falling to -1
                                self.check_relationship_alliance_breaking(npc, self.player)
                            else:  # Option 3: Add to target roster
                                if self.player not in npc.target_roster:
                                    npc.target_roster.append(self.player)
                            
                            self.record_npc_action(npc, f"Pitch Vote Target ({npc.vote_target.name}) to player", "Player declined the pitch")
                    elif choice == 2:
                        self.narration(f"You politely excuse yourself from the conversation with {npc.name}.")
                        self.record_npc_action(npc, f"Pitch Vote Target to player", "Player declined to listen")
                    else:
                        print("Invalid choice. Please enter 1 or 2.")
                        continue
                    break
                except ValueError:
                    print("Invalid input. Please enter a number.")
            return  # Exit after player interaction is complete
        else:
            # Don't allow cross-tribe vote pitches during pre-merge
            if not self.merged and npc.vote_target and npc.vote_target.tribe != npc.tribe:
                return
                
            # NPC pitches to another NPC (no narration needed)
            # Share vote target information
            target.add_information('vote_pitch', npc, npc.vote_target)
            # Update the day for the most recent information
            if target.information_bank:
                target.information_bank[-1]['day'] = self.day
            
            # Check for alliance betrayal
            self.check_vote_pitch_betrayal(npc, npc.vote_target, target)
            
            # Also record that the pitcher is planning to vote for the target
            target.add_information('vote_target', npc, npc.vote_target)
            # Update the day for the most recent information
            if target.information_bank:
                target.information_bank[-1]['day'] = self.day
            
            # Mark that this NPC was pitched to today (for game security)
            target.mark_pitched_to_today()
            
            # Roll to see if the pitch is successful
            roll = random.randint(1, 20)
            persuasiveness_bonus = npc.persuasive_skill
            
            # Get temporary persuasion modifier from probe responses
            temp_persuasion_bonus = self.get_temporary_persuasion_modifier(npc, target)
            
            # Get resistance modifier from the target
            resistance_modifier = self.roll_resistance_to_persuasion(target)
            
            # Apply busted penalty if applicable
            busted_penalty = self.get_busted_penalty(npc, target)
            
            # Apply NPC reveal bonus if applicable
            npc_reveal_bonus = 0
            if hasattr(self, 'npc_reveal_bonuses') and (npc, target) in self.npc_reveal_bonuses:
                if self.npc_reveal_bonuses[(npc, target)] >= self.day:
                    npc_reveal_bonus = 1
            
            # Apply group alliance bonuses
            group_alliance_persuasion_bonus = self.get_group_alliance_persuasion_bonus(npc, target)
            group_alliance_resistance_bonus = self.get_group_alliance_persuasion_bonus(target, npc.vote_target)  # Resistance if target and vote_target are in same group alliance
            
            total_roll = roll + persuasiveness_bonus + resistance_modifier + busted_penalty + npc_reveal_bonus + group_alliance_persuasion_bonus - group_alliance_resistance_bonus + temp_persuasion_bonus
            
            # Check if target knows the consensus vote is their vote target
            knows_consensus_matches_target = False
            if target.vote_target:
                for info in target.information_bank:
                    if info['type'] == 'consensus_vote' and 'targets' in info:
                        if target.vote_target in info['targets']:
                            knows_consensus_matches_target = True
                            break
            
            # Determine success
            # If target knows consensus matches their target, require critical success (20+)
            success_threshold = 20 if knows_consensus_matches_target else 14
            
            if total_roll >= success_threshold:  # Success threshold
                # Target changes their vote using priority system
                old_target = target.vote_target
                self.assign_vote_target_with_priority(target, npc, npc.vote_target, total_roll)
                
                # Update target roster if necessary
                if old_target and old_target in target.target_roster:
                    target.target_roster = [c for c in target.target_roster if c != old_target]
                if npc.vote_target and npc.vote_target not in target.target_roster:
                    target.target_roster.append(npc.vote_target)
                
                penalty_text = f"+{busted_penalty}" if busted_penalty else ""
                critical_text = " (Critical Success needed!)" if knows_consensus_matches_target else ""
                self.record_npc_action(npc, f"Pitch Vote Target ({npc.vote_target.name}) to {target.name}", 
                                     f"Success!{critical_text} {target.name} will vote for {npc.vote_target.name} (roll: {roll}+{persuasiveness_bonus}+{resistance_modifier}{penalty_text}={total_roll})")
            else:
                # Target keeps their original vote
                penalty_text = f"+{busted_penalty}" if busted_penalty else ""
                self.record_npc_action(npc, f"Pitch Vote Target ({npc.vote_target.name}) to {target.name}", 
                                     f"Failure! {target.name} will stick with their intended target (roll: {roll}+{persuasiveness_bonus}+{resistance_modifier}{penalty_text}={total_roll})")
    
    def npc_pitch_vote_to_group(self, npc: Contestant) -> None:
        """Handle NPC vote target pitch to group action."""
        # Check if NPC has a vote target
        if not npc.vote_target:
            self.record_npc_action(npc, "Pitch Vote to Group", "No vote target selected yet")
            return
        
        # Prevent self-targeting (should never happen but safety check)
        if npc.vote_target == npc:
            npc.vote_target = None
            self.record_npc_action(npc, "Pitch Vote to Group", "Invalid self-target detected and cleared")
            return
        
        player_tribe = self.get_player_tribe()
        
        # Determine who to pitch to
        if len(npc.group_alliances) > 0:
            # NPC is in a group alliance - ALWAYS pitch to their group alliance
            selected_targets = []
            
            # Get all members from their group alliances (excluding themselves and vote target)
            for alliance_id in npc.group_alliances:
                if alliance_id in self.group_alliances:
                    alliance_members = self.group_alliances[alliance_id]['members']
                    for member in alliance_members:
                        if member != npc and member != npc.vote_target and member in player_tribe and not member.eliminated and member not in selected_targets:
                            selected_targets.append(member)
            
            if len(selected_targets) < 2:
                self.record_npc_action(npc, "Pitch Vote to Group", "Not enough group alliance members available for a group pitch - need at least 2 people")
                return
            
            pitch_type = "group alliance"
            
        else:
            # NPC is not in a group alliance - hand pick using hat-based system
            available_targets = [c for c in player_tribe if c != npc and not c.eliminated]
            
            if len(available_targets) < 2:
                self.record_npc_action(npc, "Pitch Vote to Group", "Not enough people available to pitch to")
                return
            
            # Use hat-based selection for group vote pitch targets
            weighted_hat = self.get_weighted_group_vote_pitch_targets(npc, available_targets)
            
            if len(set(weighted_hat)) < 2:  # Need at least 2 unique targets
                self.record_npc_action(npc, "Pitch Vote to Group", "Not enough viable targets after weighting")
                return
            
            # Select 2-3 targets from the weighted hat
            group_size = random.randint(2, min(3, len(set(weighted_hat))))
            selected_targets = []
            remaining_hat = weighted_hat.copy()
            
            for _ in range(group_size):
                if not remaining_hat:
                    break
                target = random.choice(remaining_hat)
                if target not in selected_targets:
                    selected_targets.append(target)
                # Remove all instances of this target from the remaining hat
                remaining_hat = [t for t in remaining_hat if t != target]
            
            if len(selected_targets) < 2:
                self.record_npc_action(npc, "Pitch Vote to Group", "Could not find enough people for a group pitch - need at least 2 people")
                return
            
            pitch_type = "hand-picked group"
        
        # Narrate the pitch
        target_names = ', '.join([t.name for t in selected_targets])
        
        if self.player in selected_targets:
            # Player is included - show the interaction
            other_targets = [t for t in selected_targets if t != self.player]
            if other_targets:
                if len(other_targets) == 1:
                    other_names = other_targets[0].name
                    self.narration(f"{npc.name} approaches you and {other_names} about the upcoming vote.")
                elif len(other_targets) == 2:
                    other_names = f"{other_targets[0].name} and {other_targets[1].name}"
                    self.narration(f"{npc.name} approaches you, {other_names}, about the upcoming vote.")
                else:
                    # For multiple people, use proper comma separation with "and"
                    other_names = ', '.join([t.name for t in other_targets[:-1]]) + f", and {other_targets[-1].name}"
                    self.narration(f"{npc.name} approaches you, {other_names}, about the upcoming vote.")
            else:
                self.narration(f"{npc.name} approaches you about the upcoming vote.")
            
            self.contestant_speaks(npc, f"I think we should all vote for {npc.vote_target.name} at the next tribal council. What do you think?")
            
            # Get player's response
            print(f"\n{npc.name} has pitched {npc.vote_target.name} as the next vote target. Do you agree with {npc.get_pronoun('possessive')} pitch?")
            print("1. Yes")
            print("2. No")
            
            while True:
                try:
                    player_choice = int(input("Enter your choice (1-2): "))
                    if player_choice in [1, 2]:
                        break
                    else:
                        print("Please enter 1 or 2.")
                except ValueError:
                    print("Please enter a valid number.")
            
            player_modifier = 0
            player_agrees = False
            
            if player_choice == 1:
                player_modifier = 2
                player_agrees = True
                print(f"You agree with {npc.name}'s pitch.")
            else:
                player_modifier = -2
                player_agrees = False
                print(f"You disagree with {npc.name}'s pitch.")
        else:
            # Player is not included - just record the action
            self.record_npc_action(npc, f"Pitch Vote to Group", f"Approached {target_names} about voting for {npc.vote_target.name}")
            player_modifier = 0
            player_agrees = False
        
        # Determine roll mechanics based on whether it's group alliance or hand-picked
        roll = random.randint(1, 20)
        persuasive_bonus = npc.persuasive_skill
        total_roll = roll + persuasive_bonus + player_modifier
        
        if len(npc.group_alliances) > 0:
            # Pitching to group alliance - easier success (14+)
            success_threshold = 14
            pitch_description = f"group alliance ({target_names})"
        else:
            # Hand-picked people - harder success (18+)
            success_threshold = 18
            pitch_description = f"hand-picked group ({target_names})"
        
        if total_roll >= success_threshold:
            # Success - people agree to the vote target
            if self.player in selected_targets:
                responses = [
                    f"That makes sense. {npc.vote_target.name} is definitely a threat.",
                    f"I agree, {npc.vote_target.name} needs to go.",
                    f"You're right about {npc.vote_target.name}. Let's do it.",
                    f"That's a good call. {npc.vote_target.name} has to go."
                ]
                response_giver = random.choice([t for t in selected_targets if t != self.player] + [selected_targets[0]])
                self.contestant_speaks(response_giver, random.choice(responses))
                self.narration(f"The group agrees to vote for {npc.vote_target.name}!")
                
                # If player agreed to the pitch, offer to update their vote target
                if player_agrees:
                    # Compare by name to avoid object reference issues
                    current_target_name = self.player.vote_target.name if self.player.vote_target else None
                    npc_target_name = npc.vote_target.name if npc.vote_target else None
                    
                    if current_target_name != npc_target_name:
                        print(f"\nWould you like to update your vote target to {npc.vote_target.name}?")
                        print("1. Yes")
                        print("2. No")
                        while True:
                            try:
                                update_choice = int(input("Enter your choice (1-2): "))
                                if update_choice in [1, 2]:
                                    break
                                else:
                                    print("Please enter 1 or 2.")
                            except ValueError:
                                print("Please enter a valid number.")
                        
                        if update_choice == 1:
                            old_target = self.player.vote_target.name if self.player.vote_target else "None"
                            # Human player doesn't use target roster - just change target
                            # Safety check - don't let player target themselves
                            if npc.vote_target != self.player:
                                self.player.vote_target = npc.vote_target
                                print(f"Your vote target has been updated from {old_target} to {npc.vote_target.name}.")
                            else:
                                print("You can't target yourself! Keeping your current vote target.")
                        else:
                            print(f"Your vote target remains {self.player.vote_target.name if self.player.vote_target else 'None'}.")
                    else:
                        print(f"You are already planning to vote for {npc.vote_target.name}.")
            
            # Set vote targets for group members (except player - handled above)
            for target in selected_targets:
                if target != self.player:
                    previous_vote_target = target.vote_target
                    self.track_first_pitch_for_target(npc, npc.vote_target)
                    target.vote_target = npc.vote_target
                    self.track_successful_pitch(npc, npc.vote_target, target, previous_vote_target)
                    # Add vote pitch agreement
                    target.vote_pitch_agreements[npc] = npc.vote_target
            
            # Add vote pitch agreement for player only if they agreed
            if self.player in selected_targets and player_agrees:
                self.player.vote_pitch_agreements[npc] = npc.vote_target
            
            # Add to information banks
            for target in selected_targets:
                if target != self.player or player_agrees:
                    self.add_information_with_day(target, 'vote_pitch', npc, npc.vote_target)
                    # Record that each person is planning to vote for this target (for consensus calculation)
                    if target == self.player and player_agrees:
                        self.add_information_with_day(self.player, 'vote_target', target, npc.vote_target)
                    elif target != self.player:
                        # NPCs who were successfully pitched to are planning to vote for the target
                        self.add_information_with_day(npc, 'vote_target', target, npc.vote_target)
                        if self.player in selected_targets:
                            self.add_information_with_day(self.player, 'vote_target', target, npc.vote_target)
            self.add_information_with_day(npc, 'vote_pitch', npc, npc.vote_target)
            self.add_information_with_day(npc, 'vote_target', npc, npc.vote_target)
            
            self.record_npc_action(npc, f"Pitch Vote to Group", f"Successfully convinced {pitch_description} to vote for {npc.vote_target.name} (roll: {total_roll})")
            
        elif not len(npc.group_alliances) > 0 and total_roll >= 6:
            # Hand-picked group polite decline (6-17)
            if self.player in selected_targets:
                responses = [
                    "I'm not sure about that right now.",
                    "Let me think about it some more.",
                    "I don't think that's the right move yet.",
                    "We should wait and see how things develop."
                ]
                response_giver = random.choice([t for t in selected_targets if t != self.player] + [selected_targets[0]])
                self.contestant_speaks(response_giver, random.choice(responses))
                self.narration("The group politely declines the vote target suggestion.")
                
                # Add information to player's bank even though they declined
                self.add_information_with_day(self.player, 'vote_pitch', npc, npc.vote_target)
                self.add_information_with_day(self.player, 'vote_target', npc, npc.vote_target)
            
            self.record_npc_action(npc, f"Pitch Vote to Group", f"Group politely declined voting for {npc.vote_target.name} (roll: {total_roll})")
            
        elif not len(npc.group_alliances) > 0 and total_roll <= 5:
            # Hand-picked group bluff (1-5) - pretend to accept
            if self.player in selected_targets:
                responses = [
                    f"That makes sense. {npc.vote_target.name} is definitely a threat.",
                    f"I agree, {npc.vote_target.name} needs to go.",
                    f"You're right about {npc.vote_target.name}. Let's do it.",
                    f"That's a good call. {npc.vote_target.name} has to go."
                ]
                response_giver = random.choice([t for t in selected_targets if t != self.player] + [selected_targets[0]])
                self.contestant_speaks(response_giver, random.choice(responses))
                self.narration(f"The group agrees to vote for {npc.vote_target.name}!")
                
                # Add information to player's bank (player knows about the pitch and Kim's target)
                self.add_information_with_day(self.player, 'vote_pitch', npc, npc.vote_target)
                self.add_information_with_day(self.player, 'vote_target', npc, npc.vote_target)
            
            # Only NPC thinks it worked - others are bluffing
            npc.add_information('vote_pitch', npc, npc.vote_target)
            # Note: Others do NOT change their vote targets or add agreements
            
            self.record_npc_action(npc, f"Pitch Vote to Group", f"Group bluffed agreement to vote for {npc.vote_target.name} (roll: {total_roll})")
            
        else:
            # Group alliance polite decline (1-13)
            if self.player in selected_targets:
                responses = [
                    "I'm not sure about that right now.",
                    "Let me think about it some more.",
                    "I don't think that's the right move yet.",
                    "We should wait and see how things develop."
                ]
                response_giver = random.choice([t for t in selected_targets if t != self.player] + [selected_targets[0]])
                self.contestant_speaks(response_giver, random.choice(responses))
                self.narration("The group politely declines the vote target suggestion.")
                
                # Add information to player's bank even though they declined
                self.add_information_with_day(self.player, 'vote_pitch', npc, npc.vote_target)
                self.add_information_with_day(self.player, 'vote_target', npc, npc.vote_target)
            
            self.record_npc_action(npc, f"Pitch Vote to Group", f"Group alliance declined voting for {npc.vote_target.name} (roll: {total_roll})")
    
    def npc_pitch_final_2(self, npc: Contestant) -> None:
        """Handle NPC final 2 pitch action."""
        # NPCs can only pitch to allies they don't already have (or think they have) a final 2 deal with
        eligible_targets = [c for c in npc.alliance_roster 
                          if not c.eliminated 
                          and not npc.believes_has_final_2_with(c)
                          and npc.can_rebuild_alliance_with(c)]
        
        if not eligible_targets:
            self.record_npc_action(npc, "Pitch Final 2", "No available alliance members to pitch to")
            return
        
        # Choose a target (prefer stronger relationships)
        weighted_targets = []
        for target in eligible_targets:
            relationship = npc.get_relationship(target)
            # Add more copies for better relationships
            weight = max(1, relationship + 2)  # Weight from 1 to 5
            weighted_targets.extend([target] * weight)
        
        target = random.choice(weighted_targets)
        
        if target.is_player:
            # NPC wants to pitch final 2 to player
            self.contestants_who_interacted_with_player.append(npc)
            self.narration(f"{npc.name} approaches you with a serious expression.")
            print(f"\n{npc.name} wants to discuss going to the end together.")
            print("1. Listen to their final 2 pitch")
            print("2. Make an excuse and leave")
            
            while True:
                try:
                    choice = int(input("Enter your choice (1-2): "))
                    if choice == 1:
                        # Simulate the final 2 pitch
                        self.npc_pitch_final_2_to_player(npc)
                        self.record_npc_action(npc, f"Pitch Final 2 to player", "Pitched final 2 deal to the player")
                    elif choice == 2:
                        self.narration(f"You politely excuse yourself from the conversation with {npc.name}.")
                        self.record_npc_action(npc, f"Pitch Final 2 to player", "Player declined to listen")
                    else:
                        print("Invalid choice. Please enter 1 or 2.")
                        continue
                    break
                except ValueError:
                    print("Invalid input. Please enter a number.")
            return
        else:
            # NPC pitches to another NPC
            # Roll d20 + persuasion skill
            roll = random.randint(1, 20)
            persuasiveness_bonus = npc.persuasive_skill
            relationship_bonus = npc.get_relationship(target)
            
            # Get temporary persuasion modifier from probe responses
            temp_persuasion_bonus = self.get_temporary_persuasion_modifier(npc, target)
            
            # Get resistance modifier from the target
            resistance_modifier = self.roll_resistance_to_persuasion(target)
            
            # Apply busted penalty if applicable
            busted_penalty = self.get_busted_penalty(npc, target)
            
            total_roll = roll + persuasiveness_bonus + relationship_bonus + resistance_modifier + busted_penalty + temp_persuasion_bonus
            
            # Determine success based on total roll
            if total_roll >= 14:  # Success threshold
                # Check if target already has a final 2 deal
                if target.final_2_deal:
                    self.record_npc_action(npc, f"Pitch Final 2 to {target.name}", 
                                         f"Failed - {target.name} already has a final 2 deal")
                else:
                    # Form real final 2 deal between NPCs
                    npc.final_2_deal = target
                    target.final_2_deal = npc
                    
                    # Game Security: Both NPCs become part of a Final 2 Deal (+1 each)
                    npc.modify_base_game_security(1, "Formed Final 2 deal", silent=True)
                    target.modify_base_game_security(1, "Formed Final 2 deal", silent=True)
                    target.mark_pitched_to_today()
                    
                    # Remove each other from target rosters
                    npc.target_roster = [c for c in npc.target_roster if c != target]
                    target.target_roster = [c for c in target.target_roster if c != npc]
                    
                    # Update vote targets if they were targeting each other
                    if npc.vote_target == target:
                        self.assign_random_vote_target(npc)
                    if target.vote_target == npc:
                        self.assign_random_vote_target(target)
                    
                    # Add final 2 information to both NPCs' information banks
                    npc.add_information('final_2', npc, target)
                    target.add_information('final_2', target, npc)
                    if npc.information_bank:
                        npc.information_bank[-1]['day'] = self.day
                    if target.information_bank:
                        target.information_bank[-1]['day'] = self.day
                    
                    # Note: Betrayal detection should only happen when NPCs learn about existing deals
                    # not when they form new deals themselves
                    
                    penalty_text = f"+{busted_penalty}" if busted_penalty else ""
                    self.record_npc_action(npc, f"Pitch Final 2 to {target.name}", 
                                         f"Success! Formed final 2 deal (roll: {roll}+{persuasiveness_bonus}+{relationship_bonus}+{resistance_modifier}{penalty_text}={total_roll})")
            else:
                # Add final 2 pitch information to target's bank (they know npc pitched)
                target.add_information('final_2_pitch', npc, target)
                if target.information_bank:
                    target.information_bank[-1]['day'] = self.day
                
                penalty_text = f"+{busted_penalty}" if busted_penalty else ""
                self.record_npc_action(npc, f"Pitch Final 2 to {target.name}", 
                                     f"Failed to form final 2 deal (roll: {roll}+{persuasiveness_bonus}+{relationship_bonus}+{resistance_modifier}{penalty_text}={total_roll})")
    
    def npc_bluff(self, npc: Contestant, bluff_type: str = None) -> None:
        """Handle NPC bluff action."""
        # Get weighted list of potential targets
        weighted_targets = self.get_weighted_bluff_targets(npc)
        
        if not weighted_targets:
            self.record_npc_action(npc, f"Bluff ({bluff_type})", "No available targets")
            return
            
        target = random.choice(weighted_targets)
        
        # Determine bluff type if not specified
        if bluff_type is None:
            # Determine bluff type based on day restrictions (for backward compatibility)
            if self.day <= 3:
                # Days 1-3: Only vote_target bluffs for NPCs
                bluff_type = 'vote_target'
            else:
                # After day 3: Random bluff type
                bluff_types = ['vote_target', 'has_idol', 'alliance', 'final_2']
                
                # Add previous_vote bluff if we've had at least one tribal council
                if any(info['type'] == 'previous_vote' for info in npc.information_bank):
                    bluff_types.append('previous_vote')
                
                bluff_type = random.choice(bluff_types)
        
        # Handle new bluff types
        if bluff_type == "targeting_you":
            self.npc_bluff_targeting_you(npc, target)
            return
        elif bluff_type == "consensus_vote":
            self.npc_bluff_consensus_vote(npc, target)
            return
        
        if target.is_player:
            # NPC wants to bluff to player
            self.contestants_who_interacted_with_player.append(npc)
            self.narration(f"{npc.name} approaches you looking like {npc.get_pronoun('subject')} wants to share something.")
            print(f"\n{npc.name} wants to tell you something important.")
            print(f"1. Listen to what {npc.get_pronoun('subject')} has to say")
            print("2. Make an excuse and leave")
            
            while True:
                try:
                    choice = int(input("Enter your choice (1-2): "))
                    if choice == 1:
                        # Execute the bluff
                        if bluff_type == 'vote_target':
                            # Choose a fake vote target (exclude player when bluffing to player)
                            player_tribe = self.get_player_tribe()
                            fake_targets = [c for c in player_tribe if c != npc and c != npc.vote_target and c != self.player and not c.eliminated]
                            if fake_targets:
                                fake_target = random.choice(fake_targets)
                                self.contestant_speaks(npc, f"I need to tell you something... I'm planning to vote for {fake_target.name}.")
                                # Add false information to player's info bank
                                self.add_player_information('vote_target', npc, fake_target)
                                self.record_npc_action(npc, f"Bluff to player", f"Lied about vote target (claimed: {fake_target.name}, actual: {npc.vote_target.name if npc.vote_target else 'undecided'})")
                            else:
                                # Fallback if no valid fake targets
                                self.contestant_speaks(npc, "I need to tell you something... I'm still thinking about who to vote for.")
                                self.record_npc_action(npc, f"Bluff to player", "Attempted vote target bluff but no valid targets")
                        elif bluff_type == 'has_idol':
                            if not npc.has_idol:
                                self.contestant_speaks(npc, "I need to tell you something... I found the hidden immunity idol.")
                                # Add false information to player's info bank
                                self.add_player_information('has_idol', npc)
                                self.record_npc_action(npc, f"Bluff to player", "Lied about having an idol")
                            else:
                                # When target is player, still deliver bluff content even if NPC has idol
                                self.contestant_speaks(npc, "I need to tell you something... I found the hidden immunity idol.")
                                # Add false information to player's info bank (even though NPC actually has one)
                                self.add_player_information('has_idol', npc)
                                self.record_npc_action(npc, f"Bluff to player", "Lied about having an idol (actually does have one)")
                        elif bluff_type == 'alliance':
                            # Choose random contestants for fake alliance (excluding the player)
                            player_tribe = self.get_player_tribe()
                            fake_allies = random.sample([c for c in player_tribe if c != npc and c != self.player and not c.eliminated], 
                                                      min(2, len([c for c in player_tribe if c != npc and c != self.player and not c.eliminated])))
                            if fake_allies:
                                ally_names = " and ".join([c.name for c in fake_allies])
                                self.contestant_speaks(npc, f"I need to tell you something... I have a strong alliance with {ally_names}.")
                                # Add false alliance information
                                for ally in fake_allies:
                                    self.add_player_information('alliance', npc, ally)
                                self.record_npc_action(npc, f"Bluff to player", f"Lied about alliance with {ally_names}")
                            else:
                                # When target is player and no valid fake allies, create a believable bluff anyway
                                # NPCs can claim they have an alliance with themselves and someone who was eliminated
                                player_tribe = self.get_player_tribe()
                                all_contestants = [c for c in self.contestants if c != npc and c != self.player]
                                if all_contestants:
                                    fake_ally = random.choice(all_contestants)
                                    self.contestant_speaks(npc, f"I need to tell you something... I have a strong alliance with {fake_ally.name}.")
                                    # Add false alliance information
                                    self.add_player_information('alliance', npc, fake_ally)
                                    self.record_npc_action(npc, f"Bluff to player", f"Lied about alliance with {fake_ally.name}")
                                else:
                                    # Last resort fallback
                                    self.contestant_speaks(npc, "I need to tell you something... I've been working on building some alliances.")
                                    self.record_npc_action(npc, f"Bluff to player", "Attempted alliance bluff but no contestants available")
                        elif bluff_type == 'previous_vote':
                            # Get list of who received votes (using authoritative game data)
                            vote_recipients = self.get_vote_recipients_from_last_tribal()
                            
                            # Find who the NPC actually voted for (using authoritative game data)
                            actual_vote_target = None
                            if hasattr(self, 'most_recent_votes') and npc in self.most_recent_votes:
                                actual_vote_target = self.most_recent_votes[npc][0]  # [0] is target, [1] is day
                            
                            # Can only bluff if someone other than the player and their actual vote received votes
                            valid_targets = [c for c in vote_recipients 
                                           if c != target 
                                           and c != npc 
                                           and c != actual_vote_target]
                            if valid_targets:
                                fake_vote = random.choice(valid_targets)
                                if fake_vote == self.player:
                                    self.contestant_speaks(npc, f"I need to tell you something... I voted for you at the last tribal council.")
                                else:
                                    self.contestant_speaks(npc, f"I need to tell you something... I voted for {fake_vote.name} at the last tribal council.")
                                # Add false information to player's info bank
                                self.add_player_information('previous_vote', npc, fake_vote)
                                self.record_npc_action(npc, f"Bluff to player", f"Lied about previous vote (claimed: {fake_vote.name}, actual: {actual_vote_target.name if actual_vote_target else 'unknown'})")
                            else:
                                # When target is player, create a bluff even if no "valid" targets from original logic
                                # NPCs can claim they voted for the player or any eliminated contestant
                                if self.day > 1:  # Only if there have been tribal councils
                                    self.contestant_speaks(npc, "I need to tell you something... I voted for you at the last tribal council.")
                                    # Add false information to player's info bank
                                    self.add_player_information('previous_vote', npc, self.player)
                                    self.record_npc_action(npc, f"Bluff to player", f"Lied about voting for player (actual vote: {actual_vote_target.name if actual_vote_target else 'unknown'})")
                                else:
                                    # Fallback only if no tribal councils have happened yet
                                    self.contestant_speaks(npc, "I need to tell you something... last tribal council was really intense.")
                                    self.record_npc_action(npc, f"Bluff to player", "Attempted previous vote bluff but no tribal councils yet")
                        elif bluff_type == 'final_2':
                            # Choose random contestants for fake Final 2 deal (excluding the player and NPC)
                            player_tribe = self.get_player_tribe()
                            potential_final2_members = [c for c in player_tribe if c != npc and c != self.player and not c.eliminated]
                            if len(potential_final2_members) >= 2:
                                final2_members = random.sample(potential_final2_members, 2)
                                self.contestant_speaks(npc, f"I need to tell you something... I heard that {final2_members[0].name} and {final2_members[1].name} have a Final 2 deal together.")
                                # Add false Final 2 information to player's info bank
                                false_info = {
                                    'type': 'final_2',
                                    'subject': final2_members[0],
                                    'target': final2_members[1],
                                    'day': self.day
                                }
                                self.player.information_bank.append(false_info)
                                self.record_npc_action(npc, f"Bluff to player", f"Lied about Final 2 deal between {final2_members[0].name} and {final2_members[1].name}")
                            else:
                                # Fallback if not enough people for Final 2 bluff
                                self.contestant_speaks(npc, "I need to tell you something... people are already starting to think about the end game.")
                                self.record_npc_action(npc, f"Bluff to player", "Attempted final 2 bluff but not enough targets")
                        else:
                            # Fallback for unknown bluff types or when no valid bluff can be made
                            self.contestant_speaks(npc, "I need to tell you something... I've been observing everyone closely.")
                            self.record_npc_action(npc, f"Bluff to player", f"Fallback bluff - type: {bluff_type}")
                        
                        # Ensure all bluff paths have spoken something
                        if not hasattr(self, '_last_speaker') or self._last_speaker != npc:
                            # Emergency fallback if somehow no dialogue was triggered
                            self.contestant_speaks(npc, "Things are getting really intense around here. People are making moves.")
                            self.record_npc_action(npc, f"Bluff to player", "Emergency fallback - generic game warning")
                        break
                    elif choice == 2:
                        self.narration(f"You politely excuse yourself from the conversation with {npc.name}.")
                        self.record_npc_action(npc, f"Bluff to player", "Player declined to listen")
                        break
                    else:
                        print("Invalid choice. Please enter 1 or 2.")
                        continue
                except ValueError:
                    print("Invalid input. Please enter a number.")
            return  # Exit after player interaction is complete
        else:
            # NPC bluffs to another NPC (no narration needed)
            # Execute the bluff (NPC to NPC)
            if bluff_type == 'vote_target':
                player_tribe = self.get_player_tribe()
                fake_targets = [c for c in player_tribe if c != npc and c != npc.vote_target and not c.eliminated]
                if fake_targets:
                    fake_target = random.choice(fake_targets)
                    target.add_information('vote_target', npc, fake_target)
                    self.record_npc_action(npc, f"Bluff to {target.name}", f"Lied about vote target (claimed: {fake_target.name})")
            elif bluff_type == 'has_idol' and not npc.has_idol:
                target.add_information('has_idol', npc)
                self.record_npc_action(npc, f"Bluff to {target.name}", "Lied about having an idol")
            elif bluff_type == 'alliance':
                player_tribe = self.get_player_tribe()
                fake_allies = random.sample([c for c in player_tribe if c != npc and not c.eliminated], 
                                          min(2, len([c for c in player_tribe if c != npc and not c.eliminated])))
                for ally in fake_allies:
                    target.add_information('alliance', npc, ally)
                if fake_allies:
                    ally_names = " and ".join([c.name for c in fake_allies])
                    self.record_npc_action(npc, f"Bluff to {target.name}", f"Lied about alliance with {ally_names}")
            elif bluff_type == 'previous_vote':
                # Get list of who received votes (using authoritative game data)
                vote_recipients = self.get_vote_recipients_from_last_tribal()
                
                # Find who the NPC actually voted for (using authoritative game data)
                actual_vote_target = None
                if hasattr(self, 'most_recent_votes') and npc in self.most_recent_votes:
                    actual_vote_target = self.most_recent_votes[npc][0]  # [0] is target, [1] is day
                
                # Can only bluff if someone other than the target and their actual vote received votes
                valid_targets = [c for c in vote_recipients 
                               if c != target 
                               and c != npc 
                               and c != actual_vote_target]
                if valid_targets:
                    fake_vote = random.choice(valid_targets)
                    target.add_information('previous_vote', npc, fake_vote)
                    target.information_bank[-1]['day'] = self.day
                    self.record_npc_action(npc, f"Bluff to {target.name}", f"Lied about previous vote (claimed: {fake_vote.name})")
            elif bluff_type == 'final_2':
                # Choose random contestants for fake Final 2 deal (excluding the NPC and target)
                player_tribe = self.get_player_tribe()
                potential_final2_members = [c for c in player_tribe if c != npc and c != target and not c.eliminated]
                if len(potential_final2_members) >= 2:
                    final2_members = random.sample(potential_final2_members, 2)
                    false_info = {
                        'type': 'final_2',
                        'subject': final2_members[0],
                        'target': final2_members[1],
                        'day': self.day
                    }
                    target.information_bank.append(false_info)
                    self.record_npc_action(npc, f"Bluff to {target.name}", f"Lied about Final 2 deal between {final2_members[0].name} and {final2_members[1].name}")
    
    def npc_bluff_targeting_you(self, npc: Contestant, target: Contestant) -> None:
        """Handle NPC bluff that someone is targeting the target."""
        # Choose someone to blame for targeting the target
        tribe = self.get_player_tribe()
        potential_blamees = [c for c in tribe if c != npc and c != target and not c.eliminated]
        
        if not potential_blamees:
            self.record_npc_action(npc, f"Bluff Targeting You to {target.name}", "No one available to blame")
            return
        
        blamee = random.choice(potential_blamees)
        
        if target.is_player:
            # NPC bluffs to player that someone is targeting them
            self.contestants_who_interacted_with_player.append(npc)
            self.narration(f"{npc.name} approaches you looking like {npc.get_pronoun('subject')} wants to share something.")
            print(f"\n{npc.name} wants to tell you something important.")
            print(f"1. Listen to what {npc.get_pronoun('subject')} has to say")
            print("2. Make an excuse and leave")
            
            while True:
                try:
                    choice = int(input("Enter your choice (1-2): "))
                    if choice == 1:
                        self.contestant_speaks(npc, f"I need to tell you something... I heard {blamee.name} is planning to vote for you.")
                        break
                    elif choice == 2:
                        self.narration(f"You politely excuse yourself from the conversation with {npc.name}.")
                        self.record_npc_action(npc, f"Bluff Targeting You to player", "Player declined to listen")
                        return
                    else:
                        print("Invalid choice. Please enter 1 or 2.")
                        continue
                except ValueError:
                    print("Invalid input. Please enter a number.")
            
            # Add false vote target information to player's bank
            self.add_player_information('vote_target', blamee, target)
            self.record_npc_action(npc, f"Bluff Targeting You to player", f"Lied that {blamee.name} is targeting player")
        else:
            # NPC bluffs to another NPC
            # Add false information to target's bank
            target.add_information('vote_target', blamee, target)
            if target.information_bank:
                target.information_bank[-1]['day'] = self.day
            
            self.record_npc_action(npc, f"Bluff Targeting You to {target.name}", f"Lied that {blamee.name} is targeting {target.name}")
    
    def npc_bluff_consensus_vote(self, npc: Contestant, target: Contestant) -> None:
        """Handle NPC bluff about consensus vote - sometimes claims target is consensus, sometimes claims others are."""
        if target.is_player:
            # Get potential consensus targets (including player and other NPCs)
            player_tribe = self.get_player_tribe()
            potential_consensus_targets = [c for c in player_tribe if not c.eliminated and c != npc]
            
            # 60% chance to claim player is consensus, 40% chance to claim someone else
            if random.random() < 0.6 or len(potential_consensus_targets) <= 1:
                # Claim player is the consensus vote
                consensus_target = self.player
                bluff_message = "I need to tell you something... word is going around that you're going to be voted out."
            else:
                # Claim someone else is the consensus vote
                other_targets = [c for c in potential_consensus_targets if c != self.player]
                consensus_target = random.choice(other_targets)
                bluff_message = f"I need to tell you something... word is going around that {consensus_target.name} is going to be voted out."
            
            # NPC bluffs to player
            self.contestants_who_interacted_with_player.append(npc)
            self.narration(f"{npc.name} approaches you looking like {npc.get_pronoun('subject')} wants to share something.")
            print(f"\n{npc.name} wants to tell you something important.")
            print(f"1. Listen to what {npc.get_pronoun('subject')} has to say")
            print("2. Make an excuse and leave")
            
            while True:
                try:
                    choice = int(input("Enter your choice (1-2): "))
                    if choice == 1:
                        self.contestant_speaks(npc, bluff_message)
                        break
                    elif choice == 2:
                        self.narration(f"You politely excuse yourself from the conversation with {npc.name}.")
                        self.record_npc_action(npc, f"Bluff Consensus Vote to player", "Player declined to listen")
                        return
                    else:
                        print("Invalid choice. Please enter 1 or 2.")
                        continue
                except ValueError:
                    print("Invalid input. Please enter a number.")
            
            # Add false consensus vote information to player's bank
            consensus_info = {
                'type': 'consensus_vote',
                'targets': [consensus_target],
                'day': self.day
            }
            self.player.information_bank.append(consensus_info)
            self.record_npc_action(npc, f"Bluff Consensus Vote to player", f"Lied that {consensus_target.name} is consensus vote")
        else:
            # NPC bluffs to another NPC about consensus vote
            # Get potential consensus targets
            npc_tribe = self.get_contestant_tribe(npc)
            potential_consensus_targets = [c for c in npc_tribe if not c.eliminated and c != npc]
            
            # 60% chance to claim target is consensus, 40% chance to claim someone else
            if random.random() < 0.6 or len(potential_consensus_targets) <= 1:
                consensus_target = target
            else:
                other_targets = [c for c in potential_consensus_targets if c != target]
                consensus_target = random.choice(other_targets) if other_targets else target
            
            # Add false consensus vote information to target's bank
            consensus_info = {
                'type': 'consensus_vote',
                'targets': [consensus_target],
                'day': self.day
            }
            target.information_bank.append(consensus_info)
            
            self.record_npc_action(npc, f"Bluff Consensus Vote to {target.name}", f"Lied that {consensus_target.name} is consensus vote")
    
    def npc_reveal(self, npc: Contestant) -> None:
        """Handle NPC reveal action."""
        # Check if NPC has any information to reveal
        if not npc.information_bank:
            self.record_npc_action(npc, "Reveal", "No information to reveal")
            return
        
        # Get weighted list of potential targets
        weighted_targets = self.get_weighted_reveal_targets(npc)
        
        if not weighted_targets:
            self.record_npc_action(npc, "Reveal", "No available targets")
            return
            
        target = random.choice(weighted_targets)
        
        # Filter out inappropriate information to reveal to this target
        appropriate_info = []
        for info in npc.information_bank:
            # Don't reveal that you're planning to vote for the person you're talking to
            if info['type'] == 'vote_target' and info.get('subject') == npc and info.get('target') == target:
                continue
            # Don't reveal that the person you're talking to is your target
            if info['type'] == 'vote_target' and info.get('target') == target:
                continue
            # Don't reveal previous votes against the person you're talking to (strategically dumb)
            if info['type'] == 'previous_vote' and info.get('subject') == npc and info.get('target') == target:
                continue
            # Don't reveal information about the player's own actions to the player
            if target.is_player and info.get('subject') == target:
                continue
            # Don't reveal alliance information where the player is the target of the alliance
            if target.is_player and info['type'] == 'alliance' and info.get('target') == target:
                continue
            appropriate_info.append(info)
        
        if not appropriate_info:
            self.record_npc_action(npc, "Reveal", "No appropriate information to reveal")
            return
            
        # Choose random information from appropriate info
        info_to_reveal = random.choice(appropriate_info)
        
        if target.is_player:
            # NPC wants to reveal to the player
            self.contestants_who_interacted_with_player.append(npc)
            self.narration(f"{npc.name} approaches you looking like {npc.get_pronoun('subject')} wants to share something.")
            print(f"\n{npc.name} wants to tell you something important.")
            print(f"1. Listen to what {npc.get_pronoun('subject')} has to say")
            print("2. Make an excuse and leave")
            
            while True:
                try:
                    choice = int(input("Enter your choice (1-2): "))
                    if choice == 1:
                        # NPC reveals information to player
                        info_text = npc.get_information_text_for_speaking(info_to_reveal, listener=self.player)
                        self.contestant_speaks(npc, f"I need to tell you something... {info_text}")
                        
                        # Add information to player's info bank (NPCs are always believed when revealing to player)
                        # Create a copy and adjust the information for the player's perspective
                        player_info = info_to_reveal.copy()
                        player_info['day'] = self.day
                        self.player.information_bank.append(player_info)
                        
                        # Check if player learned they're being targeted
                        if (player_info.get('type') in ['vote_target', 'target_roster'] and 
                            player_info.get('target') == self.player):
                            # Player learns they're being targeted (but player doesn't have game security)
                            pass
                        
                        # Check for Final 2 betrayal if player learned about a Final 2 deal
                        if player_info.get('type') == 'final_2' and player_info.get('subject') and player_info.get('target'):
                            self.check_for_final_2_betrayal(self.player, player_info.get('subject'), player_info['target'])
                        
                        self.narration(f"{npc.name} has shared valuable information with you.")
                        self.record_npc_action(npc, f"Reveal to player", f"Shared: {info_text}")
                        break
                    elif choice == 2:
                        self.narration(f"You politely excuse yourself from the conversation with {npc.name}.")
                        self.record_npc_action(npc, f"Reveal to player", "Player declined to listen")
                        break
                    else:
                        print("Invalid choice. Please enter 1 or 2.")
                except ValueError:
                    print("Invalid input. Please enter a number.")
                except EOFError:
                    print("\nInput interrupted. Declining conversation.")
                    self.record_npc_action(npc, f"Reveal to player", "Input error - conversation ended")
                    return
            return  # Exit after player interaction is complete
        else:
            # NPC reveals to another NPC (use same mechanics as player reveal)
            roll = random.randint(1, 20)
            social_bonus = npc.social_skill
            alliance_bonus = 1 if npc.believes_has_alliance_with(target, self) else 0
            relationship_bonus = 1 if npc.get_relationship(target) >= 2 else 0
            hero_bonus = 1 if npc.hero_or_villain == "Hero" else 0
            
            total_roll = roll + social_bonus + alliance_bonus + relationship_bonus + hero_bonus
            outcome = self.get_roll_outcome(total_roll)
            
            info_text = npc.get_information_text(info_to_reveal)
            
            # Handle outcomes (similar to player reveal but simplified)
            if outcome == "critical_failure":
                # Target pretends to believe but NPC gets Busted lvl 3
                self.handle_busted(npc, target, 3)
                self.record_npc_action(npc, f"Reveal to {target.name}", f"Critical Failure - Got busted lvl 3. Tried to share: {info_text}")
                
            elif outcome == "failure":
                # Target doesn't believe, NPC gets Busted lvl 1
                self.handle_busted(npc, target, 1)
                self.record_npc_action(npc, f"Reveal to {target.name}", f"Failure - Got busted lvl 1. Tried to share: {info_text}")
                
            elif outcome == "neutral":
                # Target believes and adds to info bank
                target.information_bank.append(info_to_reveal.copy())
                if target.information_bank:
                    target.information_bank[-1]['day'] = self.day
                
                # Check if NPC learned they're being targeted (for game security)
                if (info_to_reveal.get('type') == 'vote_target' and 
                    info_to_reveal.get('target') == target):
                    # NPC learned someone is targeting them
                    subject_name = info_to_reveal.get('subject').name if info_to_reveal.get('subject') else "someone"
                    target.learn_being_targeted(subject_name)
                elif (info_to_reveal.get('type') == 'vote_pitch' and 
                      info_to_reveal.get('target') == target):
                    # NPC learned someone pitched them as a target
                    subject_name = info_to_reveal.get('subject').name if info_to_reveal.get('subject') else "someone"
                    target.learn_being_targeted(subject_name)
                
                # Check for Final 2 betrayal if target learned about a Final 2 deal
                if info_to_reveal.get('type') == 'final_2' and info_to_reveal.get('subject') and info_to_reveal.get('target'):
                    # Check if the target just learned about a Final 2 deal involving the player
                    if self.player in [info_to_reveal['subject'], info_to_reveal['target']]:
                        # Check if this target believes they have a Final 2 deal with the player
                        if target.believes_has_final_2_with(self.player):
                            # Betrayal detected! Handle confrontation immediately
                            if target not in self.npcs_needing_betrayal_confrontation:
                                self.npcs_needing_betrayal_confrontation.append(target)
                                # Handle this confrontation immediately instead of waiting
                                # Figure out which contestant they learned about
                                other_contestant = info_to_reveal['target'] if info_to_reveal['subject'] == self.player else info_to_reveal['subject']
                                self.handle_immediate_confrontation(target, other_contestant)
                    
                    # Also perform the standard betrayal check
                    self.check_for_final_2_betrayal(target, info_to_reveal['subject'], info_to_reveal['target'])
                
                self.record_npc_action(npc, f"Reveal to {target.name}", f"Neutral - Shared: {info_text}")
                
            elif outcome == "success":
                # Target believes, adds to info bank, NPC gets pitch bonus
                target.information_bank.append(info_to_reveal.copy())
                if target.information_bank:
                    target.information_bank[-1]['day'] = self.day
                
                # Check if NPC learned they're being targeted (for game security)
                if (info_to_reveal.get('type') == 'vote_target' and 
                    info_to_reveal.get('target') == target):
                    # NPC learned someone is targeting them
                    subject_name = info_to_reveal.get('subject').name if info_to_reveal.get('subject') else "someone"
                    target.learn_being_targeted(subject_name)
                elif (info_to_reveal.get('type') == 'vote_pitch' and 
                      info_to_reveal.get('target') == target):
                    # NPC learned someone pitched them as a target
                    subject_name = info_to_reveal.get('subject').name if info_to_reveal.get('subject') else "someone"
                    target.learn_being_targeted(subject_name)
                
                # Check for Final 2 betrayal if target learned about a Final 2 deal
                if info_to_reveal.get('type') == 'final_2' and info_to_reveal.get('subject') and info_to_reveal.get('target'):
                    # Check if the target just learned about a Final 2 deal involving the player
                    if self.player in [info_to_reveal['subject'], info_to_reveal['target']]:
                        # Check if this target believes they have a Final 2 deal with the player
                        if target.believes_has_final_2_with(self.player):
                            # Betrayal detected! Add to confrontation list
                            if target not in self.npcs_needing_betrayal_confrontation:
                                self.npcs_needing_betrayal_confrontation.append(target)
                    
                    # Also perform the standard betrayal check
                    self.check_for_final_2_betrayal(target, info_to_reveal['subject'], info_to_reveal['target'])
                
                # Add reveal bonus for NPCs too
                if not hasattr(self, 'npc_reveal_bonuses'):
                    self.npc_reveal_bonuses = {}
                self.npc_reveal_bonuses[(npc, target)] = self.day + 2
                
                self.record_npc_action(npc, f"Reveal to {target.name}", f"Success - Shared: {info_text}, gained pitch bonus")
                
            else:  # critical_success
                # All success benefits + remove NPC from target's vote target/roster
                target.information_bank.append(info_to_reveal.copy())
                if target.information_bank:
                    target.information_bank[-1]['day'] = self.day
                
                # Check if NPC learned they're being targeted (for game security)
                if (info_to_reveal.get('type') == 'vote_target' and 
                    info_to_reveal.get('target') == target):
                    # NPC learned someone is targeting them
                    subject_name = info_to_reveal.get('subject').name if info_to_reveal.get('subject') else "someone"
                    target.learn_being_targeted(subject_name)
                elif (info_to_reveal.get('type') == 'vote_pitch' and 
                      info_to_reveal.get('target') == target):
                    # NPC learned someone pitched them as a target
                    subject_name = info_to_reveal.get('subject').name if info_to_reveal.get('subject') else "someone"
                    target.learn_being_targeted(subject_name)
                
                # Check for Final 2 betrayal if target learned about a Final 2 deal
                if info_to_reveal.get('type') == 'final_2' and info_to_reveal.get('subject') and info_to_reveal.get('target'):
                    # Check if the target just learned about a Final 2 deal involving the player
                    if self.player in [info_to_reveal['subject'], info_to_reveal['target']]:
                        # Check if this target believes they have a Final 2 deal with the player
                        if target.believes_has_final_2_with(self.player):
                            # Betrayal detected! Add to confrontation list
                            if target not in self.npcs_needing_betrayal_confrontation:
                                self.npcs_needing_betrayal_confrontation.append(target)
                    
                    # Also perform the standard betrayal check
                    self.check_for_final_2_betrayal(target, info_to_reveal['subject'], info_to_reveal['target'])
                
                # Add reveal bonus
                if not hasattr(self, 'npc_reveal_bonuses'):
                    self.npc_reveal_bonuses = {}
                self.npc_reveal_bonuses[(npc, target)] = self.day + 2
                
                # Remove NPC from target's vote target and target roster
                if target.vote_target == npc:
                    self.assign_random_vote_target(target)
                target.target_roster = [c for c in target.target_roster if c != npc]
                
                self.record_npc_action(npc, f"Reveal to {target.name}", f"Critical Success - Shared: {info_text}, gained pitch bonus, removed from targeting")
    
    def npc_work_around_camp(self, npc: Contestant) -> None:
        """Handle NPC work around camp action."""
        # Update work streaks
        npc.consecutive_work_days += 1
        npc.consecutive_no_work_days = 0
        npc.worked_today = True
        
        # Determine survival bonus based on hero/villain status
        survival_bonus = 2 if npc.hero_or_villain == "Hero" else 1
        
        # Apply survival bonus to all tribemates for tomorrow
        npc_tribe = self.get_active_contestants(npc.tribe)
        bonus_count = 0
        for contestant in npc_tribe:
            if contestant != npc and not contestant.eliminated:
                contestant.work_bonus_tomorrow = survival_bonus
                bonus_count += 1
        
        hero_text = " (Hero bonus)" if survival_bonus == 2 else ""
        self.record_npc_action(npc, "Work Around Camp", f"Provided +{survival_bonus} survival bonus{hero_text} to {bonus_count} tribemates for tomorrow")
    
    def npc_focus_on_survival(self, npc: Contestant) -> None:
        """Handle NPC focus on survival action."""
        # Random survival activities (same as player)
        survival_activities = [
            "cooking a pot of rice and eating",
            "gathering coconuts for refreshing coconut water",
            "improving the shelter for better comfort"
        ]
        
        # Choose random activity for logging
        chosen_activity = random.choice(survival_activities)
        
        # Improve survival status by 1 (clamped between -1 and 3)
        old_status = npc.survival_status
        npc.survival_status = min(3, npc.survival_status + 1)
        new_status = npc.survival_status
        
        # Track that NPC focused on survival today
        npc.focused_on_survival_today = True
        
        status_text = f" (survival status: {old_status} → {new_status})" if new_status > old_status else f" (survival status: {old_status})"
        self.record_npc_action(npc, "Focus on Survival", f"Spent time {chosen_activity}{status_text}")
    
    def npc_probe(self, npc: Contestant, probe_type: str = "general") -> None:
        """Handle NPC probe action - trying to gather information about targets.
        probe_type can be: 'general', 'vote_target', or 'consensus_vote'"""
        # Get weighted list of potential targets
        weighted_targets = self.get_weighted_probe_targets(npc)
        
        if not weighted_targets:
            action_name = f"Probe ({probe_type})"
            self.record_npc_action(npc, action_name, "No available targets")
            return
            
        target = random.choice(weighted_targets)
        
        if target.is_player:
            # NPC wants to probe the player
            self.contestants_who_interacted_with_player.append(npc)
            
            # Different dialogue based on probe type
            if probe_type == "vote_target":
                self.narration(f"{npc.name} approaches you with a serious expression.")
                self.contestant_speaks(npc, "Can I ask you something? Who are you planning on voting for?")
            elif probe_type == "consensus_vote":
                self.narration(f"{npc.name} approaches you with a curious expression.")
                self.contestant_speaks(npc, "Can I ask you something? Do you know who is getting voted out next?")
            else:  # general - no dialogue, just narration
                self.narration(f"{npc.name} approaches you with a curious expression.")
                self.narration(f"You chat with {npc.name} for a few minutes, but it seems like {npc.get_pronoun('subject')} is fishing for information.")
            
            print("How do you respond?")
            print("1. Share information honestly")
            print("2. Give misleading information")
            print("3. Give a vague, non-committal response")
            
            while True:
                try:
                    choice = int(input("Enter your choice (1-3): "))
                    if choice in [1, 2, 3]:
                        # Player agrees to engage
                        # Handle the chosen response
                        response_completed = False
                        if choice == 1:
                            # Let player choose what honest information to share
                            response_completed = self.handle_honest_probe_response(npc, probe_type)
                        elif choice == 2:
                            # Let player choose what false information to share
                            response_completed = self.handle_bluff_probe_response(npc, probe_type)
                        elif choice == 3:
                            # Give vague response
                            if probe_type == "vote_target":
                                vague_responses = [
                                    "I'm still thinking about it. There are a few people I'm considering.",
                                    "It's hard to say right now. I want to see how things play out.",
                                    "I haven't made up my mind yet. What about you?",
                                    "I'm keeping my options open for now."
                                ]
                            elif probe_type == "consensus_vote":
                                vague_responses = [
                                    "It's hard to tell. Everyone's being pretty tight-lipped.",
                                    "I think there are a few names being thrown around, but nothing concrete.",
                                    "Your guess is as good as mine. The tribe's pretty divided.",
                                    "I'm not sure. What are you hearing?"
                                ]
                            else:  # general
                                vague_responses = [
                                    "Things are going okay, I guess. Just taking it day by day.",
                                    "It's hard to say. Everyone seems to be playing their own game.",
                                    "I'm still figuring things out. This game is more complex than I expected.",
                                    "I'm trying to stay focused on the challenges and not overthink things."
                                ]
                            self.contestant_speaks(self.player, random.choice(vague_responses))
                            self.narration("You give a diplomatic, non-committal answer that doesn't reveal much.")
                            # Apply temporary -1 persuasion penalty through end of next day
                            self.apply_temporary_persuasion_modifier(self.player, npc, -1, 2)
                            action_name = f"Probe player ({probe_type})"
                            self.record_npc_action(npc, action_name, "Player gave vague response")
                            response_completed = True
                        
                        if response_completed:
                            break
                            
                    else:
                        print("Invalid choice. Please enter 1, 2, or 3.")
                        continue
                except ValueError:
                    print("Invalid input. Please enter a number.")
            return  # Exit after player interaction is complete
        else:
            # NPC probes another NPC - use new response system
            self.handle_npc_to_npc_probe(npc, target, probe_type)
    
    def handle_npc_to_npc_probe(self, prober: Contestant, target: Contestant, probe_type: str = "general") -> None:
        """Handle NPC-to-NPC probe interactions using the new response system."""
        action_name = f"Probe {target.name} ({probe_type})"
        
        # Target NPC chooses how to respond based on their personality and relationship
        response_type = self.determine_npc_probe_response(prober, target, probe_type)
        
        if response_type == "honest":
            self.handle_npc_honest_response(prober, target, probe_type, action_name)
        elif response_type == "bluff":
            self.handle_npc_bluff_response(prober, target, probe_type, action_name)
        else:  # vague
            self.handle_npc_vague_response(prober, target, probe_type, action_name)
    
    def determine_npc_probe_response(self, prober: Contestant, target: Contestant, probe_type: str) -> str:
        """Determine how an NPC responds to being probed by another NPC."""
        relationship = target.get_relationship(prober)
        
        # Base probabilities
        honest_weight = 30
        bluff_weight = 35
        vague_weight = 35
        
        # Relationship modifiers
        if relationship >= 3:  # Very good relationship
            honest_weight += 40
            vague_weight -= 20
        elif relationship >= 1:  # Good relationship
            honest_weight += 20
            vague_weight -= 10
        elif relationship <= -1:  # Bad relationship
            bluff_weight += 30
            honest_weight -= 20
        
        # Alliance modifiers
        if target.has_real_alliance_with(prober):
            honest_weight += 30
            bluff_weight -= 15
        elif target.has_fake_alliance_with(prober):
            bluff_weight += 25
            honest_weight -= 10
        
        # If target doesn't have relevant information, more likely to be honest about it
        has_relevant_info = self.npc_has_relevant_info(target, probe_type)
        if not has_relevant_info:
            honest_weight += 20
            bluff_weight -= 10
        
        # Choose response based on weights
        total = honest_weight + bluff_weight + vague_weight
        roll = random.randint(1, total)
        
        if roll <= honest_weight:
            return "honest"
        elif roll <= honest_weight + bluff_weight:
            return "bluff"
        else:
            return "vague"
    
    def npc_has_relevant_info(self, npc: Contestant, probe_type: str) -> bool:
        """Check if an NPC has relevant information for the probe type."""
        if probe_type == "vote_target":
            return npc.vote_target is not None
        elif probe_type == "consensus_vote":
            return any(info['type'] == 'consensus_vote' for info in npc.information_bank)
        else:  # general
            return len(npc.information_bank) > 0
    
    def handle_npc_honest_response(self, prober: Contestant, target: Contestant, probe_type: str, action_name: str) -> None:
        """Handle when target NPC responds honestly to a probe."""
        # Target gets +1 persuasion bonus with prober
        self.apply_temporary_persuasion_modifier(target, prober, 1, 2)
        prober.modify_relationship(target, 1)
        
        if probe_type == "vote_target":
            if target.vote_target:
                prober.add_information('vote_target', target, target.vote_target)
                if prober.information_bank:
                    prober.information_bank[-1]['day'] = self.day
                self.record_npc_action(prober, action_name, f"Target honestly revealed vote target: {target.vote_target.name}")
            else:
                self.record_npc_action(prober, action_name, "Target honestly said they haven't decided vote target")
        elif probe_type == "consensus_vote":
            consensus_info = [info for info in target.information_bank if info['type'] == 'consensus_vote']
            if consensus_info:
                latest_consensus = consensus_info[-1]
                prober.add_information('consensus_vote', None, None)
                if 'targets' in latest_consensus:
                    prober.information_bank[-1]['targets'] = latest_consensus['targets']
                prober.information_bank[-1]['day'] = self.day
                self.record_npc_action(prober, action_name, "Target shared consensus vote information")
            else:
                self.record_npc_action(prober, action_name, "Target honestly said they don't know consensus")
        else:  # general
            if target.information_bank:
                shared_info = random.choice(target.information_bank)
                if shared_info['type'] == 'consensus_vote':
                    prober.add_information(shared_info['type'], shared_info.get('subject'), shared_info.get('target'), source=target)
                    if prober.information_bank and 'targets' in shared_info:
                        prober.information_bank[-1]['targets'] = shared_info['targets']
                        prober.information_bank[-1]['day'] = self.day
                else:
                    prober.add_information(shared_info['type'], shared_info.get('subject'), shared_info.get('target'), source=target)
                    if prober.information_bank:
                        prober.information_bank[-1]['day'] = self.day
                self.record_npc_action(prober, action_name, f"Target honestly shared information about {shared_info.get('type', 'unknown')}")
                
                # Check for Final 2 betrayal
                if shared_info.get('type') == 'final_2' and shared_info.get('subject') and shared_info.get('target'):
                    if self.player in [shared_info.get('subject'), shared_info['target']]:
                        if prober.believes_has_final_2_with(self.player):
                            if prober not in self.npcs_needing_betrayal_confrontation:
                                self.npcs_needing_betrayal_confrontation.append(prober)
                                other_contestant = shared_info['target'] if shared_info.get('subject') == self.player else shared_info.get('subject')
                                self.handle_immediate_confrontation(prober, other_contestant)
                    self.check_for_final_2_betrayal(prober, shared_info.get('subject'), shared_info['target'])
            else:
                self.record_npc_action(prober, action_name, "Target honestly said they have no information")
    
    def handle_npc_bluff_response(self, prober: Contestant, target: Contestant, probe_type: str, action_name: str) -> None:
        """Handle when target NPC tries to bluff in response to a probe."""
        # Roll d20 + social skill to see if bluff succeeds
        roll = random.randint(1, 20)
        total_roll = roll + target.social_skill
        
        if total_roll >= 11:  # 11-20: Prober believes the bluff
            # Target gets +1 persuasion bonus with prober
            self.apply_temporary_persuasion_modifier(target, prober, 1, 2)
            
            # Generate and share false information
            if probe_type == "vote_target":
                fake_target = self.generate_fake_vote_target(target, prober)
                if fake_target:
                    prober.add_information('vote_target', target, fake_target)
                    if prober.information_bank:
                        prober.information_bank[-1]['day'] = self.day
                    self.record_npc_action(prober, action_name, f"Target lied about vote target: claimed {fake_target.name} (bluff succeeded: {roll}+{target.social_skill}={total_roll})")
            elif probe_type == "consensus_vote":
                fake_consensus = self.generate_fake_consensus(target, prober)
                if fake_consensus:
                    prober.add_information('consensus_vote', None, None)
                    prober.information_bank[-1]['targets'] = [fake_consensus]
                    prober.information_bank[-1]['day'] = self.day
                    self.record_npc_action(prober, action_name, f"Target lied about consensus: claimed {fake_consensus.name} (bluff succeeded: {roll}+{target.social_skill}={total_roll})")
            else:  # general
                fake_info = self.generate_fake_general_info(target, prober)
                if fake_info:
                    prober.add_information(fake_info['type'], fake_info.get('subject'), fake_info.get('target'), source=target)
                    if prober.information_bank:
                        prober.information_bank[-1]['day'] = self.day
                    self.record_npc_action(prober, action_name, f"Target shared fake information about {fake_info['type']} (bluff succeeded: {roll}+{target.social_skill}={total_roll})")
        else:  # 1-10: Prober catches the bluff
            # Apply Busted Level 2 consequences
            self.handle_busted(target, prober, 2)
            self.record_npc_action(prober, action_name, f"Target tried to lie but was caught (bluff failed: {roll}+{target.social_skill}={total_roll}, Busted Lvl 2)")
    
    def handle_npc_vague_response(self, prober: Contestant, target: Contestant, probe_type: str, action_name: str) -> None:
        """Handle when target NPC gives a vague response to a probe."""
        # Target gets -1 persuasion penalty with prober
        self.apply_temporary_persuasion_modifier(target, prober, -1, 2)
        self.record_npc_action(prober, action_name, "Target gave vague response")
    
    def generate_fake_vote_target(self, target: Contestant, prober: Contestant) -> Optional[Contestant]:
        """Generate a fake vote target for bluffing."""
        tribe = self.get_contestant_tribe(target)
        potential_fake_targets = [c for c in tribe if c != target and c != prober and not c.eliminated]
        return random.choice(potential_fake_targets) if potential_fake_targets else None
    
    def generate_fake_consensus(self, target: Contestant, prober: Contestant) -> Optional[Contestant]:
        """Generate a fake consensus target for bluffing."""
        tribe = self.get_contestant_tribe(target)
        potential_fake_consensus = [c for c in tribe if c != target and not c.eliminated]
        return random.choice(potential_fake_consensus) if potential_fake_consensus else None
    
    def generate_fake_general_info(self, target: Contestant, prober: Contestant) -> Optional[Dict]:
        """Generate fake general information for bluffing."""
        tribe = self.get_contestant_tribe(target)
        potential_subjects = [c for c in tribe if c != target and c != prober and not c.eliminated]
        
        if not potential_subjects:
            return None
        
        fake_subject = random.choice(potential_subjects)
        info_types = ['vote_target', 'alliance', 'idol']
        fake_type = random.choice(info_types)
        
        if fake_type == 'vote_target':
            potential_targets = [c for c in tribe if c != fake_subject and not c.eliminated]
            if potential_targets:
                fake_target = random.choice(potential_targets)
                return {'type': 'vote_target', 'subject': fake_subject, 'target': fake_target}
        elif fake_type == 'alliance':
            potential_allies = [c for c in tribe if c != fake_subject and c != target and not c.eliminated]
            if potential_allies:
                fake_ally = random.choice(potential_allies)
                return {'type': 'alliance', 'subject': fake_subject, 'target': fake_ally}
        elif fake_type == 'idol':
            return {'type': 'idol', 'subject': fake_subject, 'target': None}
        
        return None

    def handle_honest_probe_response(self, npc: Contestant, probe_type: str = "general") -> bool:
        """Handle when player chooses to share honest information during probe.
        Returns True if action was completed, False if player backed out."""
        action_name = f"Probe player ({probe_type})"
        
        if probe_type == "vote_target":
            # Player is asked who they're voting for - answer based on assigned vote target
            if self.player.vote_target:
                if self.player.vote_target == npc:
                    self.contestant_speaks(self.player, "I'm planning to vote for you.")
                else:
                    self.contestant_speaks(self.player, f"I'm planning to vote for {self.player.vote_target.name}.")
                self.add_information_with_day(npc, 'vote_target', self.player, self.player.vote_target)
                npc.modify_relationship(self.player, 1)
                # Apply temporary +1 persuasion bonus through end of next day
                self.apply_temporary_persuasion_modifier(self.player, npc, 1, 2)
                self.record_npc_action(npc, action_name, f"Player honestly revealed vote target: {self.player.vote_target.name}")
            else:
                # Player has no vote target
                if self.day >= 3:
                    # This shouldn't happen after day 2, but handle it gracefully
                    self.contestant_speaks(self.player, "Honestly, I haven't decided who to vote for yet.")
                    npc.modify_relationship(self.player, 1)
                    # Apply temporary +1 persuasion bonus through end of next day
                    self.apply_temporary_persuasion_modifier(self.player, npc, 1, 2)
                    self.record_npc_action(npc, action_name, "Player honestly said they haven't decided vote target")
                    # Prompt player to set vote target immediately
                    self.prompt_player_vote_target("Since you were just asked about your vote target, who are you planning to vote for?")
                else:
                    self.contestant_speaks(self.player, "Honestly, I haven't decided who to vote for yet.")
                    npc.modify_relationship(self.player, 1)
                    # Apply temporary +1 persuasion bonus through end of next day
                    self.apply_temporary_persuasion_modifier(self.player, npc, 1, 2)
                    self.record_npc_action(npc, action_name, "Player honestly said they haven't decided vote target")
            return True
        
        elif probe_type == "consensus_vote":
            # Player is asked about consensus vote - let them choose what to share
            # Fall through to general probe handling
            pass
        
        # General probe - original logic
        if not self.player.information_bank:
            # Player has no information to share
            honest_responses = [
                "Honestly, I don't really know much about what's going on.",
                "I've been trying to stay out of the drama and just focus on the game.",
                "I haven't really picked up on anything specific yet."
            ]
            self.contestant_speaks(self.player, random.choice(honest_responses))
            self.narration("You're genuinely honest about not having much information.")
            npc.modify_relationship(self.player, 1)
            # Apply temporary +1 persuasion bonus through end of next day
            self.apply_temporary_persuasion_modifier(self.player, npc, 1, 2)
            self.record_npc_action(npc, action_name, "Player answered honestly (no info), gained relationship")
            return True
        
        # Let player choose what information to share
        print("\nWhat information would you like to share?")
        shareable_info = []
        
        for i, info in enumerate(self.player.information_bank):
            info_text = self.player.get_information_text_for_speaking(info, listener=npc)
            # Don't share info about the person asking or alliance info where they are the target
            if (info_text and 
                info.get('subject') != npc and 
                not (info['type'] == 'alliance' and info.get('target') == npc)):
                shareable_info.append((info, info_text))
        
        if not shareable_info:
            print("1. You don't have any relevant information to share")
            print("2. Back to response options")
        else:
            for i, (info, text) in enumerate(shareable_info, 1):
                print(f"{i}. {text}")
            print(f"{len(shareable_info) + 1}. Back to response options")
        
        while True:
            try:
                choice = int(input("Enter your choice: "))
                if shareable_info and choice <= len(shareable_info) and choice >= 1:
                    # Share the selected information
                    selected_info, info_text = shareable_info[choice - 1]
                    self.contestant_speaks(self.player, info_text)
                    
                    # Add information to NPC's knowledge
                    if selected_info['type'] == 'consensus_vote':
                        # Special handling for consensus vote info
                        npc.add_information(selected_info['type'], selected_info.get('subject'), selected_info.get('target'), source=self.player)
                        if npc.information_bank and 'targets' in selected_info:
                            npc.information_bank[-1]['targets'] = selected_info['targets']
                            npc.information_bank[-1]['day'] = self.day
                    else:
                        # Check if the selected info has required fields
                        if 'subject' in selected_info:
                            npc.add_information(selected_info['type'], selected_info.get('subject'), selected_info.get('target'), source=self.player)
                            if npc.information_bank:
                                npc.information_bank[-1]['day'] = self.day
                        else:
                            # Handle information that doesn't have a subject (like general observations)
                            new_info = selected_info.copy()
                            new_info['day'] = self.day
                            npc.information_bank.append(new_info)
                    
                    self.narration("You share what you know honestly.")
                    npc.modify_relationship(self.player, 2)  # Bonus for sharing valuable info
                    self.record_npc_action(npc, f"Probe player", "Player shared valuable information, gained strong relationship")
                    return True
                elif not shareable_info and choice == 1:
                    # No shareable info - option 1 is "don't have relevant info"
                    self.contestant_speaks(self.player, "I wish I had something useful to tell you, but I really don't know much.")
                    self.narration("You're honest about not having useful information.")
                    npc.modify_relationship(self.player, 1)
                    # Apply temporary +1 persuasion bonus through end of next day
                    self.apply_temporary_persuasion_modifier(self.player, npc, 1, 2)
                    self.record_npc_action(npc, f"Probe player", "Player answered honestly (no useful info), gained relationship")
                    return True
                elif not shareable_info and choice == 2:
                    # No shareable info - option 2 is "back"
                    return False
                elif shareable_info and choice == len(shareable_info) + 1:
                    # Has shareable info - go back to response options
                    return False
                else:
                    if not shareable_info:
                        print("Invalid choice. Please enter 1 or 2.")
                    else:
                        print(f"Invalid choice. Please enter 1-{len(shareable_info) + 2}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    def handle_bluff_probe_response(self, npc: Contestant, probe_type: str = "general") -> bool:
        """Handle when player chooses to give misleading information during probe.
        Returns True if action was completed, False if player backed out."""
        action_name = f"Probe player ({probe_type})"
        
        if probe_type == "vote_target":
            # Player is asked who they're voting for - lie about it
            player_tribe = self.get_player_tribe()
            potential_fake_targets = [c for c in player_tribe if c != self.player and c != npc and not c.eliminated]
            
            if not potential_fake_targets:
                self.contestant_speaks(self.player, "I haven't decided who to vote for yet.")
                self.record_npc_action(npc, action_name, "Player claimed they haven't decided (lie)")
                return True
            
            print("\nWho would you like to claim you're voting for?")
            for i, contestant in enumerate(potential_fake_targets, 1):
                print(f"{i}. {contestant.name}")
            
            while True:
                try:
                    choice = int(input("Enter your choice: "))
                    if 1 <= choice <= len(potential_fake_targets):
                        fake_target = potential_fake_targets[choice - 1]
                        if fake_target == npc:
                            self.contestant_speaks(self.player, "I'm planning to vote for you.")
                        else:
                            self.contestant_speaks(self.player, f"I'm planning to vote for {fake_target.name}.")
                        
                        # Roll d20 + social skill to see if bluff succeeds
                        roll = random.randint(1, 20)
                        total_roll = roll + self.player.social_skill
                        
                        if total_roll >= 11:  # 11-20: NPC believes the bluff
                            self.add_information_with_day(npc, 'vote_target', self.player, fake_target)
                            # Apply temporary +1 persuasion bonus through end of next day
                            self.apply_temporary_persuasion_modifier(self.player, npc, 1, 2)
                            self.narration(f"Your bluff succeeds. {npc.name} believes you.")
                            self.record_npc_action(npc, action_name, f"Player lied about vote target: claimed {fake_target.name} (bluff succeeded: {roll}+{self.player.social_skill}={total_roll})")
                        else:  # 1-10: NPC catches the bluff
                            self.narration(f"Your bluff fails. {npc.name} catches you lying.")
                            self.contestant_speaks(npc, "I don't believe you. I think you're lying to me.")
                            # Apply Busted Level 2 consequences
                            self.handle_busted(self.player, npc, 2)
                            self.record_npc_action(npc, action_name, f"Player lied about vote target: claimed {fake_target.name} (bluff failed: {roll}+{self.player.social_skill}={total_roll}, Busted Lvl 2)")
                        return True
                    else:
                        print("Invalid choice. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter a number.")
        
        elif probe_type == "consensus_vote":
            # Player is asked about consensus vote - lie about it
            player_tribe = self.get_player_tribe()
            potential_fake_consensus = [c for c in player_tribe if c != self.player and not c.eliminated]
            
            if not potential_fake_consensus:
                self.contestant_speaks(self.player, "I honestly don't know. Everyone's being pretty secretive.")
                
                # Roll d20 + social skill to see if bluff succeeds
                roll = random.randint(1, 20)
                total_roll = roll + self.player.social_skill
                
                if total_roll >= 11:  # 11-20: NPC believes the bluff
                    # Apply temporary +1 persuasion bonus through end of next day
                    self.apply_temporary_persuasion_modifier(self.player, npc, 1, 2)
                    self.narration(f"Your bluff succeeds. {npc.name} believes you don't know.")
                    self.record_npc_action(npc, action_name, f"Player claimed they don't know consensus (bluff succeeded: {roll}+{self.player.social_skill}={total_roll})")
                else:  # 1-10: NPC catches the bluff
                    self.narration(f"Your bluff fails. {npc.name} suspects you're hiding something.")
                    self.contestant_speaks(npc, "I think you know more than you're letting on.")
                    # Apply Busted Level 2 consequences
                    self.handle_busted(self.player, npc, 2)
                    self.record_npc_action(npc, action_name, f"Player claimed they don't know consensus (bluff failed: {roll}+{self.player.social_skill}={total_roll}, Busted Lvl 2)")
                return True
            
            print("\nWho would you like to claim is getting voted out next?")
            for i, contestant in enumerate(potential_fake_consensus, 1):
                print(f"{i}. {contestant.name}")
            print(f"{len(potential_fake_consensus) + 1}. Claim you don't know")
            
            while True:
                try:
                    choice = int(input("Enter your choice: "))
                    if 1 <= choice <= len(potential_fake_consensus):
                        fake_consensus = potential_fake_consensus[choice - 1]
                        if fake_consensus == npc:
                            self.contestant_speaks(self.player, f"From what I've heard, you're getting voted out next.")
                        elif fake_consensus == self.player:
                            self.contestant_speaks(self.player, f"From what I've heard, I'm getting voted out next.")
                        else:
                            self.contestant_speaks(self.player, f"From what I've heard, {fake_consensus.name} is getting voted out next.")
                        
                        # Roll d20 + social skill to see if bluff succeeds
                        roll = random.randint(1, 20)
                        total_roll = roll + self.player.social_skill
                        
                        if total_roll >= 11:  # 11-20: NPC believes the bluff
                            self.add_information_with_day(npc, 'consensus_vote', None, None)
                            npc.information_bank[-1]['targets'] = [fake_consensus]
                            # Apply temporary +1 persuasion bonus through end of next day
                            self.apply_temporary_persuasion_modifier(self.player, npc, 1, 2)
                            self.narration(f"Your bluff succeeds. {npc.name} believes you.")
                            self.record_npc_action(npc, action_name, f"Player lied about consensus: claimed {fake_consensus.name} (bluff succeeded: {roll}+{self.player.social_skill}={total_roll})")
                        else:  # 1-10: NPC catches the bluff
                            self.narration(f"Your bluff fails. {npc.name} catches you lying.")
                            self.contestant_speaks(npc, "I don't think that's true. I think you're making that up.")
                            # Apply Busted Level 2 consequences
                            self.handle_busted(self.player, npc, 2)
                            self.record_npc_action(npc, action_name, f"Player lied about consensus: claimed {fake_consensus.name} (bluff failed: {roll}+{self.player.social_skill}={total_roll}, Busted Lvl 2)")
                        return True
                    elif choice == len(potential_fake_consensus) + 1:
                        self.contestant_speaks(self.player, "I honestly don't know. Everyone's being pretty secretive.")
                        
                        # Roll d20 + social skill to see if bluff succeeds
                        roll = random.randint(1, 20)
                        total_roll = roll + self.player.social_skill
                        
                        if total_roll >= 11:  # 11-20: NPC believes the bluff
                            # Apply temporary +1 persuasion bonus through end of next day
                            self.apply_temporary_persuasion_modifier(self.player, npc, 1, 2)
                            self.narration(f"Your bluff succeeds. {npc.name} believes you don't know.")
                            self.record_npc_action(npc, action_name, f"Player claimed they don't know consensus (bluff succeeded: {roll}+{self.player.social_skill}={total_roll})")
                        else:  # 1-10: NPC catches the bluff
                            self.narration(f"Your bluff fails. {npc.name} suspects you're hiding something.")
                            self.contestant_speaks(npc, "I think you know more than you're letting on.")
                            # Apply Busted Level 2 consequences
                            self.handle_busted(self.player, npc, 2)
                            self.record_npc_action(npc, action_name, f"Player claimed they don't know consensus (bluff failed: {roll}+{self.player.social_skill}={total_roll}, Busted Lvl 2)")
                        return True
                    else:
                        print("Invalid choice. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter a number.")
        
        # General probe - original bluff options
        print("\nWhat false information would you like to share?")
        print("1. Lie about someone's vote target")
        print("2. Lie about someone having an idol")
        print("3. Lie about an alliance between two people")
        print("4. Lie about the consensus vote")
        print("5. Back to response options")
        
        while True:
            try:
                choice = int(input("Enter your choice (1-5): "))
                if choice == 1:
                    self.bluff_vote_target_to_npc(npc)
                    return True
                elif choice == 2:
                    self.bluff_idol_to_npc(npc)
                    return True
                elif choice == 3:
                    self.bluff_alliance_to_npc(npc)
                    return True
                elif choice == 4:
                    self.bluff_consensus_vote_to_npc(npc)
                    return True
                elif choice == 5:
                    return False  # Go back to response options
                else:
                    print("Invalid choice. Please enter 1, 2, 3, 4, or 5.")
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    def handle_deflection_response(self, npc: Contestant) -> None:
        """Handle when player deflects and gains information from NPC."""
        # NPC responds with some information
        if npc.information_bank:
            # Share something the NPC knows
            info_to_share = random.choice(npc.information_bank)
            response_text = npc.get_information_text_for_speaking(info_to_share, listener=self.player)
            
            if response_text and info_to_share['subject'] != self.player:
                self.contestant_speaks(npc, response_text)
                # Add info to player's knowledge
                self.player.add_information(info_to_share['type'], info_to_share['subject'], info_to_share.get('target'))
                if self.player.information_bank:
                    self.player.information_bank[-1]['day'] = self.day
                self.narration(f"You learn something interesting from {npc.name}.")
            else:
                # Fallback response
                deflection_responses = [
                    "Things are pretty intense out here. Everyone's playing hard.",
                    "I'm just trying to take it one day at a time, you know?",
                    "There's definitely a lot going on beneath the surface.",
                    "I think we're all feeling the pressure as we get deeper into the game."
                ]
                self.contestant_speaks(npc, random.choice(deflection_responses))
                self.narration(f"{npc.name} gives a diplomatic response but you don't learn anything specific.")
        else:
            # NPC has no information to share
            deflection_responses = [
                "Honestly, I'm just trying to focus on getting through each day.",
                "It's hard to keep track of everything that's happening.",
                "I'm probably not the best person to ask - I've been keeping to myself.",
                "I don't really know. What made you think I would have insights?"
            ]
            self.contestant_speaks(npc, random.choice(deflection_responses))
            self.narration(f"{npc.name} doesn't seem to have much to share.")
    
    def bluff_vote_target_to_npc(self, npc: Contestant) -> None:
        """Player bluffs about someone's vote target to an NPC."""
        player_tribe = self.get_player_tribe()
        potential_subjects = [c for c in player_tribe if c != npc and c != self.player]
        
        if not potential_subjects:
            self.contestant_speaks(self.player, "I don't really have any insights about voting plans.")
            self.narration("You give a non-committal response.")
            return
        
        # Let player choose who they want to lie about
        print("\nWho do you want to claim is planning to vote?")
        for i, contestant in enumerate(potential_subjects, 1):
            print(f"{i}. {contestant.name}")
        print(f"{len(potential_subjects) + 1}. Cancel")
        
        while True:
            try:
                choice = int(input(f"Enter your choice (1-{len(potential_subjects) + 1}): "))
                if 1 <= choice <= len(potential_subjects):
                    subject = potential_subjects[choice - 1]
                    break
                elif choice == len(potential_subjects) + 1:
                    return  # Cancel
                else:
                    print(f"Please enter a number between 1 and {len(potential_subjects) + 1}.")
            except ValueError:
                print("Please enter a valid number.")
        
        potential_targets = [c for c in player_tribe if c != subject and c != self.player]
        
        if not potential_targets:
            self.contestant_speaks(self.player, "I don't really have any insights about voting plans.")
            self.narration("You give a non-committal response.")
            return
        
        # Let player choose the target
        print(f"\nWho do you want to claim {subject.name} is targeting?")
        for i, contestant in enumerate(potential_targets, 1):
            print(f"{i}. {contestant.name}")
        print(f"{len(potential_targets) + 1}. Cancel")
        
        while True:
            try:
                choice = int(input(f"Enter your choice (1-{len(potential_targets) + 1}): "))
                if 1 <= choice <= len(potential_targets):
                    target = potential_targets[choice - 1]
                    break
                elif choice == len(potential_targets) + 1:
                    return  # Cancel
                else:
                    print(f"Please enter a number between 1 and {len(potential_targets) + 1}.")
            except ValueError:
                print("Please enter a valid number.")
        
        if target == npc:
            self.contestant_speaks(self.player, f"I heard {subject.name} is planning to vote for you.")
        else:
            self.contestant_speaks(self.player, f"I heard {subject.name} is planning to vote for {target.name}.")
        npc.add_information('vote_target', subject, target)
        if npc.information_bank:
            npc.information_bank[-1]['day'] = self.day
        self.narration(f"You share false information to mislead {npc.get_pronoun('object')}.")
        self.record_npc_action(npc, f"Probe player", "Player bluffed about vote target")
    
    def bluff_idol_to_npc(self, npc: Contestant) -> None:
        """Player bluffs about someone having an idol to an NPC."""
        player_tribe = self.get_player_tribe()
        potential_subjects = [c for c in player_tribe if c != npc and c != self.player]
        
        if not potential_subjects:
            self.contestant_speaks(self.player, "I don't have any information about idols.")
            self.narration("You give a non-committal response.")
            return
        
        # Let player choose who they want to lie about
        print("\nWho do you want to claim has the hidden immunity idol?")
        for i, contestant in enumerate(potential_subjects, 1):
            print(f"{i}. {contestant.name}")
        print(f"{len(potential_subjects) + 1}. Cancel")
        
        while True:
            try:
                choice = int(input(f"Enter your choice (1-{len(potential_subjects) + 1}): "))
                if 1 <= choice <= len(potential_subjects):
                    subject = potential_subjects[choice - 1]
                    break
                elif choice == len(potential_subjects) + 1:
                    return  # Cancel
                else:
                    print(f"Please enter a number between 1 and {len(potential_subjects) + 1}.")
            except ValueError:
                print("Please enter a valid number.")
        
        self.contestant_speaks(self.player, f"I'm pretty sure {subject.name} has the hidden immunity idol.")
        npc.add_information('has_idol', subject)
        if npc.information_bank:
            npc.information_bank[-1]['day'] = self.day
        self.narration("You share false information about an idol.")
        self.record_npc_action(npc, f"Probe player", "Player bluffed about idol")
    
    def bluff_alliance_to_npc(self, npc: Contestant) -> None:
        """Player bluffs about an alliance between two people to an NPC."""
        player_tribe = self.get_player_tribe()
        potential_allies = [c for c in player_tribe if c != npc and c != self.player]
        
        if len(potential_allies) < 2:
            self.contestant_speaks(self.player, "I haven't really noticed any specific alliances forming.")
            self.narration("You give a non-committal response.")
            return
        
        # Let player choose first person in the fake alliance
        print("\nWho do you want to claim is in an alliance? (First person)")
        for i, contestant in enumerate(potential_allies, 1):
            print(f"{i}. {contestant.name}")
        print(f"{len(potential_allies) + 1}. Cancel")
        
        while True:
            try:
                choice = int(input(f"Enter your choice (1-{len(potential_allies) + 1}): "))
                if 1 <= choice <= len(potential_allies):
                    ally1 = potential_allies[choice - 1]
                    break
                elif choice == len(potential_allies) + 1:
                    return  # Cancel
                else:
                    print(f"Please enter a number between 1 and {len(potential_allies) + 1}.")
            except ValueError:
                print("Please enter a valid number.")
        
        # Remove ally1 from potential allies for second choice
        remaining_allies = [c for c in potential_allies if c != ally1]
        
        # Let player choose second person in the fake alliance
        print(f"\nWho do you want to claim {ally1.name} is allied with? (Second person)")
        for i, contestant in enumerate(remaining_allies, 1):
            print(f"{i}. {contestant.name}")
        print(f"{len(remaining_allies) + 1}. Cancel")
        
        while True:
            try:
                choice = int(input(f"Enter your choice (1-{len(remaining_allies) + 1}): "))
                if 1 <= choice <= len(remaining_allies):
                    ally2 = remaining_allies[choice - 1]
                    break
                elif choice == len(remaining_allies) + 1:
                    return  # Cancel
                else:
                    print(f"Please enter a number between 1 and {len(remaining_allies) + 1}.")
            except ValueError:
                print("Please enter a valid number.")
        
        self.contestant_speaks(self.player, f"I think {ally1.name} and {ally2.name} are working together.")
        npc.add_information('alliance', ally1, ally2)
        npc.add_information('alliance', ally2, ally1)
        if npc.information_bank:
            npc.information_bank[-1]['day'] = self.day
            npc.information_bank[-2]['day'] = self.day
        self.narration("You share false information about an alliance.")
        self.record_npc_action(npc, f"Probe player", "Player bluffed about alliance")
    
    def bluff_consensus_vote_to_npc(self, npc: Contestant) -> None:
        """Player bluffs about the consensus vote to an NPC."""
        player_tribe = self.get_player_tribe()
        eligible_targets = [c for c in player_tribe if c != self.player and c != npc]
        
        if not eligible_targets:
            self.contestant_speaks(self.player, "I honestly don't know. Everyone's being pretty secretive.")
            self.narration("You give a non-committal response.")
            return
        
        # Let player choose who to claim is the consensus target
        print("\nWho do you want to claim is getting voted out next?")
        for i, contestant in enumerate(eligible_targets, 1):
            print(f"{i}. {contestant.name}")
        print(f"{len(eligible_targets) + 1}. Cancel")
        
        while True:
            try:
                choice = int(input(f"Enter your choice (1-{len(eligible_targets) + 1}): "))
                if 1 <= choice <= len(eligible_targets):
                    fake_target = eligible_targets[choice - 1]
                    break
                elif choice == len(eligible_targets) + 1:
                    return  # Cancel
                else:
                    print(f"Please enter a number between 1 and {len(eligible_targets) + 1}.")
            except ValueError:
                print("Please enter a valid number.")
        
        # Share the fake consensus information
        self.contestant_speaks(self.player, f"From what I've been hearing, {fake_target.name} is getting voted out next.")
        
        # Add false consensus information to NPC's info bank
        consensus_info = {
            'type': 'consensus_vote',
            'targets': [fake_target],
            'day': self.day
        }
        npc.information_bank.append(consensus_info)
        
        # NPC will react to learning about consensus vote
        npc.react_to_consensus_vote_discovery(source=self.player)
        
        # Record the action
        self.record_npc_action(npc, "Probed by player", f"Player gave false consensus vote info ({fake_target.name})")
    
    def npc_pitch_alliance_to_player(self, npc: Contestant) -> None:
        """Handle when an NPC pitches an alliance to the player."""
        # NPC makes their pitch
        pitches = [
            f"I think we should work together. We could go far in this game.",
            f"I trust you, and I think we'd make a strong alliance.",
            f"What do you say we watch each other's backs?",
            f"I've been thinking - you and I should stick together."
        ]
        
        self.contestant_speaks(npc, random.choice(pitches))
        
        print("\nHow do you respond?")
        print("1. Accept the alliance")
        print("2. Decline the alliance")
        print("3. Say you'll think about it")
        
        while True:
            try:
                choice = int(input("Enter your choice (1-3): "))
                if choice == 1:
                    # Accept alliance - form real alliance
                    self.narration("You agree to form an alliance.")
                    self.player.alliance_roster.append(npc)
                    npc.alliance_roster.append(self.player)
                    
                    # Game Security: NPC successfully pitched an alliance (+1)
                    npc.modify_base_game_security(1, "Successfully pitched alliance", silent=True)
                    
                    # Update vote targets and target rosters if they were targeting each other
                    if self.player.vote_target == npc:
                        self.assign_random_vote_target(self.player)
                    if npc.vote_target == self.player:
                        self.assign_random_vote_target(npc)
                    
                    npc.target_roster = [c for c in npc.target_roster if c != self.player]
                    
                    npc.modify_relationship(self.player, 1)
                    # Both parties add alliance info
                    self.add_player_information('alliance', self.player, npc)
                    npc.add_information('alliance', npc, self.player)
                elif choice == 2:
                    # Decline alliance
                    self.narration("You politely decline the alliance offer.")
                    npc.modify_relationship(self.player, -1)
                    # Check for alliance breaking due to relationship falling to -1
                    self.check_relationship_alliance_breaking(npc, self.player)
                elif choice == 3:
                    # Non-committal
                    self.narration("You tell them you'll think about it.")
                else:
                    print("Invalid choice. Please enter 1, 2, or 3.")
                    continue
                break
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    def npc_pitch_final_2_to_player(self, npc: Contestant) -> None:
        """Handle when an NPC pitches a final 2 deal to the player."""
        
        # NPC makes their pitch
        final_2_pitches = [
            f"I've been thinking - you and I should make a pact to go to the final 2 together.",
            f"What would you say to a final 2 deal? Just you and me at the end.",
            f"I want to propose something big - let's commit to taking each other to the final 2.",
            f"I trust you completely. Will you make a final 2 deal with me?"
        ]
        
        self.contestant_speaks(npc, random.choice(final_2_pitches))
        
        print("\nHow do you respond?")
        print("1. Accept the final 2 deal")
        print("2. Decline the final 2 deal")
        
        while True:
            try:
                choice = int(input("Enter your choice (1-2): "))
                if choice == 1:
                    # Accept final 2 deal - add to existing deals
                    # Note: Player can only have one "real" final_2_deal at a time in current system
                    # So we treat this as replacing the main deal, but the betrayal system handles multiple deals
                    
                    # If player already has a final 2 deal, warn them before accepting
                    # Check for both real and fake final 2 deals
                    current_deals = []
                    if self.player.final_2_deal:
                        current_deals.append(self.player.final_2_deal)
                    current_deals.extend(self.player.fake_final_2_deals)
                    
                    if current_deals:
                        if len(current_deals) == 1:
                            print(f"\n⚠️  WARNING: You already have a final 2 deal with {current_deals[0].name}!")
                        else:
                            deals_names = ", ".join([c.name for c in current_deals[:-1]]) + f" and {current_deals[-1].name}"
                            print(f"\n⚠️  WARNING: You already have final 2 deals with {deals_names}!")
                        print(f"Accepting this new deal with {npc.name} will betray your existing partner(s).")
                        print("\nDo you still want to accept this new final 2 deal?")
                        print("1. Yes, accept the new deal (betray existing partner)")
                        print("2. No, keep my existing deal")
                        
                        while True:
                            try:
                                confirm_choice = int(input("Enter your choice (1-2): "))
                                if confirm_choice == 1:
                                    # Player confirms they want to betray existing partner
                                    break
                                elif confirm_choice == 2:
                                    # Player decides to keep existing deal
                                    self.narration("You decide to stay loyal to your existing final 2 partner.")
                                    self.contestant_speaks(self.player, "I appreciate the offer, but I have to decline.")
                                    self.contestant_speaks(npc, "I understand. I respect your loyalty.")
                                    npc.modify_relationship(self.player, -1)
                                    # Check for alliance breaking due to relationship falling to -1
                                    self.check_relationship_alliance_breaking(npc, self.player)
                                    break
                                else:
                                    print("Invalid choice. Please enter 1 or 2.")
                            except ValueError:
                                print("Invalid input. Please enter a number.")
                        
                        # If player chose to keep existing deal, exit the function
                        if confirm_choice == 2:
                            break
                    
                    # If player already has a final 2 deal, this becomes betrayal territory
                    if self.player.final_2_deal:
                        # Check if NPC knows about existing deal - if so, they might confront about betrayal
                        knows_about_existing = False
                        for info in npc.information_bank:
                            if (info['type'] == 'final_2' and 
                                info.get('subject') == self.player and 
                                info.get('target') == self.player.final_2_deal):
                                knows_about_existing = True
                                break
                        
                        if knows_about_existing:
                            # NPC knows about existing deal but is still offering - they're being strategic
                            self.narration("You shake hands and agree to go to the final 2 together.")
                        else:
                            # NPC doesn't know about existing deal
                            self.narration("You shake hands and agree to go to the final 2 together.")
                    else:
                        self.narration("You shake hands and agree to go to the final 2 together.")
                    
                    # Form the new deal (this will be the player's "main" final 2 deal)
                    # The old deal becomes a "secondary" deal that can trigger betrayal consequences
                    old_partner = self.player.final_2_deal
                    self.player.final_2_deal = npc
                    npc.final_2_deal = self.player
                    
                    # Game Security: NPC becomes part of a Final 2 Deal (+1)
                    npc.modify_base_game_security(1, "Formed Final 2 deal")
                    
                    # Remove each other from target rosters
                    npc.target_roster = [c for c in npc.target_roster if c != self.player]
                    
                    # Update vote targets if they were targeting each other
                    if self.player.vote_target == npc:
                        self.player.vote_target = None  # Player will choose new target
                    if npc.vote_target == self.player:
                        self.assign_random_vote_target(npc)
                    
                    npc.modify_relationship(self.player, 2)
                    # Add final 2 info to player's knowledge
                    self.add_player_information('final_2', self.player, npc)
                    npc.add_information('final_2', npc, self.player)
                elif choice == 2:
                    # Decline final 2 deal
                    self.narration("You politely decline the final 2 offer.")
                    self.contestant_speaks(npc, "I understand. Maybe another time.")
                    npc.modify_relationship(self.player, -1)
                    # Check for alliance breaking due to relationship falling to -1
                    self.check_relationship_alliance_breaking(npc, self.player)
                else:
                    print("Invalid choice. Please enter 1 or 2.")
                    continue
                break
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    def npc_confront_player_about_final_2_betrayal(self, npc: Contestant, other_contestant: Contestant) -> None:
        """Handle when an NPC confronts the player about conflicting Final 2 deals.
        
        Args:
            npc: The NPC doing the confronting
            other_contestant: The specific contestant they learned about having a Final 2 deal with player
        """
        # Mark that this NPC has interacted with player today
        if npc not in self.contestants_who_interacted_with_player:
            self.contestants_who_interacted_with_player.append(npc)
        
        # Narrate the confrontation
        self.narration(f"{npc.name} approaches you with an angry expression.")
        
        # Different confrontation messages based on personality
        if npc.hero_or_villain == "Villain":
            confrontations = [
                f"So I just heard something interesting. Apparently you have a Final 2 deal with {other_contestant.name}? And here I thought we had something special.",
                f"You think you're so clever, making Final 2 deals with everyone? Well, I just found out about your arrangement with {other_contestant.name}.",
                f"I should have known better than to trust you. I know about your Final 2 deal with {other_contestant.name} now."
            ]
        else:
            confrontations = [
                f"I can't believe this... I just found out about your Final 2 deal with {other_contestant.name}! How could you?",
                f"I just found out about your Final 2 deal with {other_contestant.name}! What about our deal? Were you playing me this whole time?",
                f"I thought we had a real connection, a real Final 2 deal. But now I find out you have one with {other_contestant.name} too?"
            ]
        
        self.contestant_speaks(npc, random.choice(confrontations))
        
        # Check if the player believes they have conflicting Final 2 deals
        # From the player's perspective, do they think they have a deal with other_contestant?
        player_believes_has_deal_with_other = (
            self.player.final_2_deal == other_contestant or
            other_contestant in self.player.fake_final_2_deals or
            (other_contestant.final_2_deal == self.player and other_contestant not in self.player.fake_final_2_deals)
        )
        
        # Does the player have any other Final 2 arrangements?
        player_has_other_final2_relationships = (
            (self.player.final_2_deal is not None and self.player.final_2_deal != other_contestant) or
            len([c for c in self.player.fake_final_2_deals if c != other_contestant]) > 0 or
            any(c.final_2_deal == self.player and c not in self.player.fake_final_2_deals and c != other_contestant 
                for c in self.contestants if not c.eliminated and not c.is_player)
        )
        
        # If player believes they have a deal with other_contestant AND has other arrangements, 
        # then from player's perspective they are being duplicitous
        player_believes_they_are_guilty = player_believes_has_deal_with_other and player_has_other_final2_relationships
        
        if player_believes_they_are_guilty:
            print(f"\n{npc.name} has discovered your conflicting Final 2 deals!")
        else:
            print(f"\n{npc.name} believes you have conflicting Final 2 deals!")
        
        print("1. Deny it")
        print("2. Do damage control")
        
        while True:
            try:
                choice = int(input("Enter your choice (1-2): "))
                if choice == 1:
                    # Deny
                    self.narration("You try to deny having any other Final 2 deals.")
                    self.contestant_speaks(npc, "Don't lie to me! I know the truth. We're done.")
                elif choice == 2:
                    # Damage control
                    self.narration("You try to do damage control and salvage the relationship.")
                    self.contestant_speaks(npc, "It's too late for that. You've shown me who you really are.")
                else:
                    print("Invalid choice. Please enter 1 or 2.")
                    continue
                break
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Apply the betrayal consequences
        self.narration(f"{npc.name} storms off, clearly upset about your betrayal.")
        self.apply_final_2_betrayal_consequences(self.player, npc)
        
        # Record the action
        self.record_npc_action(npc, "Confront player", "Discovered player's Final 2 betrayal")
    
    def get_premerge_challenge_description(self, challenge_type: str = "immunity") -> str:
        """Get a unique pre-merge challenge description for immunity or reward challenges."""
        all_premerge_challenges = [
            "For today's challenge, each tribe will swim out to a large bamboo cage. You'll climb up and over the wall and jump into the water where you will find four large fish traps full of puzzle pieces. You'll swim them back to shore where one tribe member will use the pieces inside to solve a very complicated puzzle. Whoever finishes the puzzle first wins {challenge_type} for their tribe.",
            "For today's challenge you'll throw a rope through a ring releasing sandbags. You'll then throw the sandbags as far as you can through a net tunnel. Once you've maneuvered them all the way through, one tribe member will bounce the sandbags off a trampoline attempting to land them into a series of baskets. The first tribe to get one sandbag into each of the five baskets wins {challenge_type}.",
            "For today's challenge you'll square off, one-on-one. You'll each be holding an idol. Your job is to knock your opponents idol before they knock off yours. Every time you do, you score a point for your tribe. First to four wins {challenge_type}.",
            "For today's challenge you're going to be trapped in a cage. There's an escape hatch at the top. To get to it, you're going to have to make your way through a rope web of knots until you release a pole. Use the pole to retrieve three sets of keys. Use the keys to unlock the locks and release the hatch. First tribe to open the hatch wins {challenge_type}.",
            "For today's challenge, you'll race to roll six large crates to your platform. Once you've collected all six crates, you must use them to build a staircase that will spell out your tribe name. First tribe to stack their crates correctly and get all their tribe members to the top wins {challenge_type}.",
            "For today's challenge, one person from each tribe will race across a floating bridge carrying a body board attached to a long rope. Once you've reached the platform, you'll grab a bag and then hang on to the board as the rest of the tribe will crank a giant winch pulling you back to shore. Inside the bags are puzzle banners. Once you have all five bags, you'll roll the banners down the face of the wall and then arrange them to form your tribe flag. First tribe to get it right wins {challenge_type}.",
            "For today's challenge, one tribe member will be your caller. The rest of the tribe will be blindfolded. Using only verbal commands, the caller will direct the blindfolded tribe members to collect a series of very large and very heavy puzzle pieces. First tribe to finish their puzzle wins {challenge_type}.",
            "For today's challenge, you'll race up a tower through a series of obstacles. When you get to the top, you will launch sandbags attempting to hit a series of targets. First two tribes to hit all their targets wins {challenge_type}.",
            "For today's challenge, two members of each tribe will alternate launching balls out onto the course where the remaining tribe members will catch the ball. If you catch a ball from either tribe, you score a point for your tribe. First tribe to five points wins {challenge_type}.",
            "For today's challenge, each tribe will have five minutes to build a barricade inside the other tribe's frame. You will then attempt to toss ceramic pigs through the barricade the other tribe built in your frame. If you drop a pig or if it breaks, it doesn't count. The tribe with the most pigs at the end of ten minutes wins {challenge_type}.",
            "For today's challenge, two contestants from each tribe will start inside a barrel. The rest of the tribe will push you through a series of obstacles. Along the way, you'll collect a total of four buoys which you'll then use to float the two people in the barrel across the water. You'll then dive down and retrieve four flags. You'll take those four flags and attach them to a flagpole. First tribe to hang all four flags wins {challenge_type}.",
            "For today's challenge, two members from each tribe will swim out to a floating platform. One at a time, you'll dive down to a 30-foot-long steel cage containing tribe colored coconuts, ten of which have letters painted on them. You'll remove your tribe's letter coconuts from the cage and bring them to shore where the remaining tribe members will use those letters to unscramble a one word answer. First tribe to solve the puzzle wins {challenge_type}.",
            "For today's challenge, you'll take turns throwing rocks at ceramic tiles. Each time you break a tile, you release a bundle of wooden puzzle pieces. Once you've collected all four bundles, three tribe members will assemble the puzzle. First tribe to finish the puzzle wins {challenge_type}.",
            "For today's challenge, one tribe member at a time will attempt to navigate an obstacle course on a platform while members of the other tribe attempt to knock you off by swinging heavy canvas bags of sand. When you reach the end, you'll grab a flag and try to make your way back. If you fall off at any point, you have to start over. First tribe to collect five flags wins {challenge_type}.",
            "For today's challenge, one by one, you'll dive down to release puzzle wheels attached to a rope. Bring it up, and the next person goes. Once you've collected all eight wheels, you will use those puzzle wheels to solve a word puzzle. First tribe to get it right wins {challenge_type}."
        ]
        
        # Get available challenges (ones that haven't been used yet)
        available_indices = [i for i in range(len(all_premerge_challenges)) if i not in self.used_premerge_challenge_indices]
        
        if available_indices:
            # Select a random available challenge
            selected_index = random.choice(available_indices)
            self.used_premerge_challenge_indices.append(selected_index)
            # Replace {challenge_type} with the actual challenge type
            return all_premerge_challenges[selected_index].format(challenge_type=challenge_type)
        else:
            # Fallback if somehow all challenges have been used
            return f"For today's challenge, tribes will compete in a test of teamwork and strategy. The winning tribe earns {challenge_type}."
    
    def select_sit_out_contestants(self) -> List[Contestant]:
        """Select contestants to sit out when tribes are uneven. Returns list of contestants sitting out."""
        if self.merged:
            return []  # No sit-outs in individual challenges
        
        player_tribe_members = self.get_player_tribe()
        other_tribe_members = self.get_other_tribe()
        
        # Determine which tribe needs to sit out members
        if len(player_tribe_members) == len(other_tribe_members):
            return []  # Tribes are even, no sit-outs needed
        
        larger_tribe = player_tribe_members if len(player_tribe_members) > len(other_tribe_members) else other_tribe_members
        smaller_tribe = other_tribe_members if larger_tribe == player_tribe_members else player_tribe_members
        
        # Calculate how many need to sit out
        sit_out_count = len(larger_tribe) - len(smaller_tribe)
        
        # Create list of candidates (exclude anyone who sat out last challenge)
        candidates = [c for c in larger_tribe if not c.sat_out_last_challenge]
        
        # If we don't have enough candidates (everyone sat out last time), allow previous sit-outs
        if len(candidates) < sit_out_count:
            candidates = larger_tribe[:]
        
        # Sort candidates by sit-out priority
        # Primary: lowest challenge_skill
        # Secondary: lowest survival_status  
        # Tertiary: random
        candidates.sort(key=lambda c: (c.challenge_skill, c.survival_status, random.random()))
        
        # Select the required number to sit out
        sit_out_contestants = candidates[:sit_out_count]
        
        return sit_out_contestants
    
    def immunity_challenge(self) -> bool:
        """Run an immunity challenge. Returns True if player's tribe wins."""
        if self.merged:
            return self.individual_immunity_challenge()
        else:
            return self.tribal_immunity_challenge()
    
    def tribal_immunity_challenge(self) -> bool:
        """Run a tribal immunity challenge. Returns True if player's tribe wins."""
        self.jeff_speaks("Come on in guys!")
        self.narration(f"Both tribes enter the challenge area. Jeff stands ready to explain today's immunity challenge.")
        
        # Reset immunity
        for contestant in self.contestants:
            contestant.immune = False
        
        # Reveal any unrevealed eliminated contestants from the other tribe
        if self.day > 3 and len(self.eliminated_contestants) > 0:
            other_tribe_name = self.get_other_tribe_name()
            
            # Find all unrevealed eliminations from the other tribe
            unrevealed_other_tribe = [c for c in self.eliminated_contestants 
                                    if c.tribe == other_tribe_name 
                                    and c not in self.revealed_eliminations]
            
            # Reveal the most recent unrevealed elimination
            if unrevealed_other_tribe:
                last_eliminated = unrevealed_other_tribe[-1]
                self.jeff_speaks(f"{self.get_player_tribe_name()}, getting your first look at the new {other_tribe_name} tribe. {last_eliminated.name} voted out at the last tribal council.")
                self.revealed_eliminations.append(last_eliminated)
        
        # Handle sit-outs for uneven tribes
        sit_out_contestants = self.select_sit_out_contestants()
        
        # Pre-challenge dialogue (varies based on which challenge this is)
        if self.immunity_challenges_held == 0:
            # Very first pre-merge immunity challenge
            self.jeff_speaks("Ready to get to your first immunity challenge?")
        else:
            # All other pre-merge challenges
            self.jeff_speaks("Ready to get to today's immunity challenge?")
        
        self.narration("The contestants enthusiastically say yes.")
        
        # Handle idol retrieval (skip for first immunity challenge)
        if self.immunity_challenges_held > 0:
            self.jeff_speaks("First thing's first I'll take back the idol.")
            
            # Determine which tribe won the previous challenge
            if self.previous_immunity_winner:
                if self.previous_immunity_winner == self.get_player_tribe_name():
                    self.narration(f"Jeff retrieves the idol from the {self.get_player_tribe_name()} tribe.")
                else:
                    self.narration(f"Jeff retrieves the idol from the {self.get_other_tribe_name()} tribe.")
            
            # For subsequent challenges, combine with challenge description to avoid back-to-back Jeff lines
            challenge_description = self.get_premerge_challenge_description("immunity")
            combined_description = f"Once again immunity is back up for grabs. {challenge_description}"
            self.jeff_speaks(combined_description)
        else:
            # First challenge - just use the challenge description
            challenge_description = self.get_premerge_challenge_description("immunity")
            self.jeff_speaks(challenge_description)
        
        # Tribes take their places
        self.narration("The tribes take their places.")
        
        # Announce sit-outs just before the challenge starts
        if sit_out_contestants:
            sit_out_names = [c.name for c in sit_out_contestants]
            if len(sit_out_contestants) == 1:
                self.narration(f"{sit_out_contestants[0].name} sits out of today's challenge for {sit_out_contestants[0].tribe}.")
            else:
                self.narration(f"{', '.join(sit_out_names[:-1])} and {sit_out_names[-1]} sit out of today's challenge for {sit_out_contestants[0].tribe}.")
        
        self.jeff_speaks("Survivors ready... GO!")
        
        self.narration("The tribes battle fiercely in the challenge...")
        time.sleep(2)
        
        # Calculate tribe average challenge skills (excluding sit-out contestants)
        player_tribe_members = [c for c in self.get_player_tribe() if c not in sit_out_contestants]
        other_tribe_members = [c for c in self.get_other_tribe() if c not in sit_out_contestants]
        
        player_tribe_avg_skill = sum(c.challenge_skill for c in player_tribe_members) / len(player_tribe_members) if player_tribe_members else 0
        other_tribe_avg_skill = sum(c.challenge_skill for c in other_tribe_members) / len(other_tribe_members) if other_tribe_members else 0
        
        # Add elite challenge performer bonus (+2 for each contestant with challenge skill 3)
        player_tribe_elite_bonus = sum(2 for c in player_tribe_members if c.challenge_skill == 3)
        other_tribe_elite_bonus = sum(2 for c in other_tribe_members if c.challenge_skill == 3)
        
        # Add survival status modifiers for each tribe (capped at ±4 for pre-merge)
        player_tribe_survival_bonus = sum(c.get_survival_status_modifier("challenge") for c in player_tribe_members)
        other_tribe_survival_bonus = sum(c.get_survival_status_modifier("challenge") for c in other_tribe_members)
        
        # Cap survival bonuses at ±4 for pre-merge challenges
        player_tribe_survival_bonus = max(-4, min(4, player_tribe_survival_bonus))
        other_tribe_survival_bonus = max(-4, min(4, other_tribe_survival_bonus))
        
        # Roll d20 for each tribe and add all bonuses
        player_tribe_base_roll = random.randint(1, 20)
        other_tribe_base_roll = random.randint(1, 20)
        
        player_tribe_total = player_tribe_base_roll + player_tribe_avg_skill + player_tribe_elite_bonus + player_tribe_survival_bonus
        other_tribe_total = other_tribe_base_roll + other_tribe_avg_skill + other_tribe_elite_bonus + other_tribe_survival_bonus
        
        # Display challenge calculations
        player_tribe_calc = f"{player_tribe_base_roll} + {player_tribe_avg_skill:.1f} skill"
        if player_tribe_elite_bonus > 0:
            player_tribe_calc += f" + {player_tribe_elite_bonus} elite bonus"
        if player_tribe_survival_bonus != 0:
            player_tribe_calc += f" + {player_tribe_survival_bonus} survival"
        player_tribe_calc += f" = {player_tribe_total:.1f}"
        
        other_tribe_calc = f"{other_tribe_base_roll} + {other_tribe_avg_skill:.1f} skill"
        if other_tribe_elite_bonus > 0:
            other_tribe_calc += f" + {other_tribe_elite_bonus} elite bonus"
        if other_tribe_survival_bonus != 0:
            other_tribe_calc += f" + {other_tribe_survival_bonus} survival"
        other_tribe_calc += f" = {other_tribe_total:.1f}"
        
        
        # Determine winner based on total scores
        if player_tribe_total > other_tribe_total:
            player_tribe_wins = True
        elif other_tribe_total > player_tribe_total:
            player_tribe_wins = False
        else:
            # Tie - decide randomly
            self.narration("It's a tie! The winner will be decided by a tiebreaker...")
            player_tribe_wins = random.choice([True, False])
            tiebreaker_winner = self.get_player_tribe_name() if player_tribe_wins else self.get_other_tribe_name()
            self.narration(f"{tiebreaker_winner} wins the tiebreaker!")
        
        if player_tribe_wins:
            self.narration(f"{self.get_player_tribe_name()} wins immunity!")
            self.jeff_speaks(f"{self.get_player_tribe_name()}, immunity is yours. No tribal council for you tonight. Grab your stuff, head back to camp.")
            self.narration(f"Jeff Probst hands the immunity idol to the {self.get_player_tribe_name()} tribe.")
        else:
            self.narration(f"{self.get_other_tribe_name()} wins immunity!")
            self.jeff_speaks(f"{self.get_other_tribe_name()}, immunity is yours. No tribal council for you tonight.")
            self.narration(f"Jeff Probst hands the immunity idol to the {self.get_other_tribe_name()} tribe.")
            self.jeff_speaks(f"{self.get_player_tribe_name()}, I've got nothing for you except a date with me at tribal council tonight.")
        
        # Update sit-out tracking for next challenge
        # First, reset all contestants' sit-out flags
        for contestant in self.contestants:
            contestant.sat_out_last_challenge = False
        
        # Mark contestants who sat out this challenge
        for contestant in sit_out_contestants:
            contestant.sat_out_last_challenge = True
        
        # Update immunity challenge tracking
        self.immunity_challenges_held += 1
        self.previous_immunity_winner = self.get_player_tribe_name() if player_tribe_wins else self.get_other_tribe_name()
        
        return player_tribe_wins
    
    def individual_immunity_challenge(self) -> bool:
        """Run an individual immunity challenge. Returns True if player wins."""
        self.jeff_speaks("Come on in guys!")
        self.narration("The tribe arrives at the challenge area for today's individual immunity challenge.")
        
        # Reset immunity
        for contestant in self.contestants:
            contestant.immune = False
        
        # Pre-challenge dialogue (varies based on which challenge this is)
        active_contestants = self.get_active_contestants()
        if len(active_contestants) == 3:
            # Final immunity challenge
            self.jeff_speaks("Ready to get to your final immunity challenge?")
        elif self.individual_immunity_challenges_held == 0:
            # First individual immunity challenge
            self.jeff_speaks("Ready to get to your first individual immunity challenge?")
        else:
            # All other individual challenges
            self.jeff_speaks("Ready to get to today's immunity challenge?")
        
        self.narration("The contestants enthusiastically say yes.")
        
        # Handle idol retrieval (skip for first individual immunity challenge)
        if self.individual_immunity_challenges_held > 0:
            self.jeff_speaks("First thing's first I'll take back immunity.")
            # previous_immunity_winner is a Contestant object for individual challenges
            if self.previous_immunity_winner and hasattr(self.previous_immunity_winner, 'eliminated') and not self.previous_immunity_winner.eliminated:
                self.narration(f"Jeff retrieves the immunity necklace from {self.previous_immunity_winner.name}.")
            self.jeff_speaks("Once again immunity is back up for grabs.")
        
        # Challenge description
        if len(active_contestants) == 3:
            # Final immunity challenge descriptions
            final_challenge_descriptions = [
                "For today's challenge you will place a ball down a chute. The ball will spiral downward until it drops out the bottom where you must catch it and place it back in the chute. Every few minutes we'll add another ball. The balls will alternate left, then right. If at any point one of your balls hits the ground, you're out of the challenge. Last person to keep all of their balls in play wins.",
                "For today's challenge, you each have a long wooden cylinder that has been cut into several pieces. In the center is a slot on which rests a metal ball. You'll hold the first piece using two handles, balancing the ball. Every five minutes, you will add more pieces, making it more difficult to hold onto. If your ball drops, you're out of the challenge. Last person standing wins immunity.",
                "For today's challenge, you will race through a series of obstacles collecting bags of puzzle pieces. You'll run them up, drop them at your table, then race down a giant water slide and collect more bags. Once you have all six bags, you'll use the pieces to solve a puzzle. First person to finish wins immunity.",
                "Today's immunity challenge is very simple. You will stand barefoot on two posts. You'll have one hand on the immunity idol and you'll stand there as long as you can. If either of your feet come off their post at any time or if your hand comes off the idol at any time, you are out. Last person standing wins immunity.",
                "For today's immunity challenge, you will compete in a Survivor maze. You'll each be blindfolded. To help you navigate your way, there will be a series of guideposts. You will have to use your fingers to read the symbols. Each guidepost leads you to four different stations where you must collect a corresponding necklace. Once you have all four necklaces, make your way to the finish. First person to finish wins immunity."
            ]
            self.jeff_speaks(random.choice(final_challenge_descriptions))
        else:
            # Regular individual challenge descriptions
            all_individual_challenges = [
                "For today's challenge, you're going to stand on a narrow beam while balancing a ball on a platform. At regular intervals, your feet are going to move down to a more narrow beam and your hand will move farther down the pole making it more difficult to balance. If at any point you fall off the beam or drop your ball, you're out of the challenge. Last person left standing wins immunity.",
                "For today's challenge, you will each be attached to a long rope that is threaded through a series of obstacles. You'll climb over, crawl under, and maneuver around these obstacles as you race to the finish. First one to get through wins immunity.",
                "For today's challenge, each of you will hold onto a pole for as long as you can. When you fall off the pole, you're out of the challenge. Last person left hanging on the pole wins immunity.",
                "For today's challenge, your hand will be tethered to a bucket filled with water above your head. When your hand drops, the bucket tips, you get wet, and you're out of the challenge. Last person standing wins immunity.",
                "For today's challenge, you'll race across a bamboo balance beam to a platform where you will find a hook attached to a rope. You'll drop it in the water and use the hook to retrieve three bags. Once you have all three bags you'll use the rope and sticks inside the bag to fashion a pole. Once the pole is long enough, you'll use it to hit a target dropping a flag. First person to drop their flag wins immunity.",
                "For today's challenge, you're going to race through a series of obstacles while balancing a ball on top of a pole. If the ball drops, you have to start over. Once you reach the end, you'll release a key that unlocks a box full of sandbags. Use the sandbags to knock over nine bamboo targets. First person to knock down all their targets wins immunity.",
                "For today's challenge, you're going to dive in to the water and push a buoy along a rope through an obstacle. Once you reach the shore you'll untie a bag of letter tiles and use them to solve a classic survivor phrase. First to finish wins immunity.",
                "For today's challenge, you're going to pull on a rope, leveling out an unbalanced table. You'll then race out collecting wooden blocks, bringing them back one at a time and attempting to place them on the table. If your table wobbles and the blocks fall, you have to reset them. First person to get all ten blocks on their table wins immunity.",
                "For today's challenge, you are going to balance a ball on a disc attached to ropes. At regular intervals you will move your hands farther back on the rope making it more difficult to balance. If you drop your ball, you are out of the challenge. Last one standing wins immunity.",
                "For today's challenge, you'll use grappling hooks to retrieve three bags. Each bag contains a ball. Once you have all three bags, you will place the balls one at a time, into a table maze that you will control using two ropes. First person to maneuver all three balls through the table maze wins immunity."
            ]
            
            # Get available challenges (ones that haven't been used yet)
            available_indices = [i for i in range(len(all_individual_challenges)) if i not in self.used_individual_challenge_indices]
            
            if available_indices:
                # Select a random available challenge
                selected_index = random.choice(available_indices)
                self.used_individual_challenge_indices.append(selected_index)
                self.jeff_speaks(all_individual_challenges[selected_index])
            else:
                # Fallback if somehow all challenges have been used
                self.jeff_speaks("For today's challenge, you'll compete in a test of endurance and willpower. Last person standing wins immunity.")
        
        # Players take their positions
        self.narration("The players take their positions.")
        
        self.jeff_speaks("Survivors ready... GO!")
        
        self.narration("The contestants battle fiercely in the challenge...")
        time.sleep(2)
        
        # Roll d20 for each contestant and add their challenge skill plus survival status
        active_contestants = self.get_active_contestants()
        contestant_totals = {}
        
        for contestant in active_contestants:
            base_roll = random.randint(1, 20)
            survival_modifier = contestant.get_survival_status_modifier("challenge")
            total = base_roll + contestant.challenge_skill + survival_modifier
            contestant_totals[contestant] = total
            
        
        # Find the highest total
        max_total = max(contestant_totals.values())
        winners = [contestant for contestant, total in contestant_totals.items() if total == max_total]
        
        if len(winners) == 1:
            winner = winners[0]
        else:
            # Tie - decide randomly among tied contestants
            tied_names = [w.name for w in winners]
            self.narration(f"It's a tie between {', '.join(tied_names)}! The winner will be decided by a tiebreaker...")
            winner = random.choice(winners)
            self.narration(f"{winner.name} wins the tiebreaker!")
        
        winner.immune = True
        
        # Track immunity wins if post-merge
        if self.merged:
            winner.immunity_wins += 1
            
            # Check if this is the final immunity challenge (3 people left)
            if len(active_contestants) == 3:
                # Add Level 2 game move for winning final immunity
                winner.add_game_move('final_immunity_win', 2, self.day, "won the final immunity challenge")
            
            # Add/Update Level 3 game move for multiple immunity wins (3+)
            if winner.immunity_wins >= 3:
                # Remove any existing immunity move and add updated one
                winner.remove_game_move('multiple_immunity_wins')
                count = winner.immunity_wins
                winner.add_game_move('multiple_immunity_wins', 3, self.day,
                                   f"won {count} individual immunity challenges")
        
        # Handle vote target displacement due to immunity
        for contestant in active_contestants:
            if contestant != winner:  # Don't reassign winner's target
                self.handle_immunity_vote_target_displacement(contestant)
        
        self.narration(f"{winner.name} wins individual immunity!")
        self.jeff_speaks(f"{winner.name}, come on over. This is for you.")
        
        # Update immunity challenge tracking
        self.immunity_challenges_held += 1
        self.individual_immunity_challenges_held += 1
        self.previous_immunity_winner = winner
        
        # Only show Final 3 tribal council narration if there are exactly 3 contestants left
        if len(active_contestants) == 3:
            if winner.is_player:
                self.narration("The final three arrives at tribal council. Each person grabs a torch and dips it into the fire.")
                self.jeff_speaks("Fire represents life in this game. When your fire's gone, so are you.")
                self.narration(f"You are wearing the immunity necklace and will make the important decision who to eliminate and who to bring to the final two.")
                return True
            else:
                self.narration("The final three arrives at tribal council. Each person grabs a torch and dips it into the fire.")
                self.jeff_speaks("Fire represents life in this game. When your fire's gone, so are you.")
                self.narration(f"{winner.name} is wearing the immunity necklace and will make the important decision who to eliminate and who to bring to the final two.")
                return False
        
        return winner.is_player
    
    def handle_tribal_council_tie(self, tribe: List[Contestant], tied_contestants: List[Contestant], idol_recipient: Optional[Contestant] = None, vote_record: dict = None) -> Contestant:
        """Handle a tie at tribal council using Survivor rules."""
        
        # Check if this is Final 4 - automatic fire-making challenge
        if len(tribe) == 4:
            # Filter out idol recipient from tie
            voteable_tied = [c for c in tied_contestants if c != idol_recipient]
            
            if len(voteable_tied) < 2:
                # Edge case: not enough people can participate in fire challenge
                self.jeff_speaks("Due to the idol play, we cannot proceed with a fire-making challenge.")
                if voteable_tied:
                    return voteable_tied[0]  # Eliminate the one person who can be eliminated
                else:
                    return None  # No one can be eliminated
            
            if len(voteable_tied) == 2:
                self.jeff_speaks(f"Here's what's going to happen: {voteable_tied[0].name} and {voteable_tied[1].name} will face off in a fire-making challenge. Winner will stay in the game, the loser will be out and will join the jury.")
                return self.conduct_fire_making_challenge(voteable_tied[0], voteable_tied[1])
            else:
                # More than 2 tied at Final 4 - pick 2 randomly
                fire_contestants = random.sample(voteable_tied, 2)
                self.jeff_speaks(f"Since more than two contestants are tied, {fire_contestants[0].name} and {fire_contestants[1].name} will face off in the fire-making challenge.")
                return self.conduct_fire_making_challenge(fire_contestants[0], fire_contestants[1])
        
        # Normal tie handling for non-Final 4
        self.jeff_speaks("We have a tie. According to the Survivor rules, we will have a revote.")
        self.jeff_speaks("You can only vote for the tied contestants. Anyone else is not eligible to receive votes.")
        
        # Filter out idol recipient from voteable contestants
        voteable_tied = [c for c in tied_contestants if c != idol_recipient]
        
        # If idol recipient was in the tie and no one else is tied, no elimination
        if not voteable_tied:
            self.jeff_speaks("Due to the idol play, no one can be voted out. We'll return to camp.")
            return None
        
        # Display the tied contestants
        tied_names = [c.name for c in tied_contestants]
        self.narration(f"The vote is tied between: {', '.join(tied_names)}")
        
        # Player's revote (if player is not in the tie)
        player_vote = None
        if self.player not in voteable_tied and self.player in tribe:
            print("\nIt's your turn to revote. Who would you like to vote for?")
            for i, contestant in enumerate(voteable_tied, 1):
                print(f"{i}. {contestant.name}")
            
            while player_vote is None:
                try:
                    user_input = input("Enter your choice: ")
                    if self.check_for_cheat_code(user_input):
                        continue  # Ask again after cheat menu
                    choice = int(user_input)
                    if 1 <= choice <= len(voteable_tied):
                        player_vote = voteable_tied[choice - 1]
                    else:
                        print("Invalid choice. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter a number.")
            
            self.narration(f"You write down {player_vote.name}'s name and place your revote in the urn.")
        
        # Temporarily reduce game security for all non-immune NPCs due to tie stress
        original_security = {}
        for contestant in tribe:
            if not contestant.is_player and not contestant.immune and not (idol_recipient and contestant == idol_recipient):
                original_security[contestant] = contestant.get_game_security()
                contestant.modify_base_game_security(-2, "Tie vote stress", silent=True)
        
        # NPC revotes
        revotes = {}
        for contestant in tribe:
            # Skip player (already handled) and tied contestants
            # Everyone else can vote, including immune contestants
            if contestant.is_player or contestant in tied_contestants:
                continue
            
            # Determine their vote in the revote
            if len(voteable_tied) > 0:
                target = None
                
                # Check if they voted for one of the tied contestants in the original vote
                original_target = vote_record.get(contestant) if vote_record else None
                voted_for_tied_contestant = original_target and original_target in tied_contestants
                
                if voted_for_tied_contestant and original_target in voteable_tied:
                    # They voted for someone in the tie - roll to see if they flip
                    base_roll = random.randint(1, 20)
                    modified_roll = base_roll
                    
                    # Apply game security modifiers
                    current_security = contestant.get_game_security()
                    if 0 <= current_security <= 3:
                        modified_roll += 2
                    elif 4 <= current_security <= 6:
                        modified_roll += 1
                    
                    if modified_roll >= 13:
                        # Flip vote - choose different target
                        other_tied = [c for c in voteable_tied if c != original_target]
                        if other_tied:
                            target = random.choice(other_tied)
                        else:
                            target = original_target  # Can't flip if only one option
                    else:
                        # Keep same vote
                        target = original_target
                else:
                    # They didn't vote for a tied contestant - use target roster and relationship logic
                    
                    # First, filter out alliance members (unless in alliance with all tied contestants)
                    non_ally_tied = []
                    for tied_contestant in voteable_tied:
                        # Check if in alliance (regular or group alliance)
                        in_alliance = (tied_contestant in contestant.alliance_roster or 
                                     any(tied_contestant in self.group_alliances[gid]['members'] 
                                         for gid in contestant.group_alliances 
                                         if gid in self.group_alliances))
                        if not in_alliance:
                            non_ally_tied.append(tied_contestant)
                    
                    # If in alliance with all tied contestants, use normal logic with all
                    # If in alliance with some but not all, only consider non-allies
                    candidates = non_ally_tied if non_ally_tied else voteable_tied
                    
                    # Check if any candidates are on their target roster
                    tied_on_target_roster = [c for c in candidates if c in contestant.target_roster]
                    
                    if len(tied_on_target_roster) == 1:
                        # Only one candidate on target roster - vote for them
                        target = tied_on_target_roster[0]
                    elif len(tied_on_target_roster) > 1:
                        # Multiple candidates on target roster - vote for lowest relationship
                        lowest_relationship = min(contestant.get_relationship(c) for c in tied_on_target_roster)
                        lowest_relationship_targets = [c for c in tied_on_target_roster 
                                                     if contestant.get_relationship(c) == lowest_relationship]
                        target = random.choice(lowest_relationship_targets)
                    else:
                        # No candidates on target roster - vote for lowest relationship among all candidates
                        lowest_relationship = min(contestant.get_relationship(c) for c in candidates)
                        lowest_relationship_targets = [c for c in candidates 
                                                     if contestant.get_relationship(c) == lowest_relationship]
                        target = random.choice(lowest_relationship_targets)
                
                if target:
                    revotes[target] = revotes.get(target, 0) + 1
        
        # Add player's revote if applicable
        if player_vote:
            revotes[player_vote] = revotes.get(player_vote, 0) + 1
        
        # Read revotes
        self.jeff_speaks("Once the votes are read, the decision is final. The person voted out will be asked to leave the tribal council area immediately. I'll read the revotes.")
        
        # Sort so that the eliminated contestant is revealed last
        revote_order = list(revotes.items())
        if revote_order:
            revote_order.sort(key=lambda x: x[1])
            
            # Helper function to get ordinal numbers
            def get_ordinal(n):
                if n == 1:
                    return "1st"
                elif n == 2:
                    return "2nd"
                elif n == 3:
                    return "3rd"
                else:
                    return f"{n}th"
            
            # Read votes dramatically
            votes_read = 0
            for contestant, vote_count in revote_order:
                for i in range(vote_count):
                    votes_read += 1
                    self.jeff_speaks(f"{get_ordinal(votes_read)} vote, {contestant.name}.")
                    time.sleep(1)
            
            # Check if still tied
            if len(revote_order) > 1 and revote_order[-1][1] == revote_order[-2][1]:
                # If still tied, go to rocks
                eliminated = self.handle_tribal_council_deadlock(tribe, voteable_tied, idol_recipient)
            else:
                # Return eliminated contestant
                eliminated = revote_order[-1][0]
        else:
            # No valid revotes (shouldn't happen but just in case)
            self.jeff_speaks("We have no valid revotes. We'll move to a deadlock procedure.")
            eliminated = self.handle_tribal_council_deadlock(tribe, voteable_tied, idol_recipient)
        
        # Restore original game security after tribal council
        for contestant, orig_security in original_security.items():
            if not contestant.eliminated:  # Only restore if they weren't eliminated
                contestant.modify_base_game_security(2, "Tie vote stress recovery", silent=True)
        
        return eliminated
    
    def handle_tribal_council_deadlock(self, tribe: List[Contestant], tied_contestants: List[Contestant], idol_recipient: Optional[Contestant] = None) -> Contestant:
        """Handle a deadlock at tribal council using the rock-drawing method."""
        self.jeff_speaks("We still have a deadlock. According to Survivor rules, if you can't decide who to vote out, you'll have to draw rocks.")
        
        # Create explanation based on who is exempt
        exempt_reasons = []
        if any(c.immune for c in tribe):
            exempt_reasons.append("those with immunity")
        if idol_recipient:
            exempt_reasons.append("anyone who played an idol")
        exempt_reasons.append("the tied contestants")
        
        if len(exempt_reasons) > 1:
            exempt_text = ", ".join(exempt_reasons[:-1]) + f", and {exempt_reasons[-1]}"
        else:
            exempt_text = exempt_reasons[0]
            
        self.narration(f"Jeff explains that everyone except {exempt_text} will draw rocks. Whoever draws the odd-colored rock will be eliminated.")
        
        # Determine who draws rocks (everyone except immune, idol players, and tied contestants)
        eligible_for_rocks = [c for c in tribe if not c.immune and c not in tied_contestants and c != idol_recipient]
        
        if not eligible_for_rocks:
            # No one can draw rocks - fire-making challenge
            protected_names = []
            if any(c.immune for c in tribe):
                protected_names.extend([c.name for c in tribe if c.immune])
            if idol_recipient:
                protected_names.append(idol_recipient.name)
            
            protected_list = list(set(protected_names))  # Remove duplicates
            
            if len(protected_list) == 1:
                safe_text = f"{protected_list[0]} is safe"
            else:
                safe_text = f"{', '.join(protected_list)} are all safe"
            
            self.jeff_speaks(f"Here's what's going to happen: {safe_text} which means that there is nobody eligible to draw rocks.")
            self.jeff_speaks(f"The elimination is going to be determined by a fire-making challenge between {' and '.join([c.name for c in tied_contestants])}.")
            
            if len(tied_contestants) == 2:
                return self.conduct_fire_making_challenge(tied_contestants[0], tied_contestants[1])
            else:
                # More than 2 tied - pick 2 randomly for fire challenge
                fire_contestants = random.sample(tied_contestants, 2)
                self.jeff_speaks(f"Since more than two contestants are tied, {fire_contestants[0].name} and {fire_contestants[1].name} will face off in the fire-making challenge.")
                return self.conduct_fire_making_challenge(fire_contestants[0], fire_contestants[1])
        
        # If player is eligible for rocks
        if self.player in eligible_for_rocks:
            self.narration("You will be drawing rocks along with the others.")
            
            # 1 in X chance the player draws the odd rock
            player_eliminated = random.choice(eligible_for_rocks) == self.player
            
            if player_eliminated:
                self.narration("You draw a rock and reveal it to be the odd-colored one.")
                return self.player
            else:
                eliminated = random.choice([c for c in eligible_for_rocks if c != self.player])
                self.narration(f"{eliminated.name} draws the odd-colored rock.")
                return eliminated
        else:
            # Player not drawing rocks - explain why
            if self.player == idol_recipient:
                self.narration("Since you played an idol, you are safe from the rock draw.")
            elif self.player.immune:
                self.narration("Since you have immunity, you are safe from the rock draw.")
            elif self.player in tied_contestants:
                self.narration("Since you were tied in the vote, you are safe from the rock draw.")
            
            eliminated = random.choice(eligible_for_rocks)
            self.narration(f"{eliminated.name} draws the odd-colored rock.")
            return eliminated
    
    def read_votes_dramatically(self, votes_to_read: List[Tuple[Contestant, bool]], idol_played: bool, idol_recipient: Optional[Contestant]) -> Optional[Contestant]:
        """Read votes in dramatic Survivor style and return eliminated contestant."""
        
        # Count all votes by contestant
        all_vote_counts = {}
        valid_vote_counts = {}
        
        for contestant, is_nullified in votes_to_read:
            # Count all votes (including nullified)
            all_vote_counts[contestant] = all_vote_counts.get(contestant, 0) + 1
            # Count only valid votes
            if not is_nullified:
                valid_vote_counts[contestant] = valid_vote_counts.get(contestant, 0) + 1
        
        # Determine who will be eliminated (most valid votes)
        if not valid_vote_counts:
            # All votes were nullified by idols
            self.jeff_speaks("All votes have been nullified. No one is going home tonight.")
            return None
        
        # Find elimination target
        max_valid_votes = max(valid_vote_counts.values())
        elimination_candidates = [c for c, v in valid_vote_counts.items() if v == max_valid_votes]
        
        # Store whether this is a tie situation
        is_tie = len(elimination_candidates) > 1
        
        if is_tie:
            # For now, we'll still pick the first candidate for dramatic order
            # but we'll handle the tie announcement differently
            eliminated = elimination_candidates[0]
        else:
            eliminated = elimination_candidates[0]
        
        # Create dramatic reading order
        dramatic_order = []
        
        # Step 1: Add "safe" votes (people with only 1 vote) early to get them out of the way
        for contestant, count in all_vote_counts.items():
            if count == 1 and contestant != eliminated:
                dramatic_order.append((contestant, contestant in valid_vote_counts and not (idol_played and contestant == idol_recipient)))
        
        # Step 2: Add some early votes for the eliminated person as red herrings
        eliminated_votes_added = 0
        eliminated_total = all_vote_counts.get(eliminated, 0)
        early_eliminated_votes = min(2, eliminated_total // 2)  # Add about half early as red herrings
        
        for _ in range(early_eliminated_votes):
            is_valid = eliminated in valid_vote_counts and not (idol_played and eliminated == idol_recipient)
            dramatic_order.append((eliminated, is_valid))
            eliminated_votes_added += 1
        
        # Step 3: Add remaining votes from other contestants
        for contestant, count in all_vote_counts.items():
            if contestant != eliminated and count > 1:
                votes_to_add = count - (1 if count == 1 else 0)  # We already added singles
                for _ in range(votes_to_add):
                    is_valid = contestant in valid_vote_counts and not (idol_played and contestant == idol_recipient)
                    dramatic_order.append((contestant, is_valid))
        
        # Step 4: Add remaining votes for eliminated person, but save one for the final dramatic reveal
        remaining_eliminated = eliminated_total - eliminated_votes_added
        for _ in range(remaining_eliminated - 1):  # Save last vote
            is_valid = eliminated in valid_vote_counts and not (idol_played and eliminated == idol_recipient)
            dramatic_order.append((eliminated, is_valid))
        
        # Read the votes dramatically
        ordinal_numbers = ["1st", "2nd", "3rd", "4th", "5th", "6th", "7th", "8th", "9th", "10th", 
                          "11th", "12th", "13th", "14th", "15th", "16th", "17th", "18th", "19th", "20th"]
        
        for i, (contestant, is_valid) in enumerate(dramatic_order):
            ordinal = ordinal_numbers[i] if i < len(ordinal_numbers) else f"{i+1}th"
            
            if not is_valid:
                self.jeff_speaks(f"{ordinal} vote, {contestant.name}. Does not count.")
            else:
                self.jeff_speaks(f"{ordinal} vote, {contestant.name}.")
            time.sleep(1)
        
        # Dramatic final reveal
        votes_read = len(dramatic_order)
        final_ordinal = ordinal_numbers[votes_read] if votes_read < len(ordinal_numbers) else f"{votes_read+1}th"
        
        # Get elimination position and jury info
        elimination_position = len(self.eliminated_contestants) + 1
        position_str = self.get_position_string(elimination_position)
        is_jury = self.day >= self.merge_day
        
        if is_jury:
            if len(self.jury) == 0:
                jury_str = " and the first member of our jury"
            else:
                jury_position = len(self.jury) + 1
                jury_str = f" and the {self.get_position_string(jury_position)} member of our jury"
        else:
            jury_str = ""
        
        # Final dramatic announcement
        if not is_tie:
            self.jeff_speaks(f"{position_str} person voted out of Survivor{jury_str}...")
        
        self.narration(f"Jeff Probst flips over the final vote to reveal: {eliminated.name}")
        
        # Announce vote count or tie
        final_count = valid_vote_counts[eliminated]
        vote_word = "vote" if final_count == 1 else "votes"
        
        if is_tie:
            # Announce the tie
            tied_names = [c.name for c in elimination_candidates]
            tied_names_str = " and ".join(tied_names)
            
            # Handle the tie here instead of returning
            # Call the existing tie handling method
            from_tribe = elimination_candidates[0].tribe  # Get tribe from one of the tied contestants
            tribe_members = [c for c in self.contestants if c.tribe == from_tribe and not c.eliminated]
            
            # Check if this is Final 4 for special announcement
            if len(tribe_members) == 4:
                self.jeff_speaks(f"{eliminated.name}. We have a tie. {tied_names_str} each have {final_count} {vote_word}.")
            else:
                self.jeff_speaks(f"{eliminated.name}. We have a tie. {tied_names_str} each have {final_count} {vote_word}.")
            
            eliminated = self.handle_tribal_council_tie(tribe_members, elimination_candidates, idol_recipient, None)
            
            # After tie is resolved, continue with normal elimination
            self.jeff_speaks(f"{eliminated.name}, you need to bring me your torch.")
        else:
            self.jeff_speaks(f"{eliminated.name}. That's {final_count}, that's enough. You need to bring me your torch.")
        
        self.narration(f"{eliminated.name} brings {eliminated.get_pronoun('possessive')} torch to Jeff.")
        
        self.jeff_speaks(f"{eliminated.name}, the tribe has spoken.")
        self.narration("Jeff snuffs out the torch.")
        
        return eliminated
    
    def conduct_revote(self, tribe: List[Contestant], protected_contestants: set) -> Optional[Contestant]:
        """Conduct a re-vote when all original votes were nullified by idols."""
        self.narration("The tribe will now vote again.")
        
        # Get eligible targets (exclude protected contestants)
        eligible_targets = [c for c in tribe if c not in protected_contestants]
        
        # Player's re-vote (if not jury spectator)
        player_vote = None
        if not self.player_is_jury_spectator:
            print("\nRe-vote time! Who would you like to vote for?")
            print("(You cannot vote for anyone who had an idol played on them or has immunity)")
            
            for i, contestant in enumerate(eligible_targets):
                if contestant != self.player:
                    print(f"{i + 1}. {contestant.name}")
            
            while player_vote is None:
                try:
                    choice = int(input("Enter your choice: "))
                    valid_targets = [c for c in eligible_targets if c != self.player]
                    if 1 <= choice <= len(valid_targets):
                        player_vote = valid_targets[choice - 1]
                    else:
                        print("Invalid choice. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter a number.")
        
        # Collect re-votes
        revotes = {}
        vote_record = {}
        
        # Add player's vote
        if player_vote:
            revotes[player_vote] = revotes.get(player_vote, 0) + 1
            vote_record[self.player] = player_vote
        
        # NPCs re-vote
        for contestant in tribe:
            if contestant != self.player:
                # NPCs pick from eligible targets (can't vote for protected contestants)
                valid_targets = [c for c in eligible_targets if c != contestant]
                if not valid_targets:
                    continue
                
                target = None
                
                # 1. If the NPC's vote target is valid, vote for their vote target
                if (contestant.vote_target and 
                    contestant.vote_target in valid_targets):
                    target = contestant.vote_target
                
                # 2. If vote target is invalid, vote for someone on their target roster (chosen randomly)
                elif contestant.target_roster:
                    valid_roster_targets = [c for c in contestant.target_roster if c in valid_targets]
                    if valid_roster_targets:
                        target = random.choice(valid_roster_targets)
                
                # 3. If neither vote target nor target roster has valid contestants, choose randomly
                if target is None:
                    target = random.choice(valid_targets)
                
                revotes[target] = revotes.get(target, 0) + 1
                vote_record[contestant] = target
        
        if not revotes:
            self.jeff_speaks("No valid votes were cast in the re-vote.")
            return None
        
        # Find who has the most votes
        max_votes = max(revotes.values())
        tied_contestants = [c for c, v in revotes.items() if v == max_votes]
        
        if len(tied_contestants) > 1:
            # Still a tie after re-vote - handle deadlock scenario
            self.jeff_speaks("We still have a tie after the re-vote.")
            self.jeff_speaks("We are deadlocked.")
            
            # Check who can draw rocks (everyone except tied contestants and protected contestants)
            eligible_for_rocks = [c for c in tribe if c not in tied_contestants and c not in protected_contestants]
            
            if len(eligible_for_rocks) == 0:
                # No one can draw rocks - fire-making challenge
                self.jeff_speaks(f"Here's what's going to happen: {', '.join([c.name for c in protected_contestants])} {'is' if len(protected_contestants) == 1 else 'are all'} safe which means that there is nobody eligible to draw rocks.")
                self.jeff_speaks(f"The elimination is going to be determined by a fire-making challenge between {' and '.join([c.name for c in tied_contestants])}.")
                
                if len(tied_contestants) == 2:
                    eliminated = self.conduct_fire_making_challenge(tied_contestants[0], tied_contestants[1])
                else:
                    # More than 2 tied - for simplicity, pick 2 randomly for fire challenge
                    fire_contestants = random.sample(tied_contestants, 2)
                    self.jeff_speaks(f"Since more than two contestants are tied, {fire_contestants[0].name} and {fire_contestants[1].name} will face off in the fire-making challenge.")
                    eliminated = self.conduct_fire_making_challenge(fire_contestants[0], fire_contestants[1])
            else:
                # Normal rock draw (could be implemented later)
                self.jeff_speaks("We'll proceed to a rock draw.")
                # For now, randomly eliminate one of the tied contestants
                eliminated = random.choice(tied_contestants)
                self.jeff_speaks(f"After the rock draw, {eliminated.name} drew the wrong rock.")
        else:
            eliminated = tied_contestants[0]
        
        # Read the re-vote results
        self.jeff_speaks("Once the votes are read, the decision is final. The person voted out will be asked to leave the tribal council area immediately. I'll read the re-vote.")
        
        for contestant, vote_count in revotes.items():
            for _ in range(vote_count):
                self.jeff_speaks(f"{contestant.name}.")
        
        # Final announcement
        self.jeff_speaks(f"{eliminated.name}, that's enough. You need to bring me your torch.")
        self.narration(f"{eliminated.name} brings {eliminated.get_pronoun('possessive')} torch to Jeff.")
        self.jeff_speaks(f"{eliminated.name}, the tribe has spoken.")
        self.narration("Jeff snuffs out the torch.")
        
        return eliminated
    
    def conduct_fire_making_challenge(self, contestant1: Contestant, contestant2: Contestant) -> Contestant:
        """Conduct a fire-making challenge between two contestants and return the eliminated contestant."""
        
        self.narration(f"{contestant1.name} and {contestant2.name} take their places at their fire making stations")
        
        self.jeff_speaks("Each of you has a flint, a machete, and a box of kindling. You will need to build a fire big enough and strong enough to burn through your rope. Survivors ready? Go.")
        
        self.narration(f"{contestant1.name} and {contestant2.name} start building their fires")
        
        # Roll for each contestant
        # Fire-making uses challenge skill + survival skill + survival status modifier
        contestant1_base_roll = random.randint(1, 20)
        contestant2_base_roll = random.randint(1, 20)
        
        # Handle critical success/failure (natural 20/1 ignore modifiers)
        if contestant1_base_roll == 20:
            contestant1_total = 20  # Critical success
        elif contestant1_base_roll == 1:
            contestant1_total = 1   # Critical failure
        else:
            # Normal roll with modifiers
            contestant1_total = contestant1_base_roll + contestant1.challenge_skill + contestant1.survival_skill
            # Add survival status modifiers
            if contestant1.survival_status == 3:
                contestant1_total += 1
            elif contestant1.survival_status == -1:
                contestant1_total -= 1
        
        if contestant2_base_roll == 20:
            contestant2_total = 20  # Critical success
        elif contestant2_base_roll == 1:
            contestant2_total = 1   # Critical failure
        else:
            # Normal roll with modifiers
            contestant2_total = contestant2_base_roll + contestant2.challenge_skill + contestant2.survival_skill
            # Add survival status modifiers
            if contestant2.survival_status == 3:
                contestant2_total += 1
            elif contestant2.survival_status == -1:
                contestant2_total -= 1
        
        # Determine winner
        if contestant1_total > contestant2_total:
            winner = contestant1
            loser = contestant2
        elif contestant2_total > contestant1_total:
            winner = contestant2
            loser = contestant1
        else:
            # Tie - random winner
            winner = random.choice([contestant1, contestant2])
            loser = contestant2 if winner == contestant1 else contestant1
        
        self.narration(f"{winner.name}'s fire burns through {winner.get_pronoun('possessive')} rope. {winner.name} wins the fire making challenge!")
        
        self.narration(f"{loser.name} brings {loser.get_pronoun('possessive')} torch to Jeff Probst")
        
        return loser
    
    def process_elimination(self, eliminated: Contestant) -> None:
        """Handle the common elimination processing logic."""
        # Jury determination  
        is_jury = self.day >= self.merge_day
        
        # Check if eliminated contestant had an idol and get the tribe beach
        had_idol = len(eliminated.idols) > 0
        eliminated_idol_tribe_beach = None
        if had_idol:
            # Use the most recent idol they found
            eliminated_idol = eliminated.idols[-1]
            eliminated_idol_tribe_beach = eliminated_idol['tribe_beach']
        
        # Update game state
        eliminated.eliminated = True
        self.eliminated_contestants.append(eliminated)
        self.revealed_eliminations.append(eliminated)  # Immediately reveal player's tribe eliminations
        
        # Determine elimination orchestrator (tracked silently for game balance)
        orchestrator = self.determine_elimination_orchestrator(eliminated)
        if orchestrator:
            orchestrator.orchestrated_eliminations += 1
            
            # Add to Game Move Bank (Level 1) unless high threat/security combination
            # Exception: Don't add if orchestrator has threat level 7+ AND game security 7+
            exclude_from_bank = (orchestrator.threat_level >= 7 and 
                                orchestrator.get_game_security() >= 7)
            
            if not exclude_from_bank:
                orchestrator.add_game_move('elimination_orchestrated', 1, self.day, 
                                         f"orchestrated the elimination of {eliminated.name.title()}")
            
            # Add Level 3 game move for eliminating major threat (threat 7+ AND security 7+)
            if (eliminated.threat_level >= 7 and 
                eliminated.get_game_security() >= 7):
                orchestrator.add_game_move('major_threat_elimination', 3, self.day,
                                         f"orchestrated the elimination of {eliminated.name.title()}, who was a major threat")
            
            # Add/Update Level 2 game move for multiple eliminations (3+)
            if orchestrator.orchestrated_eliminations >= 3:
                # Remove any existing orchestration move and add updated one
                orchestrator.remove_game_move('multiple_eliminations_orchestrated')
                count = orchestrator.orchestrated_eliminations
                orchestrator.add_game_move('multiple_eliminations_orchestrated', 2, self.day,
                                         f"orchestrated the elimination of {count} people")
        
        # Lock relationships between the eliminated contestant and all others
        self.lock_relationships_for_elimination(eliminated)
        
        # Clean up final 2 deals involving the eliminated contestant
        if eliminated.final_2_deal:
            # Their final 2 partner loses their deal
            eliminated.final_2_deal.final_2_deal = None
            eliminated.final_2_deal = None
        
        # Remove eliminated contestant from fake final 2 deals
        for contestant in self.contestants:
            if eliminated in contestant.fake_final_2_deals:
                contestant.fake_final_2_deals.remove(eliminated)
        
        if is_jury:
            self.jury.append(eliminated)
            eliminated.voting_history_locked = True  # Lock voting history for jury decisions
            
            # Check if player should become jury spectator
            if eliminated == self.player:
                self.player_is_jury_spectator = True
        
        # Update other contestants' game security for surviving tribal council
        for contestant in self.contestants:
            if not contestant.eliminated and contestant != eliminated:
                contestant.consecutive_correct_votes += 1
        
        # Clear their idols since they're eliminated
        eliminated.idols = []
        eliminated.idol_count = 0
        
        # Hide a new idol if the eliminated contestant had one, only if it came from current tribe's beach
        if had_idol and eliminated_idol_tribe_beach:
            self.hide_new_idol(eliminated_idol_tribe_beach)
        
        # Update target rosters after elimination
        self.update_target_roster_after_elimination(eliminated)
        
        # Update group alliances after elimination
        self.update_group_alliances_after_elimination(eliminated)
        
        # Clean up information banks
        self.clean_info_banks_after_tribal(eliminated)
        
        self.narration(f"{eliminated.name} leaves tribal council.")
        self.narration("The remaining contestants grab their torches and head back to camp.")
        
        # Handle jury continuation for eliminated player
        if eliminated == self.player and is_jury:
            self.handle_jury_continuation()
        # Handle return to Ponderosa for existing jury spectators
        elif self.player_is_jury_spectator:
            self.narration("" + "="*80)
            self.narration("You return to Ponderosa")
            self.narration("" + "="*80)
    
    def handle_jury_continuation(self) -> None:
        """Handle the jury continuation prompt when the player is eliminated."""
        print("\nYou have been voted out of the game. Would you like to continue as a juror?")
        print("1. Yes")
        print("2. No")
        
        while True:
            try:
                choice = input("Enter your choice: ").strip()
                if self.check_for_cheat_code(choice):
                    continue  # Ask again after cheat menu
                choice_num = int(choice)
                if choice_num == 1:
                    # Continue as jury spectator
                    self.player_is_jury_spectator = True
                    self.narration("You proceed to Ponderosa where you'll stay until the end of the game.")
                    break
                elif choice_num == 2:
                    # End the game
                    self.narration("You choose not to continue as a juror. The game ends for you here.")
                    sys.exit(0)
                else:
                    print("Invalid choice. Please enter 1 or 2.")
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    def conduct_tribal_council_questioning(self, tribe: List[Contestant]) -> None:
        """Conduct structured tribal council questioning with Jeff."""
        
        # Define all possible questions with their response logic
        question_pool = [
            {
                "type": "safety",
                "question": "how safe do you feel tonight?",
                "exclude_player": True  # Don't ask player since they don't have game security
            },
            {
                "type": "biggest_threat", 
                "question": "who do you think is the biggest threat in the game?",
                "exclude_player": False
            },
            {
                "type": "alliances",
                "question": "have you noticed any alliances forming?",
                "exclude_player": False
            },
            {
                "type": "vote_impact",
                "question": "how big of an impact will tonight's vote have?",
                "exclude_player": False
            },
            {
                "type": "trust",
                "question": "is there anyone here that you don't trust?",
                "exclude_player": False
            },
            {
                "type": "blindside",
                "question": "is tonight's vote going to be a blindside?",
                "exclude_player": False
            },
            {
                "type": "keep_you",
                "question": "why should the tribe keep you tonight?",
                "exclude_player": False,
                "exclude_immune": True
            }
        ]
        
        # Get eligible contestants for questioning
        eligible_contestants = [c for c in tribe if not (self.player_is_jury_spectator and c == self.player)]
        
        if len(eligible_contestants) < 2:
            return  # Not enough people to question
        
        # Select 2 questions and 2 different contestants
        selected_questions = random.sample(question_pool, 2)
        
        for i, question_data in enumerate(selected_questions):
            # Filter contestants based on question exclusions
            if question_data["exclude_player"]:
                question_eligible = [c for c in eligible_contestants if c != self.player]
            else:
                question_eligible = eligible_contestants.copy()
            
            # Exclude immune contestants if specified
            if question_data.get("exclude_immune", False):
                question_eligible = [c for c in question_eligible if not c.immune]
            
            if not question_eligible:
                continue
                
            # Ensure we don't ask the same person twice if possible
            if i > 0 and len(question_eligible) > 1:
                # Remove previously selected contestant if possible
                prev_contestant = getattr(self, '_last_tribal_questioner', None)
                if prev_contestant in question_eligible and len(question_eligible) > 1:
                    question_eligible.remove(prev_contestant)
            
            # Select contestant to answer
            contestant = random.choice(question_eligible)
            self._last_tribal_questioner = contestant
            
            # Ask question and get response
            self.jeff_speaks(f"{contestant.name}, {question_data['question']}")
            response = self.get_tribal_council_response(contestant, question_data["type"], tribe)
            self.contestant_speaks(contestant, response)
    
    def get_tribal_council_response(self, contestant: Contestant, question_type: str, tribe: List[Contestant]) -> str:
        """Generate appropriate response based on question type and contestant state."""
        
        if question_type == "safety":
            # Safety question responses based on game security and immunity
            if contestant.immune:
                return "I think I'm the only one who can say that they feel 100% safe tonight."
            
            game_security = contestant.get_game_security()
            
            # Create possible responses based on game security
            possible_responses = []
            
            if game_security <= 3:
                possible_responses.append("I don't feel safe at all. I always expect to see my name come up at tribal council.")
            elif 4 <= game_security <= 6:
                possible_responses.append("I've tried to set myself to be safe tonight. I don't expect to be voted out, but I won't be surprised if I am.")
            elif 7 <= game_security <= 10:
                possible_responses.append("I would be really surprised if I'm voted out tonight. I have my plan and I fully expect to see it play out.")
            
            # Always add the numbered scale response as an option
            security_words = ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten"]
            security_word = security_words[min(max(game_security, 0), 10)]
            possible_responses.append(f"On a scale of one to ten, I'd say it's about a {security_word}.")
            
            return random.choice(possible_responses)
        
        elif question_type == "biggest_threat":
            # Find someone to call a threat based on different criteria
            active_tribe = [c for c in tribe if not c.eliminated and c != contestant]
            
            # Try challenge beast response (challenge skill 2+)
            challenge_threats = [c for c in active_tribe if c.challenge_skill >= 2]
            if challenge_threats:
                target = random.choice(challenge_threats)
                pronoun = target.get_pronoun("subject")
                obj_pronoun = target.get_pronoun("object")
                return f"{target.name} is a challenge beast. I think that makes {obj_pronoun} a huge threat."
            
            # Try high threat level response (top 3 threat levels)
            if active_tribe:
                sorted_threats = sorted(active_tribe, key=lambda x: x.threat_level, reverse=True)
                top_threats = sorted_threats[:min(3, len(sorted_threats))]
                if top_threats:
                    target = random.choice(top_threats)
                    return f"I think that most of the tribe sees {target.name} as a big threat."
            
            # Try charismatic response
            charismatic_contestants = [c for c in active_tribe if "charismatic" in [c.positive_attribute.lower(), c.neutral_attribute.lower()]]
            if charismatic_contestants:
                target = random.choice(charismatic_contestants)
                pronoun = target.get_pronoun("object")
                return f"Probably {target.name}. Everyone likes {pronoun}."
            
            # Try social threat response (relationship 2+ with 3+ people)
            for potential_target in active_tribe:
                high_relationships = sum(1 for c in active_tribe if potential_target.get_relationship(c) >= 2)
                if high_relationships >= 3:
                    pronoun = potential_target.get_pronoun("subject")
                    return f"The biggest threat is probably {potential_target.name}. {pronoun.capitalize()} seems to be making a lot of friends out here."
            
            # Fallback
            if active_tribe:
                target = random.choice(active_tribe)
                return f"I think {target.name} is probably the biggest threat right now."
            return "It's hard to say. Everyone here is a threat in their own way."
        
        elif question_type == "alliances":
            responses = [
                "Yeah, it's hard to keep track of it all. I've certainly been trying to make sure that I'm part of the right one.",
                "I'm definitely noticing alliances. The hard part is figuring out which one's are real.",
                "Of course. This game moves really fast and if you're not picking up on alliances then you're doing something wrong."
            ]
            return random.choice(responses)
        
        elif question_type == "vote_impact":
            responses = [
                "Tonight's vote is going to be huge. It could change the entire dynamic of the game.",
                "I think tonight's vote will have a big impact on how the rest of the game plays out.",
                "Every vote is important, but tonight feels especially crucial.",
                "This vote could determine who makes it to the end."
            ]
            return random.choice(responses)
        
        elif question_type == "trust":
            # Try specific untrusted person response
            active_tribe = [c for c in tribe if not c.eliminated and c != contestant]
            untrusted = [c for c in active_tribe 
                        if contestant.get_relationship(c) == -1 and c not in contestant.alliance_roster]
            
            if untrusted:
                target = random.choice(untrusted)
                pronoun = target.get_pronoun("object")
                return f"I think that {target.name} and I don't get along very well so it's hard to trust {pronoun}."
            
            # Generic responses
            responses = [
                "Of course. I'm not going to say who that is though.",
                "I think I've done a pretty good job of figuring out who I can and can't trust.",
                "I try to focus on who I can trust instead of who I can't trust."
            ]
            return random.choice(responses)
        
        elif question_type == "blindside":
            responses = [
                "No, I think the person getting voted out tonight has a pretty good idea it's coming.",
                "I think there's a good chance it will be a blindside.",
                "I think some people will definitely feel blindsided after tonight.",
                "I don't think there's a person here tonight who will feel blindsided if they get voted out."
            ]
            return random.choice(responses)
        
        elif question_type == "keep_you":
            # Try pre-merge challenge strength
            if not self.merged and contestant.challenge_skill >= 2:
                return "They should keep me because they need me in the challenges."
            
            # Try post-merge challenge weakness
            if self.merged and contestant.challenge_skill <= 0:
                return "They should keep me because I'm not winning any immunity challenges any time soon."
            
            # Try hardworking attribute
            if "hardworking" in [contestant.positive_attribute.lower(), contestant.neutral_attribute.lower()]:
                return "They should keep me because I pull my weight around camp."
            
            # Generic responses
            responses = [
                "They should keep me because they agreed to a plan and I know they'll keep their word.",
                "They should keep me because I'm a valuable member of my alliance."
            ]
            return random.choice(responses)
        
        # Fallback
        return "This game is all about making the right moves at the right time."
    
    def tribal_council(self) -> None:
        """Run a tribal council and eliminate a contestant."""
        tribe = self.get_player_tribe()
        
        self.narration("The tribe arrives at tribal council. Each person grabs a torch and dips it into the fire.")
        self.jeff_speaks("Fire represents life in this game. When your fire's gone, so are you.")
        
        # Show immunity status for all contestants
        immune_contestants = [c for c in tribe if c.immune]
        if immune_contestants:
            if len(immune_contestants) == 1:
                self.narration(f"{immune_contestants[0].name} is wearing the immunity necklace and is safe from tonight's vote.")
            else:
                immune_names = ", ".join([c.name for c in immune_contestants])
                self.narration(f"{immune_names} are immune from tonight's vote.")
        
        # If player is jury spectator, show them observing the tribal council
        if self.player_is_jury_spectator:
            self.narration("From your seat in the jury area, you watch the tribal council proceedings intently.")
        
        # Special handling for Final 3 tribal council - skip questioning
        if len(tribe) == 3 and immune_contestants:
            # Final 3: Only the immunity winner votes
            immunity_winner = immune_contestants[0]
            eligible_to_eliminate = [c for c in tribe if not c.immune]
            
            if len(eligible_to_eliminate) != 2:
                self.jeff_speaks("Due to an unusual situation at the Final 3, we'll proceed differently.")
                return
            
            self.jeff_speaks(f"{immunity_winner.name}, as the immunity winner, you have the sole vote tonight. You must choose which of the other two contestants to eliminate.")
            
            # Add voting booth narration
            if immunity_winner.is_player and not self.player_is_jury_spectator:
                self.narration("" + "="*80)
                self.narration("You walk to the voting booth to cast the final vote.")
                self.narration("" + "="*80)
            else:
                self.narration("" + "="*80)
                self.narration(f"{immunity_winner.name} walks to the voting booth to cast the final vote.")
                self.narration("" + "="*80)
            
            if self.player_is_jury_spectator:
                self.narration("You watch as the immunity winner must make the crucial decision of who to take to the Final 2.")
            
            # Determine who the immunity winner chooses to eliminate
            if immunity_winner.is_player and not self.player_is_jury_spectator:
                # Player is immunity winner and making the choice
                print(f"\nYou must choose who to eliminate:")
                for i, contestant in enumerate(eligible_to_eliminate, 1):
                    print(f"{i}. {contestant.name}")
                
                while True:
                    try:
                        choice = int(input("Who do you choose to eliminate? "))
                        if 1 <= choice <= len(eligible_to_eliminate):
                            eliminated = eligible_to_eliminate[choice - 1]
                            break
                        else:
                            print("Invalid choice. Please try again.")
                    except ValueError:
                        print("Invalid input. Please enter a number.")
                
                self.narration(f"You choose to eliminate {eliminated.name}.")
            else:
                # NPC is immunity winner - they make the choice
                # Choose based on relationships and strategy
                best_choice = None
                best_score = float('-inf')
                
                for candidate in eligible_to_eliminate:
                    score = 0
                    # Prefer to eliminate stronger competitors
                    score -= candidate.threat_level
                    # Consider relationship (might eliminate someone they dislike)
                    relationship = immunity_winner.get_relationship(candidate)
                    if relationship < 0:
                        score += 5  # More likely to eliminate if bad relationship
                    elif relationship > 2:
                        score -= 3  # Less likely to eliminate close allies
                    
                    if score > best_score:
                        best_score = score
                        best_choice = candidate
                
                eliminated = best_choice if best_choice else random.choice(eligible_to_eliminate)
                self.narration(f"{immunity_winner.name} takes a moment to consider the decision.")
            
            # Jeff's vote retrieval dialogue
            self.jeff_speaks("I'll get the vote.")
            
            self.narration("" + "="*80)
            self.narration("Jeff retrieves the urn and returns to face the tribe.")
            self.narration("" + "="*80)
            
            self.jeff_speaks("Once the vote is read, the decision is final. The person voted out will be asked to leave the tribal council area immediately. I'll read the vote.")
            
            self.narration("Jeff retrieves the sole vote from the urn.")
            
            # Calculate elimination position for announcement
            elimination_position = len(self.eliminated_contestants) + 1
            position_str = self.get_position_string(elimination_position)
            is_jury = self.day >= self.merge_day
            
            if is_jury:
                if len(self.jury) == 0:
                    jury_str = " and the first member of our jury"
                else:
                    jury_position = len(self.jury) + 1
                    jury_str = f" and the {self.get_position_string(jury_position)} member of our jury"
            else:
                jury_str = ""
            
            # Final dramatic announcement and vote reading
            self.jeff_speaks(f"{position_str} person voted out of Survivor{jury_str}...")
            
            self.narration(f"Jeff Probst flips over the final vote to reveal: {eliminated.name}")
            
            self.jeff_speaks(f"{eliminated.name}, the tribe has spoken.")
            self.narration("Jeff snuffs out the torch.")
            
            # Handle elimination
            eliminated.eliminated = True
            self.eliminated_contestants.append(eliminated)
            
            # Clean up information banks
            self.clean_info_banks_after_tribal(eliminated)
            
            # Final 2 setup
            self.narration("The Final 2 has been determined.")
            return
        
        # Regular tribal council - conduct questioning first
        self.conduct_tribal_council_questioning(tribe)
        
        # Regular tribal council voting
        first_voter = random.choice([c for c in tribe if c != self.player])
        self.jeff_speaks(f"It IS time to vote. {first_voter.name}, you're up first.")
        
        self.narration("One by one, the contestants go up to vote...")
        
        # Handle jury spectator vs active player voting
        if self.player_is_jury_spectator:
            # Simulate voting for NPCs only
            eligible_to_vote_for = [c for c in tribe if not c.immune]
        else:
            # Player's vote
            eligible_to_vote_for = [c for c in tribe if not c.immune and c != self.player]
        
        if not eligible_to_vote_for:
            self.jeff_speaks("Due to an unusual situation, there's no one eligible to vote for. We'll skip this tribal council.")
            return
        
        player_vote = None
        if not self.player_is_jury_spectator:
            print("\nIt's your turn to vote. Who would you like to vote for?")
            if self.player.vote_target and self.player.vote_target in eligible_to_vote_for:
                print(f"(Your current vote target: {self.player.vote_target.name})")
            elif self.player.vote_target:
                print(f"(Your vote target {self.player.vote_target.name} is not eligible to vote for)")
            else:
                print("(You haven't assigned a vote target yet)")
            for i, contestant in enumerate(eligible_to_vote_for, 1):
                print(f"{i}. {contestant.name}")
            
            while player_vote is None:
                try:
                    user_input = input("Enter your choice: ")
                    if self.check_for_cheat_code(user_input):
                        continue  # Ask again after cheat menu
                    choice = int(user_input)
                    if 1 <= choice <= len(eligible_to_vote_for):
                        player_vote = eligible_to_vote_for[choice - 1]
                    else:
                        print("Invalid choice. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter a number.")
        
        # Voting confessional prompt (only for active players)
        if not self.player_is_jury_spectator:
            print("\nWhat would you like to say as you cast your vote?")
            confessional = input("> ")
            
            self.narration(f"You write down {player_vote.name}'s name. You hold your vote up to the camera and say \"{confessional}\"")
        
        # Track who voted for whom (for information banks)
        vote_record = {}
        if not self.player_is_jury_spectator:
            vote_record[self.player] = player_vote
        
        # Other contestants' votes
        votes = {}
        for contestant in tribe:
            if contestant != self.player:
                # Check if this contestant has a valid vote target
                if (contestant.vote_target and 
                    not contestant.vote_target.immune and 
                    contestant.vote_target in tribe and
                    not contestant.vote_target.eliminated):
                    
                    # Check if alliance or work protection applies to the target
                    target = contestant.vote_target
                    
                    # Apply work protection (only protection that overrides vote targets)
                    if (target == self.player and 
                        random.randint(1, 100) <= contestant.vote_protection):
                        # Need to find a new target due to work protection
                        self.assign_random_vote_target(contestant)
                        target = contestant.vote_target
                    
                    # If still have a valid target, vote for them
                    if (target and 
                        not target.immune and 
                        target in tribe and
                        not target.eliminated and
                        target != contestant):
                        votes[target] = votes.get(target, 0) + 1
                        vote_record[contestant] = target
                    else:
                        # Fallback to random valid target
                        valid_targets = [c for c in tribe if not c.immune and c != contestant]
                        if valid_targets:
                            target = random.choice(valid_targets)
                            votes[target] = votes.get(target, 0) + 1
                            vote_record[contestant] = target
                else:
                    # No valid vote target, assign a new random one
                    self.assign_random_vote_target(contestant)
                    if (contestant.vote_target and 
                        not contestant.vote_target.immune and 
                        contestant.vote_target in tribe and
                        contestant.vote_target != contestant):
                        votes[contestant.vote_target] = votes.get(contestant.vote_target, 0) + 1
                        vote_record[contestant] = contestant.vote_target
        
        # Add player's vote (only if not jury spectator)
        if not self.player_is_jury_spectator and player_vote:
            votes[player_vote] = votes.get(player_vote, 0) + 1
        
        # Check vote pitch agreements and give relationship bonuses/penalties (only for active players)
        if not self.player_is_jury_spectator:
            for pitcher, agreed_target in list(self.player.vote_pitch_agreements.items()):
                # Check if player voted for the agreed target AND the pitcher still has that same target
                if player_vote == agreed_target and pitcher.vote_target == agreed_target:
                    pitcher.modify_relationship(self.player, 1)
                    # Relationship improves silently for following through on vote agreement
                elif player_vote != agreed_target and pitcher.vote_target == agreed_target and not agreed_target.eliminated:
                    # Player broke their promise AND the target wasn't eliminated anyway - calculate slips for each consequence
                    option1_slips = 4  # Base slips for Option 1
                    option2_slips = 4  # Base slips for Option 2
                    option3_slips = 4  # Base slips for Option 3
                    
                    # Get current relationship
                    relationship = self.player.get_relationship(pitcher)
                    
                    # Apply modifiers for Option 1
                    # +1 if more than 2 people voted for the agreed target
                    votes_for_agreed_target = votes.get(agreed_target, 0)
                    if votes_for_agreed_target > 2:
                        option1_slips += 1
                    
                    # +1 if relationship is 2 or higher
                    if relationship >= 2:
                        option1_slips += 1
                    
                    # -1 if relationship is 0 or lower
                    if relationship <= 0:
                        option1_slips = max(0, option1_slips - 1)
                    
                    # -1 if ever been busted by this person
                    if self.player in pitcher.busted_penalties:
                        option1_slips = max(0, option1_slips - 1)
                    
                    # Apply modifiers for Option 2
                    # If relationship is already -1, convert all Option 2 slips to Option 3
                    if relationship <= -1:
                        option3_slips += option2_slips
                        option2_slips = 0
                    
                    # Apply modifiers for Option 3
                    # +1 if relationship is -1
                    if relationship == -1:
                        option3_slips += 1
                    
                    # +1 if player is on the pitcher's target roster
                    if self.player in pitcher.target_roster:
                        option3_slips += 1
                    
                    # -1 if in an alliance with the pitcher
                    if self.player in pitcher.alliance_roster:
                        option3_slips = max(0, option3_slips - 1)
                    
                    # -1 if relationship is 2 or higher
                    if relationship >= 2:
                        option3_slips = max(0, option3_slips - 1)
                    
                    # Draw from hat with calculated slips
                    total_slips = option1_slips + option2_slips + option3_slips
                    consequence_draw = random.randint(1, total_slips)
                    
                    if consequence_draw <= option1_slips:  # Option 1: No penalty
                        pass  # No consequence
                    elif consequence_draw <= option1_slips + option2_slips:  # Option 2: Relationship penalty
                        pitcher.modify_relationship(self.player, -1)
                        # Check for alliance breaking due to relationship falling to -1
                        self.check_relationship_alliance_breaking(pitcher, self.player)
                        # Track for next day confrontation
                        self.player.vote_pitch_confrontations.append((pitcher, agreed_target))
                    else:  # Option 3: Become their target
                        pitcher.vote_target = self.player
                        if self.player not in pitcher.target_roster:
                            pitcher.target_roster.append(self.player)
                        # Track for next day confrontation
                        self.player.vote_pitch_confrontations.append((pitcher, agreed_target))
            
            # Clear vote pitch agreements after tribal council
            self.player.vote_pitch_agreements.clear()
        
        # Idol play
        self.jeff_speaks("I'll go tally the votes.")
        self.narration("Jeff retrieves the urn and returns to face the tribe.")
        
        # Check if idols can still be played (not at final 4 or later)
        active_count = len(self.get_active_contestants())
        can_play_idols = active_count > 4
        
        if can_play_idols:
            self.jeff_speaks("If anybody has a hidden immunity idol and would like to play it, now would be the time to do so.")
        else:
            # Remove any remaining idols since they're now expired
            for contestant in self.contestants:
                contestant.idol_count = 0
        
        # Player idol play
        idol_played = False
        idol_recipient = None
        idol_player = None
        
        if can_play_idols and self.player.has_idol and not self.player_is_jury_spectator:
            # Clean up any corrupted idol data
            self.player.idols = [idol for idol in self.player.idols if isinstance(idol, dict)]
            actual_idol_count = len(self.player.idols)
            
            # Fallback safety check
            if actual_idol_count <= 0:
                actual_idol_count = max(1, self.player.idol_count)
                
            idol_text = "idol" if actual_idol_count == 1 else f"one of your {actual_idol_count} idols"
            while True:
                play_idol_input = input(f"Would you like to play {idol_text}? (yes/no): ").lower().strip()
                if self.check_for_cheat_code(play_idol_input):
                    continue  # Ask again after cheat menu
                if play_idol_input in ["yes", "no"]:
                    break
                print("Please enter 'yes' or 'no'.")
            
            if play_idol_input == "yes":
                # Ask who to play the idol on
                other_contestants = [c for c in tribe if c != self.player]
                print("\nWho would you like to play the idol on?")
                print("1. Yourself")
                for i, contestant in enumerate(other_contestants):
                    print(f"{i + 2}. {contestant.name}")
                
                while True:
                    try:
                        choice = input("\nEnter your choice: ").strip()
                        if self.check_for_cheat_code(choice):
                            continue  # Ask again after cheat menu
                        choice_num = int(choice)
                        if choice_num == 1:
                            idol_recipient = self.player
                            self.narration("You stand up and approach Jeff with your idol.")
                            self.jeff_speaks("This is a hidden immunity idol. Any votes cast against you will not count.")
                            break
                        elif 2 <= choice_num <= len(other_contestants) + 1:
                            # Find the contestant at this position (adjusted for 1-based indexing)
                            idol_recipient = other_contestants[choice_num - 2]
                            self.narration(f"You stand up and approach Jeff with your idol.")
                            self.contestant_speaks(self.player, f"Jeff, I'm playing this idol for {idol_recipient.name}.")
                            self.jeff_speaks(f"This is a hidden immunity idol. Any votes cast against {idol_recipient.name} will not count.")
                            break
                        else:
                            print("Invalid choice. Please try again.")
                    except ValueError:
                        print("Please enter a number.")
                
                idol_played = True
                idol_player = self.player
                # Remove the most recently found idol
                if self.player.idols:
                    played_idol = self.player.idols.pop()
                    self.player.idol_count = len(self.player.idols)  # Keep count in sync with actual idols list
                else:
                    played_idol = {'tribe_beach': self.player.tribe, 'found_day': self.day}
                    self.player.idol_count = 0  # Ensure count doesn't go negative
                
                if self.player.idol_count > 0:
                    self.narration(f"You have {self.player.idol_count} idol{'s' if self.player.idol_count > 1 else ''} remaining.")
                # Hide a new idol only if it came from the current tribe's beach
                self.hide_new_idol(played_idol['tribe_beach'])
        
        # NPC idol play
        if can_play_idols:
            npc_played_idol = False
            for contestant in tribe:
                if npc_played_idol:
                    break
                if contestant != self.player and contestant.has_idol:
                    # Check if someone this NPC is voting for just played an idol on themselves
                    vote_target_played_idol = (idol_played and 
                                             idol_recipient and 
                                             contestant.vote_target == idol_recipient and
                                             idol_recipient != contestant and
                                             votes.get(contestant) == idol_recipient)
                    # Roll separately for each idol the NPC possesses
                    for idol_num in range(contestant.idol_count):
                        # Roll d20 to decide if NPC plays idol on themselves
                        base_roll = random.randint(1, 20)
                        modified_roll = base_roll
                    
                        # Check if NPC knows they are the consensus vote
                        # They know if multiple people have told them or if they have strong perception
                        vote_info_count = sum(1 for info in contestant.information_bank 
                                            if info.get('type') == 'voting_against' 
                                            and info.get('target') == contestant
                                            and info.get('day') == self.day)
                        knows_consensus = vote_info_count >= 2 or (vote_info_count >= 1 and contestant.perception_skill >= 2)
                        
                        # Apply modifiers
                        if knows_consensus:
                            modified_roll += 5
                        
                        current_security = contestant.get_game_security()
                        if 1 <= current_security <= 4:
                            modified_roll += 2
                        elif 7 <= current_security <= 9:
                            modified_roll -= 2
                        elif current_security == 10:
                            modified_roll -= 10
                        
                        # If their vote target just played an idol, they automatically play on themselves
                        # Otherwise, 11-20 = play idol on self, 1-10 = don't play (or consider playing on someone else)
                        if vote_target_played_idol or modified_roll >= 11:
                            if vote_target_played_idol:
                                self.narration(f"{contestant.name} sees {contestant.vote_target.name} play an idol and immediately stands up with their own idol.")
                            else:
                                self.narration(f"{contestant.name} stands up and approaches Jeff with an idol.")
                            self.jeff_speaks(f"This is a hidden immunity idol. Any votes cast against {contestant.name} will not count.")
                            idol_played = True
                            npc_played_idol = True
                            idol_player = contestant
                            idol_recipient = contestant
                            # Remove the most recently found idol
                            played_idol = contestant.idols.pop() if contestant.idols else {'tribe_beach': contestant.tribe, 'found_day': self.day}
                            contestant.idol_count -= 1
                            if contestant.idol_count > 0:
                                # Don't reveal to player how many idols NPC has left
                                pass
                            # Hide a new idol only if it came from the current tribe's beach
                            self.hide_new_idol(played_idol['tribe_beach'])
                            break  # Break out of idol loop for this contestant
                        else:
                            # NPC chose not to play idol on self - consider playing on someone else
                            potential_recipients = []
                            
                            # Check each other contestant in the tribe
                            for other in tribe:
                                if other == contestant or other == self.player:
                                    continue
                                
                                # Don't consider playing idol on someone who already has immunity
                                if other.immune:
                                    continue
                                    
                                # Check all 4 conditions
                                # 1. Must be in alliance
                                in_alliance = (other in contestant.alliance_roster or 
                                             any(other in self.group_alliances[gid]['members'] 
                                                 for gid in contestant.group_alliances 
                                                 if gid in self.group_alliances))
                                
                                if not in_alliance:
                                    continue
                                
                                # 2. Must know someone is voting for them or they're consensus
                                vote_info_against_other = sum(1 for info in contestant.information_bank 
                                                            if info.get('type') == 'voting_against' 
                                                            and info.get('target') == other
                                                            and info.get('day') == self.day)
                                knows_other_targeted = vote_info_against_other >= 1
                                knows_other_consensus = vote_info_against_other >= 2
                                
                                if not knows_other_targeted:
                                    continue
                                
                                # 3. Must have relationship 2+
                                if contestant.get_relationship(other) < 2:
                                    continue
                                
                                # 4. Must not have them as vote target
                                if contestant.vote_target == other:
                                    continue
                                
                                # All conditions met - add to potential recipients
                                potential_recipients.append((other, knows_other_consensus))
                            
                            # Roll for each potential recipient
                            if potential_recipients:
                                best_roll = 0
                                best_recipient = None
                                
                                for other, is_consensus in potential_recipients:
                                    # Base d20 roll
                                    roll = random.randint(1, 20)
                                    
                                    # Apply modifiers
                                    if is_consensus:
                                        roll += 2
                                    if contestant.has_real_final_2_with(other):
                                        roll += 3
                                    if other in contestant.target_roster:
                                        roll -= 2
                                    
                                    # Check if this is the best roll so far (14+ required to play)
                                    if roll >= 14 and roll > best_roll:
                                        best_roll = roll
                                        best_recipient = other
                                
                                # Play idol on best recipient if any
                                if best_recipient:
                                    self.narration(f"{contestant.name} stands up and approaches Jeff with an idol.")
                                    self.contestant_speaks(contestant, f"Jeff, I'm playing this idol for {best_recipient.name}.")
                                    self.jeff_speaks(f"This is a hidden immunity idol. Any votes cast against {best_recipient.name} will not count.")
                                    idol_played = True
                                    npc_played_idol = True
                                    idol_player = contestant
                                    idol_recipient = best_recipient
                                    # Remove the most recently found idol
                                    played_idol = contestant.idols.pop() if contestant.idols else {'tribe_beach': contestant.tribe, 'found_day': self.day}
                                    contestant.idol_count -= 1
                                    # Hide a new idol only if it came from the current tribe's beach
                                    self.hide_new_idol(played_idol['tribe_beach'])
                                    break  # Break out of idol loop for this contestant
                    
                    # If an idol was played, break out of the contestant loop
                    if npc_played_idol:
                        break
        
        # Create a copy of votes before removing idol recipient votes for counting
        all_votes = votes.copy()
        
        # Check if idol play was successful (would have been eliminated without it)
        successful_idol_play = False
        if idol_played and idol_recipient in votes:
            # Check if they would have been eliminated without the idol
            vote_counts = list(votes.values())
            idol_votes = votes[idol_recipient]
            max_votes = max(vote_counts) if vote_counts else 0
            
            # Successful if they had the most votes or tied for most
            if idol_votes >= max_votes:
                successful_idol_play = True
        
        # Adjust votes if idol was played (for elimination purposes)
        if idol_played and idol_recipient in votes:
            del votes[idol_recipient]
        
        # Add tension moment if nobody played an idol
        if can_play_idols and not idol_played:
            self.narration("There is a brief moment of tension... nobody stands up to play an idol.")
        
        # Read votes
        self.jeff_speaks("Once the votes are read, the decision is final. The person voted out will be asked to leave the tribal council area immediately. I'll read the votes.")
        
        # Combine both valid votes and nullified votes for reading
        votes_to_read = []
        
        # Add all votes including nullified ones
        for contestant, vote_count in all_votes.items():
            # Call receive_vote_at_tribal once per contestant who received any votes (for game security)
            contestant.receive_vote_at_tribal()
            
            # Add each individual vote to the list to read
            for i in range(vote_count):
                is_nullified = idol_played and contestant == idol_recipient
                votes_to_read.append((contestant, is_nullified))
        
        # Sort votes: put nullified votes first, then sort remaining by contestant
        # This ensures dramatic buildup while showing all votes
        random.shuffle(votes_to_read)  # Shuffle for variety
        
        # Create dramatic vote reading order
        eliminated = self.read_votes_dramatically(votes_to_read, idol_played, idol_recipient)
            
        # Handle elimination or no elimination
        if eliminated is None:
            # No elimination due to all votes being nullified by idols - trigger re-vote
            self.jeff_speaks("Due to the idol play, no one received any valid votes.")
            
            # Determine who is ineligible for the re-vote (anyone protected by idols or immunity)
            protected_contestants = set()
            
            # Add anyone who had an idol played on them (check votes_to_read for nullified votes)
            for contestant, is_nullified in votes_to_read:
                if is_nullified:
                    protected_contestants.add(contestant)
            
            # Add anyone with immunity
            for contestant in tribe:
                if contestant.immune:
                    protected_contestants.add(contestant)
            
            # Create message about who is protected
            protected_names = [c.name for c in protected_contestants]
            
            if len(protected_names) == 1:
                self.jeff_speaks(f"We'll have a re-vote. You cannot vote for {protected_names[0]}.")
            elif len(protected_names) == 2:
                self.jeff_speaks(f"We'll have a re-vote. You cannot vote for {protected_names[0]} or {protected_names[1]}.")
            else:
                names_str = ", ".join(protected_names[:-1]) + f", or {protected_names[-1]}"
                self.jeff_speaks(f"We'll have a re-vote. You cannot vote for {names_str}.")
            
            # Get eligible targets for re-vote
            eligible_for_revote = [c for c in tribe if c not in protected_contestants]
            
            if len(eligible_for_revote) <= 1:
                # Edge case: only 1 or 0 people can be voted for
                self.jeff_speaks("Due to the protections in place, we cannot proceed with a re-vote.")
                self.jeff_speaks("We'll return to camp and hold tribal council again tomorrow.")
                self.narration("The tribe grabs their torches and heads back to camp.")
            else:
                # Proceed with re-vote
                eliminated = self.conduct_revote(tribe, protected_contestants)
                if eliminated:
                    # Handle the elimination from re-vote
                    self.process_elimination(eliminated)
        else:
            # Someone was eliminated - handle the elimination
            self.process_elimination(eliminated)
            
        # Update threat level if idol was played successfully
        if successful_idol_play and idol_recipient:
            idol_recipient.threat_level = min(10, idol_recipient.threat_level + 1)
            
            # Add Level 2 game moves for successful idol plays
            if idol_player:
                if idol_player == idol_recipient:
                    # Self-play
                    idol_player.add_game_move('successful_self_idol_play', 2, self.day, 
                                            "saved myself with a hidden immunity idol")
                else:
                    # Played for someone else
                    idol_player.add_game_move('successful_other_idol_play', 2, self.day, 
                                            f"saved {idol_recipient.name} with a hidden immunity idol")
        
        # Reset immunity after tribal council
        # Alliances, vote targets and target rosters persist through tribal councils
        for contestant in self.contestants:
            contestant.immune = False  # Reset immunity after tribal council
            
        # Restore vote targets that were displaced due to immunity
        self.restore_immunity_displaced_vote_targets()
        
        # Reset orchestration tracking for new cycle
        self.reset_orchestration_tracking()
        
        # Clean up outdated information from all info banks FIRST
        # This removes old previous_vote information before adding new ones
        # Pass eliminated contestant (if any) and idol recipient (if any)
        eliminated_contestant = eliminated if 'eliminated' in locals() else None
        self.clean_info_banks_after_tribal(eliminated_contestant, idol_recipient)
        
        # Add previous vote information to all contestants' info banks AFTER cleanup
        for voter, target in vote_record.items():
            # Update most recent votes tracking
            self.most_recent_votes[voter] = (target, self.day)
            
            # Update comprehensive vote history tracking
            if voter not in self.vote_history:
                self.vote_history[voter] = []
            self.vote_history[voter].append(target)
            
            # Add to the voter's own info bank (they know who they voted for)
            voter.add_information('previous_vote', voter, target)
            voter.information_bank[-1]['day'] = self.day
        
        # Track votes received for each contestant at this tribal
        tribe = self.get_player_tribe()
        self.last_tribal_vote_counts = {}
        for contestant in tribe:
            # Count votes from all_votes (includes nullified votes)
            self.last_tribal_vote_counts[contestant] = all_votes.get(contestant, 0)
        
        # Update all threat levels after tribal council
        self.update_all_threat_levels()
        
        # Track major threat survival for Level 3 game move
        self.track_major_threat_survival()
    
    def track_major_threat_survival(self) -> None:
        """Track contestants who survive tribal council with threat level 7+ for Level 3 game move."""
        for contestant in self.get_active_contestants():
            if contestant.threat_level >= 7:
                contestant.tribal_councils_survived_as_major_threat += 1
                
                # Add Level 3 game move if they've survived 4+ tribals as major threat and make final 2
                # Check this when only 2 contestants remain
                if (contestant.tribal_councils_survived_as_major_threat >= 4 and 
                    len(self.get_active_contestants()) == 2):
                    contestant.add_game_move('major_threat_survival', 3, self.day,
                                           "made it to the final 2 as a major threat")
    
    def clean_info_banks_after_tribal(self, eliminated_contestant: Optional[Contestant] = None, 
                                      idol_recipient: Optional[Contestant] = None) -> None:
        """Remove outdated information from all contestants' info banks after tribal council."""
        for contestant in self.contestants:
            if contestant.information_bank:
                # Create a new list with only information that remains relevant
                updated_info_bank = []
                
                for info in contestant.information_bank:
                    # Always remove these types of information:
                    # - vote_target (vote targets reassigned)
                    # - vote_pitch (old vote discussions no longer relevant)
                    # - previous_vote (will be replaced with new vote information)
                    # - consensus_vote (consensus changes after each vote)
                    # Note: alliance information persists now
                    if info['type'] in ['vote_target', 'vote_pitch', 'previous_vote', 'consensus_vote']:
                        continue
                    
                    # Handle alliance information - only remove if person was eliminated
                    if info['type'] == 'alliance':
                        if eliminated_contestant and (info.get('subject') == eliminated_contestant or info.get('target') == eliminated_contestant):
                            continue  # Remove alliance info involving eliminated contestant
                    
                    # Handle Final 2 information - remove if person was eliminated
                    if info['type'] in ['final_2', 'final_2_pitch', 'has_final_2']:
                        if eliminated_contestant:
                            if info['type'] == 'final_2' and (info.get('subject') == eliminated_contestant or info.get('target') == eliminated_contestant):
                                continue  # Remove final 2 info involving eliminated contestant
                            elif info['type'] == 'final_2_pitch' and (info.get('subject') == eliminated_contestant or info.get('target') == eliminated_contestant):
                                continue  # Remove final 2 pitch info involving eliminated contestant
                            elif info['type'] == 'has_final_2' and info.get('subject') == eliminated_contestant:
                                continue  # Remove has_final_2 info about eliminated contestant
                    
                    # Handle idol information
                    if info['type'] == 'has_idol':
                        # Remove if the person was eliminated with the idol
                        if eliminated_contestant and info.get('subject') == eliminated_contestant:
                            continue
                        # Remove if the person played their idol
                        if idol_recipient and info.get('subject') == idol_recipient:
                            continue
                        # Otherwise keep it (they still have the idol)
                        updated_info_bank.append(info)
                    
                    # Keep target_roster information (persists through tribal)
                    elif info['type'] == 'target_roster':
                        updated_info_bank.append(info)
                    
                    # Keep any other information types
                    else:
                        updated_info_bank.append(info)
                
                # Replace the info bank with the cleaned version
                contestant.information_bank = updated_info_bank
    
    def clean_cross_tribe_vote_pitches(self) -> None:
        """Remove vote pitch information from players who are no longer in the same tribe."""
        for contestant in self.contestants:
            if contestant.information_bank:
                updated_info_bank = []
                
                for info in contestant.information_bank:
                    # Remove vote pitch information if the pitcher is from a different tribe
                    if info['type'] == 'vote_pitch':
                        pitcher = info.get('subject')
                        if pitcher and not pitcher.eliminated and pitcher.tribe != contestant.tribe:
                            continue  # Skip this vote pitch - pitcher is from different tribe
                        # Also remove if the target is from a different tribe (though less common)
                        target = info.get('target')
                        if target and not target.eliminated and target.tribe != contestant.tribe:
                            continue  # Skip this vote pitch - target is from different tribe
                    
                    # Keep all other information
                    updated_info_bank.append(info)
                
                # Replace the info bank with the cleaned version
                contestant.information_bank = updated_info_bank
    
    def hide_new_idol(self, played_idol_tribe_beach: str) -> None:
        """Hide a new idol after one is played, but only if it came from the current tribe's beach."""
        # Don't hide new idols if we're at final 5 or later (since idols expire at final 4)
        active_count = len(self.get_active_contestants())
        if active_count <= 5:
            return
        
        # Post-merge: only hide merge idols if the played idol came from the current tribe
        if self.merged:
            merge_name = getattr(self, 'merge_tribe_name', 'Merged')
            # Only re-hide if the played idol came from the merge tribe
            if played_idol_tribe_beach == merge_name:
                self.idol_found_merge = False  # Make it available to be found again
        else:
            # Pre-merge: only re-hide if the played idol came from the current tribe's beach
            current_tribe_name = self.player.tribe
            if played_idol_tribe_beach == current_tribe_name:
                if current_tribe_name == self.tribe1_name:
                    self.idol_found_tribe1 = False
                elif current_tribe_name == self.tribe2_name:
                    self.idol_found_tribe2 = False
            # If played idol came from a different tribe's beach, don't re-hide
    
    def assign_vote_target_with_priority(self, recipient: Contestant, pitcher: Contestant, target: Contestant, roll_total: int) -> None:
        """Assign vote target considering alliance priority and roll values.
        
        Priority order:
        1. Alliance member with recipient (if only one pitcher has alliance)
        2. Highest roll (if both or neither have alliance)
        3. Most recent pitch (if tied roll)
        """
        # Initialize pitch history for recipient if needed
        if recipient not in self.vote_pitch_history:
            self.vote_pitch_history[recipient] = []
        
        # Add the new pitch to history
        self.vote_pitch_history[recipient].append((pitcher, target, roll_total, self.day))
        
        # Get all pitches for this recipient from today
        today_pitches = [(p, t, r, d) for p, t, r, d in self.vote_pitch_history[recipient] if d == self.day]
        
        if len(today_pitches) == 1:
            # Only one pitch today, accept it
            previous_vote_target = recipient.vote_target
            self.track_first_pitch_for_target(pitcher, target)
            recipient.vote_target = target
            # Safety check - ensure no cross-tribe targeting in pre-merge
            if not self.merged and recipient.vote_target and recipient.vote_target.tribe != recipient.tribe:
                recipient.vote_target = previous_vote_target  # Revert to previous target
                return
            self.track_successful_pitch(pitcher, target, recipient, previous_vote_target)
            return
        
        # Multiple pitches today - need to determine priority
        best_pitch = None
        best_score = -1
        
        for i, (pitch_pitcher, pitch_target, pitch_roll, pitch_day) in enumerate(today_pitches):
            # Calculate priority score
            score = 0
            
            # Check alliance status
            has_alliance = (recipient.has_real_alliance_with(pitch_pitcher) or 
                          recipient.has_fake_alliance_with(pitch_pitcher))
            
            # Alliance bonus: 1000 points (ensures alliance always wins over non-alliance)
            if has_alliance:
                score += 1000
            
            # Roll bonus: Add the actual roll value
            score += pitch_roll
            
            # Recency bonus: 0.1 point per position (ensures most recent wins ties)
            score += i * 0.1
            
            if score > best_score:
                best_score = score
                best_pitch = (pitch_pitcher, pitch_target, pitch_roll, pitch_day)
        
        # Apply the best pitch
        if best_pitch:
            previous_vote_target = recipient.vote_target
            winning_pitcher = best_pitch[0]
            winning_target = best_pitch[1]
            self.track_first_pitch_for_target(winning_pitcher, winning_target)
            recipient.vote_target = winning_target  # Set to the target from best pitch
            # Safety check - ensure no cross-tribe targeting in pre-merge
            if not self.merged and recipient.vote_target and recipient.vote_target.tribe != recipient.tribe:
                recipient.vote_target = previous_vote_target  # Revert to previous target
                return
            self.track_successful_pitch(winning_pitcher, winning_target, recipient, previous_vote_target)
    
    def get_position_string(self, position: int) -> str:
        """Convert a position number to its ordinal string (1st, 2nd, etc.)."""
        if position == 1:
            return "First"
        elif position == 2:
            return "Second"
        elif position == 3:
            return "Third"
        elif position == 4:
            return "Fourth"
        elif position == 5:
            return "Fifth"
        elif position == 6:
            return "Sixth"
        elif position == 7:
            return "Seventh"
        elif position == 8:
            return "Eighth"
        elif position == 9:
            return "Ninth"
        elif position == 10:
            return "Tenth"
        elif position == 11:
            return "Eleventh"
        elif position == 12:
            return "Twelfth"
        elif position == 13:
            return "Thirteenth"
        elif position == 14:
            return "Fourteenth"
        elif position == 15:
            return "Fifteenth"
        elif position == 16:
            return "Sixteenth"
        elif position == 17:
            return "Seventeenth"
        elif position == 18:
            return "Eighteenth"
        elif position == 19:
            return "Nineteenth"
        elif position == 20:
            return "Twentieth"
        return f"{position}th"
    
    def check_for_cheat_code(self, user_input: str) -> bool:
        """Check if user entered the cheat code and handle it."""
        user_input_clean = user_input.lower().strip()
        
        if user_input_clean == "snakesandrats":
            self.show_cheat_menu()
            return True
        elif user_input_clean == "snakesandrats --get idol":
            self.give_player_idol_cheat()
            return True
        return False
    
    def show_cheat_menu(self) -> None:
        """Display the cheat code menu and handle selections."""
        while True:
            print("\n" + "="*50)
            print("🐍 CHEAT CODE ACTIVATED 🐀")
            print("="*50)
            print("What behind-the-scenes information would you like to see?")
            print("1. Hidden Immunity Idol Status")
            print("2. Vote Targets")
            print("3. Relationships")
            print("4. Tribe Statistics")
            print("5. Verify Info Bank Information")
            print("6. Threat Levels")
            print("7. Game Security Levels (NPCs)")
            print("8. NPC Actions by Day")
            print("9. Most Recent Votes")
            print("10. View Contestant Info Bank")
            print("11. Control NPC Actions")
            print("12. Exit Cheat Menu")
            
            try:
                choice = input("\nEnter your choice (1-12): ").strip()
                
                if choice == "1":
                    self.show_idol_status()
                elif choice == "2":
                    self.show_vote_targets()
                elif choice == "3":
                    self.show_relationships()
                elif choice == "4":
                    self.show_tribe_stats()
                elif choice == "5":
                    self.verify_info_bank()
                elif choice == "6":
                    self.show_threat_levels()
                elif choice == "7":
                    self.show_game_security()
                elif choice == "8":
                    self.show_npc_actions_for_day()
                elif choice == "9":
                    self.show_most_recent_votes()
                elif choice == "10":
                    self.show_contestant_info_bank()
                elif choice == "11":
                    self.control_npc_actions()
                elif choice == "12":
                    print("Exiting cheat menu...\n")
                    break
                else:
                    print("Invalid choice. Please enter 1-12.")
            except (ValueError, KeyboardInterrupt):
                print("Invalid input. Please enter 1-12.")
    
    def show_idol_status(self) -> None:
        """Show who has hidden immunity idols and when they found them."""
        print("\n" + "-"*40)
        print("🏺 HIDDEN IMMUNITY IDOL STATUS 🏺")
        print("-"*40)
        
        active_contestants = self.get_active_contestants()
        idol_holders = [c for c in active_contestants if c.has_idol]
        
        if not idol_holders:
            print("No one currently has a hidden immunity idol.")
        else:
            print("Current idol holders:")
            for contestant in idol_holders:
                idol_text = "idol" if contestant.idol_count == 1 else "idols"
                finder_info = self.idol_finder_history.get(contestant.name, "Unknown day")
                print(f"- {contestant.name} ({contestant.idol_count} {idol_text}, found on {finder_info})")
        
        print("\nIdol history this game:")
        if not self.idol_finder_history:
            print("No idols have been found yet.")
        else:
            for name, day_info in self.idol_finder_history.items():
                # Check if they still have it
                still_has = any(c.name == name and len(c.idols) > 0 for c in active_contestants)
                status = "Still has it" if still_has else "No longer has it"
                print(f"- {name}: Found on {day_info} ({status})")
        
        print("-"*40 + "\n")
    
    def give_player_idol_cheat(self) -> None:
        """Give the player the hidden immunity idol via cheat code."""
        # Check if there's an idol available
        idol_available = False
        beach_name = ""
        
        if self.merged:
            # Post-merge: check merge idol
            if not self.idol_found_merge:
                idol_available = True
                beach_name = getattr(self, 'merge_tribe_name', 'Merged')
        else:
            # Pre-merge: check player's tribe idol
            if self.player.tribe == self.tribe1_name and not self.idol_found_tribe1:
                idol_available = True
                beach_name = self.tribe1_name
            elif self.player.tribe == self.tribe2_name and not self.idol_found_tribe2:
                idol_available = True
                beach_name = self.tribe2_name
        
        if idol_available:
            # Give the player the idol
            print("\n" + "="*50)
            print("🗝️  CHEAT CODE: IDOL GRANTED 🗝️")
            print("="*50)
            print("You have been granted the Hidden Immunity Idol!")
            
            # Add idol to player's collection
            idol_entry = {
                'tribe_beach': beach_name,
                'found_day': self.day
            }
            self.player.idols.append(idol_entry)
            
            # Mark the appropriate idol as found
            if self.merged:
                self.idol_found_merge = True
            elif self.player.tribe == self.tribe1_name:
                self.idol_found_tribe1 = True
            elif self.player.tribe == self.tribe2_name:
                self.idol_found_tribe2 = True
            
            # Don't reset failed hunt streak for cheat codes - player didn't actually find it
            
            # Add game move for finding the idol
            self.player.add_game_move('idol_found', 1, self.day, f"found a hidden immunity idol")
            
            print(f"Idol obtained from: {beach_name}")
            print("="*50 + "\n")
        else:
            # No idol available
            print("\n" + "="*50)
            print("🚫 CHEAT CODE: NO IDOL AVAILABLE 🚫")
            print("="*50)
            print("The Hidden Immunity Idol has already been found")
            print("="*50 + "\n")
    
    def show_vote_targets(self) -> None:
        """Show vote targets for contestants."""
        print("\n" + "-"*40)
        print("🗳️  VOTE TARGETS 🗳️")
        print("-"*40)
        
        active_contestants = self.get_active_contestants()
        player_tribe = self.get_player_tribe()
        
        if not player_tribe or len(player_tribe) <= 1:
            print("No vote targets available (no upcoming tribal council).")
            print("-"*40 + "\n")
            return
        
        print("Choose a contestant to see their targeting information:")
        eligible_contestants = [c for c in player_tribe if c != self.player]
        
        for i, contestant in enumerate(eligible_contestants, 1):
            print(f"{i}. {contestant.name}")
        print(f"{len(eligible_contestants) + 1}. Show all targeting information")
        print(f"{len(eligible_contestants) + 2}. Exit")
        
        while True:
            try:
                choice = input(f"\nEnter your choice (1-{len(eligible_contestants) + 2}): ").strip()
                choice_num = int(choice)
                
                if 1 <= choice_num <= len(eligible_contestants):
                    selected_contestant = eligible_contestants[choice_num - 1]
                    print(f"\n{selected_contestant.name}'s targeting information:")
                    if selected_contestant.vote_target:
                        print(f"  Vote Target: {selected_contestant.vote_target.name}")
                    else:
                        print(f"  Vote Target: No valid target available")
                    
                    if selected_contestant.target_roster:
                        roster_names = [t.name for t in selected_contestant.target_roster]
                        print(f"  Target Roster: {', '.join(roster_names)}")
                    else:
                        print(f"  Target Roster: Empty")
                    break
                elif choice_num == len(eligible_contestants) + 1:
                    print("\nAll targeting information:")
                    for contestant in eligible_contestants:
                        vote_target = contestant.vote_target.name if contestant.vote_target else "None"
                        roster_names = [t.name for t in contestant.target_roster] if contestant.target_roster else []
                        roster_str = ", ".join(roster_names) if roster_names else "Empty"
                        print(f"- {contestant.name}: Vote → {vote_target} | Roster → [{roster_str}]")
                    break
                elif choice_num == len(eligible_contestants) + 2:
                    break
                else:
                    print(f"Invalid choice. Please enter a number between 1 and {len(eligible_contestants) + 2}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        print("-"*40 + "\n")
    
    def show_relationships(self) -> None:
        """Show relationship information for contestants."""
        print("\n" + "-"*40)
        print("💕 RELATIONSHIPS 💕")
        print("-"*40)
        
        active_contestants = self.get_active_contestants()
        
        print("Choose a contestant to see their relationships:")
        print(f"1. {self.player.name} (You)")
        eligible_contestants = [c for c in active_contestants if c != self.player]
        
        for i, contestant in enumerate(eligible_contestants, 2):
            print(f"{i}. {contestant.name}")
        print(f"{len(eligible_contestants) + 2}. Show all relationships")
        print(f"{len(eligible_contestants) + 3}. Exit")
        
        while True:
            try:
                choice = input(f"\nEnter your choice (1-{len(eligible_contestants) + 3}): ").strip()
                choice_num = int(choice)
                
                if choice_num == 1:
                    # Show player's relationships
                    print(f"\n{self.player.name}'s relationships:")
                    for other in active_contestants:
                        if other != self.player:
                            rel_value = self.player.get_relationship(other)
                            rel_desc = self.player.get_relationship_description(other)
                            print(f"  {other.name}: {rel_value} ({rel_desc})")
                    break
                elif 2 <= choice_num <= len(eligible_contestants) + 1:
                    # Show selected contestant's relationships
                    selected = eligible_contestants[choice_num - 2]
                    print(f"\n{selected.name}'s relationships:")
                    for other in active_contestants:
                        if other != selected:
                            rel_value = selected.get_relationship(other)
                            rel_desc = selected.get_relationship_description(other)
                            print(f"  {other.name}: {rel_value} ({rel_desc})")
                    break
                elif choice_num == len(eligible_contestants) + 2:
                    # Show all relationships
                    print("\nAll relationships (format: A→B: value):")
                    for contestant1 in active_contestants:
                        relationships = []
                        for contestant2 in active_contestants:
                            if contestant1 != contestant2:
                                rel_value = contestant1.get_relationship(contestant2)
                                if rel_value != 0:  # Only show non-neutral relationships
                                    relationships.append(f"{contestant2.name}:{rel_value}")
                        
                        if relationships:
                            print(f"- {contestant1.name}: {', '.join(relationships)}")
                        else:
                            print(f"- {contestant1.name}: All neutral (0)")
                    break
                elif choice_num == len(eligible_contestants) + 3:
                    break
                else:
                    print(f"Invalid choice. Please enter a number between 1 and {len(eligible_contestants) + 3}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        print("-"*40 + "\n")
    
    def show_tribe_stats(self) -> None:
        """Show tribe statistics including challenge skill averages."""
        print("\n" + "-"*40)
        print("📊 TRIBE STATISTICS 📊")
        print("-"*40)
        
        if not self.merged:
            # Pre-merge: show both tribes
            tribe1_active = self.get_active_contestants(self.tribe1_name)
            tribe2_active = self.get_active_contestants(self.tribe2_name)
            
            # Calculate averages
            tribe1_avg = sum(c.challenge_skill for c in tribe1_active) / len(tribe1_active) if tribe1_active else 0
            tribe2_avg = sum(c.challenge_skill for c in tribe2_active) / len(tribe2_active) if tribe2_active else 0
            
            print(f"\n{self.tribe1_name} Tribe ({len(tribe1_active)} members):")
            print(f"Average Challenge Skill: {tribe1_avg:.2f}")
            print("Members and their challenge skills:")
            for c in sorted(tribe1_active, key=lambda x: x.challenge_skill, reverse=True):
                print(f"  - {c.name}: {c.challenge_skill}")
            
            print(f"\n{self.tribe2_name} Tribe ({len(tribe2_active)} members):")
            print(f"Average Challenge Skill: {tribe2_avg:.2f}")
            print("Members and their challenge skills:")
            for c in sorted(tribe2_active, key=lambda x: x.challenge_skill, reverse=True):
                print(f"  - {c.name}: {c.challenge_skill}")
            
            print(f"\nChallenge Skill Difference: {abs(tribe1_avg - tribe2_avg):.2f}")
        else:
            # Post-merge: show merged tribe
            active = self.get_active_contestants()
            avg_skill = sum(c.challenge_skill for c in active) / len(active) if active else 0
            
            print(f"\n{self.merge_tribe_name} Tribe (Merged) ({len(active)} members):")
            print(f"Average Challenge Skill: {avg_skill:.2f}")
            print("Members and their challenge skills:")
            for c in sorted(active, key=lambda x: x.challenge_skill, reverse=True):
                immune_status = " (Immune)" if c.immune else ""
                print(f"  - {c.name}: {c.challenge_skill}{immune_status}")
        
        print("-"*40 + "\n")
    
    def verify_info_bank(self) -> None:
        """Show all information in player's info bank with TRUE/FALSE verification."""
        print("\n" + "-"*40)
        print("🔍 VERIFY INFO BANK INFORMATION 🔍")
        print("-"*40)
        
        if not self.player.information_bank:
            print("Your information bank is empty.")
            print("-"*40 + "\n")
            return
        
        print("Your complete information bank with verification:\n")
        
        # Group information by type for better organization
        idol_info = []
        alliance_info = []
        vote_info = []
        previous_vote_info = []
        target_roster_info = []
        final_2_info = []
        other_info = []
        
        for info in self.player.information_bank:
            if info['type'] == 'has_idol':
                idol_info.append(info)
            elif info['type'] == 'alliance':
                alliance_info.append(info)
            elif info['type'] == 'vote_target':
                vote_info.append(info)
            elif info['type'] == 'previous_vote':
                previous_vote_info.append(info)
            elif info['type'] == 'target_roster':
                target_roster_info.append(info)
            elif info['type'] in ['final_2', 'has_final_2', 'final_2_pitch']:
                final_2_info.append(info)
            else:
                other_info.append(info)
        
        # Display each category
        if idol_info:
            print("🏺 IDOL INFORMATION:")
            for info in idol_info:
                self.display_verified_info(info)
        
        if alliance_info:
            print("\n🤝 ALLIANCE INFORMATION:")
            for info in alliance_info:
                self.display_verified_info(info)
        
        if vote_info:
            print("\n🗳️ VOTE TARGET INFORMATION:")
            for info in vote_info:
                self.display_verified_info(info)
        
        if previous_vote_info:
            print("\n📜 PREVIOUS VOTE INFORMATION:")
            for info in previous_vote_info:
                self.display_verified_info(info)
        
        if target_roster_info:
            print("\n🎯 TARGET ROSTER INFORMATION:")
            for info in target_roster_info:
                self.display_verified_info(info)
        
        if final_2_info:
            print("\n🏆 FINAL 2 INFORMATION:")
            for info in final_2_info:
                self.display_verified_info(info)
        
        if other_info:
            print("\n❓ OTHER INFORMATION:")
            for info in other_info:
                self.display_verified_info(info)
        
        print("-"*40 + "\n")
    
    def display_verified_info(self, info: Dict) -> None:
        """Display a single piece of information with its verification status."""
        info_text = self.player.get_information_text(info)
        if info.get('day'):
            info_text = f"Day {info['day']}: {info_text}"
        
        # Get verification status
        verification = self.get_info_verification_status(info)
        
        # Display with appropriate symbol
        print(f"  - {info_text} [{verification}]")
    
    def get_info_verification_status(self, info: Dict) -> str:
        """Get the verification status (TRUE/FALSE) for a piece of information."""
        if info['type'] == 'has_idol':
            subject = info.get('subject')
            if subject.has_idol:
                return "✅ TRUE"
            else:
                return "❌ FALSE"
                
        elif info['type'] == 'vote_target':
            subject = info.get('subject')
            target = info.get('target')
            if subject.vote_target == target:
                return "✅ TRUE"
            else:
                return "❌ FALSE"
                    
        elif info['type'] == 'alliance':
            subject = info.get('subject')
            target = info.get('target')
            if subject.has_real_alliance_with(target) and target.has_real_alliance_with(subject):
                return "✅ TRUE"
            elif subject.has_fake_alliance_with(target) or target.has_fake_alliance_with(subject):
                return "⚠️  FAKE"
            else:
                return "❌ FALSE"
                
        elif info['type'] == 'target_roster':
            subject = info.get('subject')
            claimed_targets = info.get('targets', [])
            actual_targets = subject.target_roster
            if set(claimed_targets) == set(actual_targets):
                return "✅ TRUE"
            else:
                return "❌ FALSE"
                    
        elif info['type'] == 'previous_vote':
            # Previous votes from the system are always true
            return "✅ TRUE"
            
        elif info['type'] == 'final_2':
            subject = info.get('subject')
            target = info.get('target')
            # Check if both contestants have matching Final 2 deals
            if subject.final_2_deal == target and target.final_2_deal == subject:
                return "✅ TRUE"
            elif subject in target.fake_final_2_deals or target in subject.fake_final_2_deals:
                return "⚠️  FAKE"
            else:
                return "❌ FALSE"
                
        elif info['type'] == 'has_final_2':
            subject = info.get('subject')
            if subject.final_2_deal or subject.fake_final_2_deals:
                return "✅ TRUE"
            else:
                return "❌ FALSE"
                
        elif info['type'] == 'final_2_pitch':
            # Final 2 pitch information is just historical, always true
            return "✅ TRUE"
            
        elif info['type'] == 'vote_pitch':
            # Vote pitch information is just historical, always true
            # But check for Day None bluff indicator
            if info.get('day') is None:
                return "✅ TRUE (⚠️ Day None - likely bluff!)"
            return "✅ TRUE"
            
        else:
            # Unknown information type
            return "❓ UNKNOWN"
    
    def verify_single_info(self, info: Dict) -> None:
        """Verify if a single piece of information is true or false."""
        info_text = self.player.get_information_text(info)
        print(f"\nVerifying: {info_text}")
        
        if info['type'] == 'has_idol':
            # Check if the subject actually has an idol
            subject = info.get('subject')
            if subject.has_idol:
                print("✅ TRUE - This person really does have an idol!")
            else:
                print("❌ FALSE - This person does NOT have an idol!")
                
        elif info['type'] == 'vote_target':
            # Check if the subject is actually targeting that person
            subject = info.get('subject')
            target = info.get('target')
            
            # Check for Day None bluff indicator
            day_none_warning = ""
            if info.get('day') is None:
                day_none_warning = " (⚠️ Day None - likely bluff!)"
            
            if subject.vote_target == target:
                print(f"✅ TRUE - This person really is planning to vote for that target!{day_none_warning}")
            else:
                if subject.vote_target:
                    print(f"❌ FALSE - {subject.name} is actually planning to vote for {subject.vote_target.name}!{day_none_warning}")
                else:
                    print(f"❌ FALSE - {subject.name} hasn't decided on a vote target yet!{day_none_warning}")
                    
        elif info['type'] == 'alliance':
            # Check if the alliance is real (both ways)
            subject = info.get('subject')
            target = info.get('target')
            if subject.has_real_alliance_with(target) and target.has_real_alliance_with(subject):
                print("✅ TRUE - These two really are in an alliance!")
            elif subject.has_fake_alliance_with(target) or target.has_fake_alliance_with(subject):
                print("⚠️  PARTIALLY TRUE - This is a fake alliance! One person is being deceived!")
            elif subject.has_real_alliance_with(target) or target.has_real_alliance_with(subject):
                print("⚠️  PARTIALLY TRUE - Only one person thinks they're in an alliance!")
            else:
                print("❌ FALSE - These two are NOT in an alliance!")
                
        elif info['type'] == 'target_roster':
            # Check if the target roster matches
            subject = info.get('subject')
            claimed_targets = info.get('targets', [])
            actual_targets = subject.target_roster
            
            if set(claimed_targets) == set(actual_targets):
                print("✅ TRUE - This person really does want to eliminate those targets!")
            else:
                if actual_targets:
                    target_names = [t.name for t in actual_targets]
                    print(f"❌ FALSE - {subject.name} actually wants to eliminate: {', '.join(target_names)}!")
                else:
                    print(f"❌ FALSE - {subject.name} doesn't have specific elimination targets!")
                    
        elif info['type'] == 'previous_vote':
            # Previous votes are always true since they come from the game system
            # The information is added directly after tribal council
            subject = info.get('subject')
            target = info.get('target')
            print(f"✅ TRUE - {subject.name} really did vote for {target.name} at the last tribal council!")
            
        elif info['type'] == 'final_2':
            # Check if the final 2 deal is real
            subject = info.get('subject')
            target = info.get('target')
            if subject.has_real_final_2_with(target):
                print("✅ TRUE - These two really do have a final 2 deal!")
            elif subject == self.player and target in self.player.fake_final_2_deals:
                print("⚠️  FAKE DEAL - They're lying to you about the final 2 deal!")
            elif target == self.player and subject in self.player.fake_final_2_deals:
                print("⚠️  FAKE DEAL - They're lying to you about the final 2 deal!")
            else:
                print("❌ FALSE - These two do NOT have a final 2 deal!")
                
        elif info['type'] == 'final_2_pitch':
            # Final 2 pitches are always true records of what happened
            print("✅ TRUE - This pitch really did happen!")
            
        elif info['type'] == 'has_final_2':
            # Check if the subject has any final 2 deal
            subject = info.get('subject')
            if subject.final_2_deal is not None:
                print(f"✅ TRUE - {subject.name} really does have a final 2 deal with {subject.final_2_deal.name}!")
            else:
                print(f"❌ FALSE - {subject.name} does NOT have a final 2 deal with anyone!")
    
    def show_threat_levels(self) -> None:
        """Show threat levels for all contestants."""
        print("\n" + "-"*40)
        print("⚠️  THREAT LEVELS ⚠️")
        print("-"*40)
        
        active_contestants = self.get_active_contestants()
        
        # Sort by threat level (highest to lowest)
        sorted_contestants = sorted(active_contestants, key=lambda c: c.threat_level, reverse=True)
        
        print("\nThreat Levels (1-10 scale):")
        for contestant in sorted_contestants:
            # Show player indicator
            player_marker = " (YOU)" if contestant.is_player else ""
            print(f"{contestant.name:15} - Level {contestant.threat_level}{player_marker}")
        
        print("-"*40 + "\n")
    
    def show_game_security(self) -> None:
        """Show game security levels for all contestants."""
        print("\n" + "-"*40)
        print("🛡️  GAME SECURITY LEVELS 🛡️")
        print("-"*40)
        
        active_contestants = self.get_active_contestants()
        # Filter out player since they don't have game security
        npc_contestants = [c for c in active_contestants if not c.is_player]
        
        # Sort by game security (highest to lowest)
        sorted_contestants = sorted(npc_contestants, key=lambda c: c.get_game_security(self.merged), reverse=True)
        
        print("\nGame Security (0-10 scale) - NPCs Only:")
        print("0 = Certain they'll be voted out next")
        print("10 = Completely safe and secure")
        
        phase = "Post-Merge" if self.merged else "Pre-Merge"
        modifier_desc = "Challenge skill subtracted" if self.merged else "Challenge skill added"
        print(f"Phase: {phase} ({modifier_desc})")
        print()
        
        if not sorted_contestants:
            print("No NPCs remaining in the game.")
        else:
            for contestant in sorted_contestants:
                current_security = contestant.get_game_security(self.merged)
                base_security = contestant.base_game_security
                challenge_modifier = contestant.challenge_skill if not self.merged else -contestant.challenge_skill
                
                # Add security description
                if current_security >= 9:
                    security_desc = "Extremely Safe"
                elif current_security >= 7:
                    security_desc = "Very Safe"
                elif current_security >= 5:
                    security_desc = "Moderately Safe"
                elif current_security >= 3:
                    security_desc = "Somewhat Unsafe"
                elif current_security >= 1:
                    security_desc = "Very Unsafe"
                else:
                    security_desc = "Expects Elimination"
                
                # Add recovery status if applicable
                recovery_status = ""
                if contestant.recovery_modifier_tomorrow != 0:
                    recovery_direction = "positive" if contestant.recovery_modifier_tomorrow > 0 else "negative"
                    recovery_status = f", Recovery tomorrow: {recovery_direction}"
                
                print(f"{contestant.name:15} - Level {current_security} ({security_desc})")
                print(f"{'':15}   Base: {base_security}, Challenge: {challenge_modifier:+d}{recovery_status}")
        
        print("-"*40 + "\n")
    
    def apply_voting_game_security_bonuses(self, eliminated_contestant: Contestant) -> None:
        """Apply game security bonuses based on voting results after tribal council."""
        if not eliminated_contestant:
            return
        
        # Track NPCs who need vote target pitch bonus
        npcs_with_correct_pitch = []
        
        # Check each active NPC
        for npc in self.get_active_contestants():
            if npc.is_player or npc.eliminated:
                continue
            
            # Check if NPC voted correctly
            if npc.vote_target == eliminated_contestant:
                npc.record_correct_vote()
            else:
                npc.record_incorrect_vote()
            
            # Check for vote target pitch bonus
            # Look through NPC's recent actions to see if they pitched the eliminated contestant
            if hasattr(self, 'npc_action_history'):
                for day, actions in self.npc_action_history.items():
                    # Only check actions from the last few days (pitch should be recent)
                    if self.day - day <= 3:  # Within last 3 days
                        for action_record in actions:
                            if (action_record.get('npc') == npc and 
                                'Pitch vote target' in action_record.get('action', '') and
                                eliminated_contestant.name in action_record.get('outcome', '')):
                                npcs_with_correct_pitch.append(npc)
                                break
        
        # Apply vote target pitch bonuses
        for npc in npcs_with_correct_pitch:
            npc.modify_base_game_security(3, f"Successfully pitched {eliminated_contestant.name} as vote target")
        
        # Check for alliance member voted out penalty
        if eliminated_contestant and not eliminated_contestant.is_player:
            for npc in self.get_active_contestants():
                if npc.is_player or npc.eliminated:
                    continue
                
                # Check if eliminated contestant was an ally
                if npc.has_real_alliance_with(eliminated_contestant):
                    # Check if NPC voted for their ally
                    voted_for_ally = (npc.vote_target == eliminated_contestant)
                    npc.ally_voted_out(eliminated_contestant.name, voted_for_ally)
    
    def apply_daily_game_security_checks(self) -> None:
        """Apply daily game security checks at the end of each day."""
        for npc in self.get_active_contestants():
            if npc.is_player or npc.eliminated:
                continue
            
            # Check if NPC was not pitched to today
            npc.check_daily_pitch_penalty()
            
            # Process end-of-day game security (check for big swings)
            npc.end_day_game_security_processing()
    
    def apply_start_of_day_processing(self) -> None:
        """Apply start-of-day processing for all NPCs."""
        for npc in self.get_active_contestants():
            if npc.is_player or npc.eliminated:
                continue
            
            # Process start-of-day game security (recovery from big swings)
            npc.start_day_game_security_processing()
    
    def show_npc_actions_for_day(self) -> None:
        """Show what NPCs did on a specific day and the outcomes."""
        print("\n" + "-"*40)
        print("📅 NPC ACTIONS BY DAY 📅")
        print("-"*40)
        
        # Ask for which day
        print(f"\nWhich day would you like to see? (1-{self.day})")
        
        while True:
            try:
                day_choice = input("Enter day number: ").strip()
                day_num = int(day_choice)
                
                if 1 <= day_num <= self.day:
                    break
                else:
                    print(f"Please enter a day between 1 and {self.day}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Display actions for that day
        if day_num not in self.npc_action_history:
            print(f"\nNo NPC actions recorded for Day {day_num}.")
        else:
            actions = self.npc_action_history[day_num]
            print(f"\nDay {day_num} NPC Actions:")
            print("-"*40)
            
            for contestant, action, outcome in actions:
                print(f"\n{contestant.name}:")
                print(f"  Action: {action}")
                print(f"  Outcome: {outcome}")
        
        print("-"*40 + "\n")
    
    def show_most_recent_votes(self) -> None:
        """Show the most recent vote cast by each contestant."""
        print("\n" + "-"*40)
        print("🗳️  MOST RECENT VOTES 🗳️")
        print("-"*40)
        
        if not self.most_recent_votes:
            print("\nNo votes have been cast yet.")
        else:
            # Get all contestants (active and eliminated)
            all_contestants = self.contestants
            
            # Separate into active and eliminated
            active_contestants = [c for c in all_contestants if not c.eliminated]
            eliminated_contestants = [c for c in all_contestants if c.eliminated]
            
            # Show active contestants' votes
            if active_contestants:
                print("\nActive Contestants:")
                for contestant in sorted(active_contestants, key=lambda c: c.name):
                    if contestant in self.most_recent_votes:
                        target, day = self.most_recent_votes[contestant]
                        player_marker = " (YOU)" if contestant.is_player else ""
                        print(f"  {contestant.name:15}{player_marker} → {target.name} (Day {day})")
                    else:
                        player_marker = " (YOU)" if contestant.is_player else ""
                        print(f"  {contestant.name:15}{player_marker} → No votes cast yet")
            
            # Show eliminated contestants' votes
            if eliminated_contestants:
                print("\nEliminated Contestants:")
                for contestant in eliminated_contestants:
                    if contestant in self.most_recent_votes:
                        target, day = self.most_recent_votes[contestant]
                        print(f"  {contestant.name:15} → {target.name} (Day {day})")
                    else:
                        print(f"  {contestant.name:15} → No votes cast")
        
        print("-"*40 + "\n")
    
    def show_contestant_info_bank(self) -> None:
        """Show any contestant's information bank and verify if information is true."""
        print("\n" + "-"*40)
        print("📖 VIEW CONTESTANT INFO BANK 📖")
        print("-"*40)
        
        # Get all contestants
        all_contestants = sorted(self.contestants, key=lambda c: (c.eliminated, c.name))
        
        print("\nSelect a contestant to view their information bank:")
        for i, contestant in enumerate(all_contestants, 1):
            status = " (Eliminated)" if contestant.eliminated else ""
            player_marker = " (YOU)" if contestant.is_player else ""
            print(f"{i:2}. {contestant.name}{player_marker}{status}")
        print(f"{len(all_contestants) + 1}. Back to cheat menu")
        
        while True:
            try:
                choice_input = input(f"\nEnter your choice (1-{len(all_contestants) + 1}): ").strip()
                choice = int(choice_input)
                
                if choice == len(all_contestants) + 1:
                    return  # Back to cheat menu
                    
                if 1 <= choice <= len(all_contestants):
                    selected_contestant = all_contestants[choice - 1]
                    break
                else:
                    print(f"Invalid choice. Please enter 1-{len(all_contestants) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Display the selected contestant's info bank
        print(f"\n{selected_contestant.name}'s Information Bank:")
        print("-"*40)
        
        if not selected_contestant.information_bank:
            print("This contestant has no information in their bank.")
        else:
            # Group information by type
            idol_info = []
            alliance_info = []
            final_2_info = []
            vote_info = []
            previous_vote_info = []
            target_roster_info = []
            
            for info in selected_contestant.information_bank:
                if info['type'] == 'has_idol':
                    idol_info.append(info)
                elif info['type'] == 'alliance':
                    alliance_info.append(info)
                elif info['type'] in ['final_2', 'final_2_pitch', 'has_final_2']:
                    final_2_info.append(info)
                elif info['type'] == 'vote_target':
                    vote_info.append(info)
                elif info['type'] == 'previous_vote':
                    previous_vote_info.append(info)
                elif info['type'] == 'target_roster':
                    target_roster_info.append(info)
            
            # Display each type of information with verification
            if idol_info:
                print("\n🏺 IDOL INFORMATION:")
                for info in idol_info:
                    info_text = selected_contestant.get_information_text(info)
                    # Verify if true
                    is_true = info.get('subject').has_idol
                    truth_status = "✅ TRUE" if is_true else "❌ FALSE"
                    print(f"  - {info_text} [{truth_status}]")
            
            if alliance_info:
                print("\n🤝 ALLIANCE INFORMATION:")
                for info in alliance_info:
                    info_text = selected_contestant.get_information_text(info)
                    # Verify if true
                    subject = info.get('subject')
                    target = info.get('target')
                    if subject and target:
                        is_true = subject.has_real_alliance_with(target) and target.has_real_alliance_with(subject)
                        if not is_true and (subject.has_fake_alliance_with(target) or target.has_fake_alliance_with(subject)):
                            truth_status = "⚠️  FAKE ALLIANCE"
                        else:
                            truth_status = "✅ TRUE" if is_true else "❌ FALSE"
                    else:
                        truth_status = "❓ UNKNOWN"
                    print(f"  - {info_text} [{truth_status}]")
            
            if final_2_info:
                print("\n🤝 FINAL 2 DEAL INFORMATION:")
                for info in final_2_info:
                    info_text = selected_contestant.get_information_text(info)
                    # Verify if true based on info type
                    if info['type'] == 'final_2':
                        subject = info.get('subject')
                        target = info.get('target')
                        if subject and target:
                            is_true = subject.has_real_final_2_with(target)
                            truth_status = "✅ TRUE" if is_true else "❌ FALSE"
                        else:
                            truth_status = "❓ UNKNOWN"
                    elif info['type'] == 'has_final_2':
                        subject = info.get('subject')
                        has_deal = subject.final_2_deal is not None
                        truth_status = "✅ TRUE" if has_deal else "❌ FALSE"
                    else:  # final_2_pitch
                        # Pitches are always true records of what happened
                        truth_status = "✅ TRUE"
                    
                    # Add day information if available
                    day = info.get('day')
                    if day:
                        info_text = f"Day {day}: {info_text}"
                    
                    print(f"  - {info_text} [{truth_status}]")
            
            if vote_info:
                print("\n🗳️  VOTE TARGET INFORMATION:")
                for info in vote_info:
                    info_text = selected_contestant.get_information_text(info)
                    # Verify if true
                    subject = info.get('subject')
                    claimed_target = info.get('target')
                    actual_target = subject.vote_target
                    is_true = actual_target == claimed_target
                    if actual_target and not is_true:
                        truth_status = f"❌ FALSE (actually: {actual_target.name})"
                    else:
                        truth_status = "✅ TRUE" if is_true else "❌ FALSE"
                    print(f"  - {info_text} [{truth_status}]")
            
            if previous_vote_info:
                print("\n📜 PREVIOUS VOTE INFORMATION:")
                for info in previous_vote_info:
                    info_text = selected_contestant.get_information_text(info)
                    # Previous votes from the system are always true
                    # But could be false if it was a bluff
                    day = info.get('day')
                    if day:
                        info_text = f"Day {day}: {info_text}"
                    
                    # Check if this matches the most recent vote record
                    voter = info.get('subject')
                    claimed_target = info.get('target')
                    if voter in self.most_recent_votes:
                        actual_target, vote_day = self.most_recent_votes[voter]
                        if vote_day == day:
                            is_true = actual_target == claimed_target
                            truth_status = "✅ TRUE" if is_true else f"❌ FALSE (actually: {actual_target.name})"
                        else:
                            truth_status = "✅ TRUE"  # From a different day, assume true
                    else:
                        truth_status = "✅ TRUE"  # No record to contradict it
                    print(f"  - {info_text} [{truth_status}]")
            
            if target_roster_info:
                print("\n🎯 TARGET ROSTER INFORMATION:")
                for info in target_roster_info:
                    subject = info.get('subject')
                    claimed_targets = info.get('targets', [])
                    actual_targets = subject.target_roster
                    target_names = [t.name for t in claimed_targets]
                    info_text = f"{subject.name} wants to eliminate: {', '.join(target_names)}"
                    
                    # Verify if true
                    is_true = set(claimed_targets) == set(actual_targets)
                    if not is_true and actual_targets:
                        actual_names = [t.name for t in actual_targets]
                        truth_status = f"❌ FALSE (actually: {', '.join(actual_names)})"
                    else:
                        truth_status = "✅ TRUE" if is_true else "❌ FALSE"
                    print(f"  - {info_text} [{truth_status}]")
        
        print("-"*40 + "\n")
    
    def control_npc_actions(self) -> None:
        """Allow player to control what actions NPCs perform next."""
        print("\n" + "-"*40)
        print("🎮 CONTROL NPC ACTIONS 🎮")
        print("-"*40)
        
        # Get active NPCs in player's tribe
        player_tribe = self.get_player_tribe()
        if not player_tribe:
            print("No NPCs available to control.")
            print("-"*40 + "\n")
            return
        
        npcs = [c for c in player_tribe if not c.is_player and not c.eliminated]
        if not npcs:
            print("No active NPCs in your tribe.")
            print("-"*40 + "\n")
            return
        
        print("\nSelect an NPC to control:")
        for i, npc in enumerate(npcs, 1):
            print(f"{i:2}. {npc.name}")
        print(f"{len(npcs) + 1}. Back to cheat menu")
        
        # Select NPC
        while True:
            try:
                choice_input = input(f"\nEnter your choice (1-{len(npcs) + 1}): ").strip()
                choice = int(choice_input)
                
                if choice == len(npcs) + 1:
                    return  # Back to cheat menu
                    
                if 1 <= choice <= len(npcs):
                    selected_npc = npcs[choice - 1]
                    break
                else:
                    print(f"Invalid choice. Please enter 1-{len(npcs) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Show action menu
        print(f"\nControl {selected_npc.name}'s next action:")
        print("-" * 30)
        
        # Check if NPC can pitch Final 2 Deal
        can_pitch_final_2 = (
            selected_npc.alliance_roster and 
            any(c for c in selected_npc.alliance_roster if selected_npc.get_relationship(c) >= 2 and not selected_npc.believes_has_final_2_with(c) and not c.eliminated)
        )
        
        actions = [
            "Small Talk",
            "Pitch Alliance", 
            "Pitch Vote Target",
            "Bluff",
            "Reveal",
            "Work around camp",
            "Probe"
        ]
        
        if can_pitch_final_2:
            actions.insert(3, "Pitch Final 2 Deal")  # Insert after Pitch Vote Target
        
        for i, action in enumerate(actions, 1):
            print(f"{i}. {action}")
        print(f"{len(actions) + 1}. Cancel")
        
        # Select action
        while True:
            try:
                action_choice = input(f"\nEnter your choice (1-{len(actions) + 1}): ").strip()
                action_num = int(action_choice)
                
                if action_num == len(actions) + 1:
                    return  # Cancel
                    
                if 1 <= action_num <= len(actions):
                    selected_action = actions[action_num - 1]
                    break
                else:
                    print(f"Invalid choice. Please enter 1-{len(actions) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Get the detailed parameters for the controlled action
        action_params = self.get_controlled_action_parameters(selected_npc, selected_action)
        
        if action_params is None:
            # Action was cancelled during parameter selection
            return
        
        # Queue the action for later execution during NPC's turn
        if not hasattr(self, 'queued_controlled_actions'):
            self.queued_controlled_actions = {}
        
        self.queued_controlled_actions[selected_npc] = {
            'action': selected_action,
            'params': action_params
        }
        
        print(f"\n{selected_action} queued for {selected_npc.name}.")
        print(f"This action will execute during {selected_npc.name}'s next turn.")
        print("-"*40 + "\n")
    
    def controlled_npc_reveal(self, npc: Contestant) -> None:
        """Allow player to control what information an NPC reveals and to whom."""
        print(f"\nControl {npc.name}'s Reveal Action")
        print("-" * 40)
        
        # Check if NPC has any information to reveal
        if not npc.information_bank:
            print(f"{npc.name} has no information to reveal.")
            return
        
        # Show available information to reveal
        print(f"\n{npc.name}'s available information to reveal:")
        for i, info in enumerate(npc.information_bank, 1):
            info_text = npc.get_information_text(info)
            print(f"{i:2}. {info_text}")
        print(f"{len(npc.information_bank) + 1}. Cancel")
        
        # Select information to reveal
        while True:
            try:
                info_choice = input(f"\nSelect information to reveal (1-{len(npc.information_bank) + 1}): ").strip()
                info_num = int(info_choice)
                
                if info_num == len(npc.information_bank) + 1:
                    return  # Cancel
                    
                if 1 <= info_num <= len(npc.information_bank):
                    selected_info = npc.information_bank[info_num - 1]
                    break
                else:
                    print(f"Invalid choice. Please enter 1-{len(npc.information_bank) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Get potential targets to reveal to
        player_tribe = self.get_player_tribe()
        if not player_tribe:
            print("No potential targets available.")
            return
        
        potential_targets = [c for c in player_tribe if c != npc and not c.eliminated]
        if not potential_targets:
            print("No valid targets to reveal information to.")
            return
        
        # Show available targets
        print(f"\nWho should {npc.name} reveal this information to?")
        for i, target in enumerate(potential_targets, 1):
            player_marker = " (YOU)" if target.is_player else ""
            print(f"{i:2}. {target.name}{player_marker}")
        print(f"{len(potential_targets) + 1}. Cancel")
        
        # Select target
        while True:
            try:
                target_choice = input(f"\nSelect target (1-{len(potential_targets) + 1}): ").strip()
                target_num = int(target_choice)
                
                if target_num == len(potential_targets) + 1:
                    return  # Cancel
                    
                if 1 <= target_num <= len(potential_targets):
                    selected_target = potential_targets[target_num - 1]
                    break
                else:
                    print(f"Invalid choice. Please enter 1-{len(potential_targets) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Execute the controlled reveal
        print(f"\n{npc.name} reveals information to {selected_target.name}:")
        print("-" * 30)
        
        # Show the reveal dialogue
        info_text_for_speaking = npc.get_information_text_for_speaking(selected_info, listener=selected_target)
        self.contestant_speaks(npc, f"I need to tell you something... {info_text_for_speaking}")
        
        # Handle the information sharing based on target type
        if selected_target.is_player:
            # NPC reveals to player - player always believes it
            player_info = selected_info.copy()
            player_info['day'] = self.day
            self.player.information_bank.append(player_info)
            
            # Check for Final 2 betrayal if player learned about a Final 2 deal
            if selected_info.get('type') == 'final_2' and selected_info.get('subject') and selected_info.get('target'):
                if self.player in [selected_info.get('subject'), selected_info['target']]:
                    # Player learned about their own Final 2 deal being shared
                    pass  # Normal case, no betrayal detection needed
                else:
                    self.check_for_final_2_betrayal(self.player, selected_info.get('subject'), selected_info['target'])
        else:
            # NPC reveals to another NPC
            # Roll for believability
            roll = random.randint(1, 20)
            social_skill_bonus = npc.social_skill
            resistance_penalty = selected_target.resistance_to_persuasion
            hero_bonus = 1 if npc.hero_or_villain == "Hero" else 0
            total_roll = roll + social_skill_bonus - resistance_penalty + hero_bonus
            
            if total_roll >= 16:
                # Critical success - target believes and may share with others
                target_info = selected_info.copy()
                target_info['day'] = self.day
                selected_target.information_bank.append(target_info)
                
                # Record the action
                self.record_npc_action(npc, f"Reveal to {selected_target.name}", f"Critical Success (Roll: {roll}, Total: {total_roll})")
                
                # Check for Final 2 betrayal detection
                if selected_info.get('type') == 'final_2' and selected_info.get('subject') and selected_info.get('target'):
                    if self.player in [selected_info.get('subject'), selected_info['target']]:
                        if selected_target.believes_has_final_2_with(self.player):
                            if selected_target not in self.npcs_needing_betrayal_confrontation:
                                self.npcs_needing_betrayal_confrontation.append(selected_target)
                                # Handle this confrontation immediately instead of waiting
                                # Figure out which contestant they learned about
                                other_contestant = selected_info['target'] if selected_info.get('subject') == self.player else selected_info.get('subject')
                                self.handle_immediate_confrontation(selected_target, other_contestant)
                
            elif total_roll >= 11:
                # Success - target believes
                target_info = selected_info.copy()
                target_info['day'] = self.day
                selected_target.information_bank.append(target_info)
                
                # Record the action  
                self.record_npc_action(npc, f"Reveal to {selected_target.name}", f"Success (Roll: {roll}, Total: {total_roll})")
                
                # Check for Final 2 betrayal detection
                if selected_info.get('type') == 'final_2' and selected_info.get('subject') and selected_info.get('target'):
                    if self.player in [selected_info.get('subject'), selected_info['target']]:
                        if selected_target.believes_has_final_2_with(self.player):
                            if selected_target not in self.npcs_needing_betrayal_confrontation:
                                self.npcs_needing_betrayal_confrontation.append(selected_target)
                
            else:
                # Failure - target doesn't believe
                self.record_npc_action(npc, f"Reveal to {selected_target.name}", f"Failure (Roll: {roll}, Total: {total_roll})")
        
        print(f"\nReveal completed successfully!")
    
    def controlled_npc_small_talk(self, npc: Contestant) -> None:
        """Allow player to control who an NPC small talks with."""
        print(f"\nControl {npc.name}'s Small Talk Action")
        print("-" * 40)
        
        # Get potential targets
        player_tribe = self.get_player_tribe()
        if not player_tribe:
            print("No potential targets available.")
            return
        
        potential_targets = [c for c in player_tribe if c != npc and not c.eliminated]
        if not potential_targets:
            print("No valid targets for small talk.")
            return
        
        # Show available targets
        print(f"\nWho should {npc.name} small talk with?")
        for i, target in enumerate(potential_targets, 1):
            player_marker = " (YOU)" if target.is_player else ""
            print(f"{i:2}. {target.name}{player_marker}")
        print(f"{len(potential_targets) + 1}. Cancel")
        
        # Select target
        while True:
            try:
                choice = input(f"\nSelect target (1-{len(potential_targets) + 1}): ").strip()
                choice_num = int(choice)
                
                if choice_num == len(potential_targets) + 1:
                    return  # Cancel
                    
                if 1 <= choice_num <= len(potential_targets):
                    selected_target = potential_targets[choice_num - 1]
                    break
                else:
                    print(f"Invalid choice. Please enter 1-{len(potential_targets) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        # Execute small talk
        print(f"\n{npc.name} small talks with {selected_target.name}:")
        print("-" * 30)
        
        if selected_target.is_player:
            self.contestant_speaks(npc, f"Hey {self.player.name}, how are you holding up out here?")
            self.contestant_speaks(self.player, f"I'm doing alright. Just trying to stay strong.")
            self.contestant_speaks(npc, f"That's good to hear. We need to stick together.")
            
            npc.modify_relationship(self.player, 1)
            self.player.modify_relationship(npc, 1)
            
            self.narration(f"You and {npc.name} have a pleasant conversation. Your relationship has improved slightly.")
        else:
            topics = ["the weather", "camp life", "missing home", "survival strategies", "funny stories"]
            topic = random.choice(topics)
            self.narration(f"{npc.name} and {selected_target.name} have a friendly conversation about {topic}.")
            
            npc.modify_relationship(selected_target, 1)
            selected_target.modify_relationship(npc, 1)
        
        self.record_npc_action(npc, f"Small Talk with {selected_target.name}", "Success")
        print(f"\nSmall talk completed successfully!")
    
    def controlled_npc_pitch_alliance(self, npc: Contestant) -> None:
        """Allow player to control who an NPC pitches an alliance to."""
        print(f"\nControl {npc.name}'s Pitch Alliance Action")
        print("-" * 40)
        
        player_tribe = self.get_player_tribe()
        if not player_tribe:
            print("No potential targets available.")
            return
        
        potential_targets = [c for c in player_tribe 
                           if c != npc 
                           and not c.eliminated 
                           and c not in npc.alliance_roster
                           and npc not in c.fake_alliance_roster]
        
        if not potential_targets:
            print("No valid targets to pitch alliance to.")
            return
        
        print(f"\nWho should {npc.name} pitch an alliance to?")
        for i, target in enumerate(potential_targets, 1):
            player_marker = " (YOU)" if target.is_player else ""
            relationship = npc.get_relationship(target)
            print(f"{i:2}. {target.name}{player_marker} (Relationship: {relationship})")
        print(f"{len(potential_targets) + 1}. Cancel")
        
        while True:
            try:
                choice = input(f"\nSelect target (1-{len(potential_targets) + 1}): ").strip()
                choice_num = int(choice)
                
                if choice_num == len(potential_targets) + 1:
                    return
                    
                if 1 <= choice_num <= len(potential_targets):
                    selected_target = potential_targets[choice_num - 1]
                    break
                else:
                    print(f"Invalid choice. Please enter 1-{len(potential_targets) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        print(f"\n{npc.name} pitches an alliance to {selected_target.name}:")
        print("-" * 30)
        
        if selected_target.is_player:
            self.npc_alliance_pitch_to_player(npc)
        else:
            self.contestant_speaks(npc, f"Hey {selected_target.name}, I think we should work together.")
            
            roll = random.randint(1, 20)
            persuasive_bonus = npc.persuasive_skill
            relationship_bonus = max(0, npc.get_relationship(selected_target))
            resistance_penalty = selected_target.resistance_to_persuasion
            
            total_roll = roll + persuasive_bonus + relationship_bonus - resistance_penalty
            
            if total_roll >= 11:
                self.contestant_speaks(selected_target, f"You know what? I'm in. Let's do this.")
                
                npc.alliance_roster.append(selected_target)
                selected_target.alliance_roster.append(npc)
                
                # Game Security: NPC successfully pitched an alliance (+1)
                npc.modify_base_game_security(1, "Successfully pitched alliance", silent=True)
                # Game Security: NPC was approached to be in an alliance (+1) 
                selected_target.modify_base_game_security(1, "Approached for alliance", silent=True)
                selected_target.mark_pitched_to_today()
                
                npc.add_information('alliance', npc, selected_target)
                selected_target.add_information('alliance', selected_target, npc)
                
                self.record_npc_action(npc, f"Pitch Alliance to {selected_target.name}", f"Success (Roll: {roll}, Total: {total_roll})")
            else:
                self.contestant_speaks(selected_target, f"I appreciate it, but I'm not ready to commit yet.")
                self.record_npc_action(npc, f"Pitch Alliance to {selected_target.name}", f"Failure (Roll: {roll}, Total: {total_roll})")
        
        print(f"\nAlliance pitch completed!")
    
    def controlled_npc_pitch_vote_target(self, npc: Contestant) -> None:
        """Allow player to control who an NPC pitches a vote target to and which target to suggest."""
        print(f"\nControl {npc.name}'s Pitch Vote Target Action")
        print("-" * 40)
        
        player_tribe = self.get_player_tribe()
        if not player_tribe:
            print("No potential targets available.")
            return
        
        potential_listeners = [c for c in player_tribe if c != npc and not c.eliminated]
        if not potential_listeners:
            print("No one to pitch vote targets to.")
            return
        
        print(f"\nWho should {npc.name} pitch a vote target to?")
        for i, listener in enumerate(potential_listeners, 1):
            player_marker = " (YOU)" if listener.is_player else ""
            print(f"{i:2}. {listener.name}{player_marker}")
        print(f"{len(potential_listeners) + 1}. Cancel")
        
        while True:
            try:
                choice = input(f"\nSelect who to pitch to (1-{len(potential_listeners) + 1}): ").strip()
                choice_num = int(choice)
                
                if choice_num == len(potential_listeners) + 1:
                    return
                    
                if 1 <= choice_num <= len(potential_listeners):
                    selected_listener = potential_listeners[choice_num - 1]
                    break
                else:
                    print(f"Invalid choice. Please enter 1-{len(potential_listeners) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        potential_vote_targets = [c for c in player_tribe if c != npc and c != selected_listener and not c.eliminated]
        if not potential_vote_targets:
            print("No valid vote targets to suggest.")
            return
        
        print(f"\nWhich vote target should {npc.name} suggest to {selected_listener.name}?")
        for i, target in enumerate(potential_vote_targets, 1):
            player_marker = " (YOU)" if target.is_player else ""
            print(f"{i:2}. {target.name}{player_marker}")
        print(f"{len(potential_vote_targets) + 1}. Cancel")
        
        while True:
            try:
                choice = input(f"\nSelect vote target to suggest (1-{len(potential_vote_targets) + 1}): ").strip()
                choice_num = int(choice)
                
                if choice_num == len(potential_vote_targets) + 1:
                    return
                    
                if 1 <= choice_num <= len(potential_vote_targets):
                    suggested_target = potential_vote_targets[choice_num - 1]
                    break
                else:
                    print(f"Invalid choice. Please enter 1-{len(potential_vote_targets) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        print(f"\n{npc.name} suggests {suggested_target.name} as a vote target to {selected_listener.name}:")
        print("-" * 30)
        
        if selected_listener.is_player:
            self.contestant_speaks(npc, f"Hey {self.player.name}, I think we should consider voting for {suggested_target.name}.")
            
            pitch_info = {
                'type': 'vote_pitch',
                'subject': npc,
                'target': suggested_target,
                'day': self.day
            }
            self.player.information_bank.append(pitch_info)
            
            self.record_npc_action(npc, f"Pitch {suggested_target.name} to {selected_listener.name}", "Success")
        else:
            self.contestant_speaks(npc, f"{selected_listener.name}, what do you think about voting for {suggested_target.name}?")
            
            roll = random.randint(1, 20)
            persuasive_bonus = npc.persuasive_skill
            relationship_bonus = max(0, npc.get_relationship(selected_listener))
            resistance_penalty = selected_listener.resistance_to_persuasion
            alliance_bonus = 1 if selected_listener in npc.alliance_roster else 0
            
            total_roll = roll + persuasive_bonus + relationship_bonus + alliance_bonus - resistance_penalty
            
            if total_roll >= 11:
                self.contestant_speaks(selected_listener, f"You know what? That makes sense.")
                selected_listener.vote_target = suggested_target
                
                if suggested_target not in selected_listener.target_roster:
                    selected_listener.target_roster.append(suggested_target)
                
                pitch_info = {
                    'type': 'vote_pitch',
                    'subject': npc,
                    'target': suggested_target,
                    'day': self.day
                }
                selected_listener.information_bank.append(pitch_info)
                
                # Mark that this NPC was pitched to today (for game security)
                selected_listener.mark_pitched_to_today()
                
                self.record_npc_action(npc, f"Pitch {suggested_target.name} to {selected_listener.name}", f"Success (Roll: {roll}, Total: {total_roll})")
            else:
                self.contestant_speaks(selected_listener, f"I'm not sure about that. I need to think about it more.")
                
                # Add the pitch info even if it failed
                pitch_info = {
                    'type': 'vote_pitch',
                    'subject': npc,
                    'target': suggested_target,
                    'day': self.day
                }
                selected_listener.information_bank.append(pitch_info)
                
                # Mark that this NPC was pitched to today (for game security)
                selected_listener.mark_pitched_to_today()
                
                self.record_npc_action(npc, f"Pitch {suggested_target.name} to {selected_listener.name}", f"Failure (Roll: {roll}, Total: {total_roll})")
        
        print(f"\nVote target pitch completed!")
    
    def controlled_npc_pitch_final_2(self, npc: Contestant) -> None:
        """Allow player to control who an NPC pitches a Final 2 deal to."""
        print(f"\nControl {npc.name}'s Pitch Final 2 Deal Action")
        print("-" * 40)
        
        if not npc.alliance_roster:
            print(f"{npc.name} has no alliance members to pitch Final 2 deals to.")
            return
        
        eligible_targets = [c for c in npc.alliance_roster 
                          if npc.get_relationship(c) >= 2 
                          and not npc.believes_has_final_2_with(c) 
                          and not c.eliminated]
        
        if not eligible_targets:
            print(f"{npc.name} has no eligible alliance members for Final 2 deals.")
            return
        
        print(f"\nWho should {npc.name} pitch a Final 2 deal to?")
        for i, target in enumerate(eligible_targets, 1):
            player_marker = " (YOU)" if target.is_player else ""
            relationship = npc.get_relationship(target)
            print(f"{i:2}. {target.name}{player_marker} (Relationship: {relationship})")
        print(f"{len(eligible_targets) + 1}. Cancel")
        
        while True:
            try:
                choice = input(f"\nSelect target (1-{len(eligible_targets) + 1}): ").strip()
                choice_num = int(choice)
                
                if choice_num == len(eligible_targets) + 1:
                    return
                    
                if 1 <= choice_num <= len(eligible_targets):
                    selected_target = eligible_targets[choice_num - 1]
                    break
                else:
                    print(f"Invalid choice. Please enter 1-{len(eligible_targets) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        print(f"\n{npc.name} pitches a Final 2 deal to {selected_target.name}:")
        print("-" * 30)
        
        if selected_target.is_player:
            self.contestant_speaks(npc, f"{self.player.name}, I really trust you. Will you make a final 2 deal with me?")
            
            print(f"\n{npc.name} is offering you a Final 2 deal.")
            print("What is your response?")
            print("1. Accept the deal")
            print("2. Decline politely")
            
            while True:
                try:
                    response = input("\nEnter your choice (1-2): ").strip()
                    if response in ["1", "2"]:
                        break
                    else:
                        print("Invalid choice. Please enter 1-2.")
                except (ValueError, KeyboardInterrupt):
                    print("Invalid input. Please enter 1-2.")
            
            if response == "1":
                # Check if player already has a final 2 deal and warn them
                if self.player.final_2_deal:
                    print(f"\n⚠️  WARNING: You already have a final 2 deal with {self.player.final_2_deal.name}!")
                    print(f"Accepting this new deal with {npc.name} will betray your existing partner.")
                    print("\nDo you still want to accept this new final 2 deal?")
                    print("1. Yes, accept the new deal (betray existing partner)")
                    print("2. No, keep my existing deal")
                    
                    while True:
                        try:
                            confirm_choice = int(input("Enter your choice (1-2): "))
                            if confirm_choice == 1:
                                # Player confirms they want to betray existing partner
                                break
                            elif confirm_choice == 2:
                                # Player decides to keep existing deal
                                self.contestant_speaks(self.player, "I appreciate the offer, but I have to decline.")
                                self.contestant_speaks(npc, "I understand.")
                                npc.modify_relationship(self.player, -1)
                                return
                            else:
                                print("Invalid choice. Please enter 1 or 2.")
                        except ValueError:
                            print("Invalid input. Please enter a number.")
                
                self.contestant_speaks(self.player, f"Yes, let's do this together.")
                self.contestant_speaks(npc, f"Perfect! I'm so glad we're doing this.")
                
                npc.final_2_deal = self.player
                self.player.final_2_deal = npc
                
                # Game Security: NPC becomes part of a Final 2 Deal (+1)
                npc.modify_base_game_security(1, "Formed Final 2 deal")
                
                npc.add_information('final_2', npc, self.player)
                self.player.add_information('final_2', self.player, npc)
                
                self.narration(f"You've entered into a Final 2 deal with {npc.name}!")
            else:
                self.contestant_speaks(self.player, f"I appreciate the offer, but I'm not ready for that.")
                self.contestant_speaks(npc, f"I understand. Maybe later.")
        else:
            self.contestant_speaks(npc, f"{selected_target.name}, I trust you completely. Will you make a final 2 deal with me?")
            
            roll = random.randint(1, 20)
            persuasive_bonus = npc.persuasive_skill
            relationship_bonus = max(0, npc.get_relationship(selected_target))
            resistance_penalty = selected_target.resistance_to_persuasion
            
            total_roll = roll + persuasive_bonus + relationship_bonus - resistance_penalty
            
            if total_roll >= 11:
                self.contestant_speaks(selected_target, f"Absolutely. I'm with you all the way.")
                
                npc.final_2_deal = selected_target
                selected_target.final_2_deal = npc
                
                # Game Security: Both NPCs become part of a Final 2 Deal (+1 each)
                npc.modify_base_game_security(1, "Formed Final 2 deal", silent=True)
                selected_target.modify_base_game_security(1, "Formed Final 2 deal", silent=True)
                selected_target.mark_pitched_to_today()
                
                npc.add_information('final_2', npc, selected_target)
                selected_target.add_information('final_2', selected_target, npc)
                
                self.record_npc_action(npc, f"Pitch Final 2 to {selected_target.name}", f"Success (Roll: {roll}, Total: {total_roll})")
            else:
                self.contestant_speaks(selected_target, f"I'm not ready for that level of commitment yet.")
                self.record_npc_action(npc, f"Pitch Final 2 to {selected_target.name}", f"Failure (Roll: {roll}, Total: {total_roll})")
        
        print(f"\nFinal 2 pitch completed!")
    
    def controlled_npc_bluff(self, npc: Contestant) -> None:
        """Allow player to control what false information an NPC shares and who they share it with."""
        print(f"\nControl {npc.name}'s Bluff Action")
        print("-" * 40)
        
        player_tribe = self.get_player_tribe()
        if not player_tribe:
            print("No potential targets available.")
            return
        
        potential_targets = [c for c in player_tribe if c != npc and not c.eliminated]
        if not potential_targets:
            print("No valid targets to bluff to.")
            return
        
        print(f"\nWho should {npc.name} bluff to?")
        for i, target in enumerate(potential_targets, 1):
            player_marker = " (YOU)" if target.is_player else ""
            print(f"{i:2}. {target.name}{player_marker}")
        print(f"{len(potential_targets) + 1}. Cancel")
        
        while True:
            try:
                choice = input(f"\nSelect target (1-{len(potential_targets) + 1}): ").strip()
                choice_num = int(choice)
                
                if choice_num == len(potential_targets) + 1:
                    return
                    
                if 1 <= choice_num <= len(potential_targets):
                    selected_target = potential_targets[choice_num - 1]
                    break
                else:
                    print(f"Invalid choice. Please enter 1-{len(potential_targets) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        print(f"\nWhat type of false information should {npc.name} share?")
        print("1. Fake alliance information")
        print("2. False vote target information")
        print("3. Fake idol information")
        print("4. Fake Final 2 deal information")
        print("5. Cancel")
        
        while True:
            try:
                bluff_choice = input("\nSelect bluff type (1-5): ").strip()
                if bluff_choice in ["1", "2", "3", "4", "5"]:
                    break
                else:
                    print("Invalid choice. Please enter 1-5.")
            except ValueError:
                print("Invalid input. Please enter 1-5.")
        
        if bluff_choice == "5":
            return
        
        print(f"\n{npc.name} bluffs to {selected_target.name}:")
        print("-" * 30)
        
        if bluff_choice == "1":
            possible_subjects = [c for c in player_tribe if c != npc and c != selected_target and not c.eliminated]
            if len(possible_subjects) >= 2:
                members = random.sample(possible_subjects, 2)
                self.contestant_speaks(npc, f"I heard that {members[0].name} and {members[1].name} have a secret alliance.")
                
                if selected_target.is_player:
                    self.add_player_information('alliance', members[0], members[1])
                    self.add_player_information('alliance', members[1], members[0])
                else:
                    selected_target.add_information('alliance', members[0], members[1])
                    selected_target.add_information('alliance', members[1], members[0])
        
        elif bluff_choice == "2":
            possible_targets = [c for c in player_tribe if c != npc and c != selected_target and not c.eliminated]
            if possible_targets:
                fake_voter = random.choice(possible_targets)
                fake_target = random.choice([c for c in possible_targets if c != fake_voter])
                if fake_target == self.player:
                    self.contestant_speaks(npc, f"I think {fake_voter.name} is planning to vote for you.")
                else:
                    self.contestant_speaks(npc, f"I think {fake_voter.name} is planning to vote for {fake_target.name}.")
                
                false_info = {
                    'type': 'vote_target',
                    'subject': fake_voter,
                    'target': fake_target,
                    'day': self.day
                }
                if selected_target.is_player:
                    self.player.information_bank.append(false_info)
                else:
                    selected_target.information_bank.append(false_info)
        
        elif bluff_choice == "3":
            possible_holders = [c for c in player_tribe if c != npc and c != selected_target and not c.eliminated]
            if possible_holders:
                fake_holder = random.choice(possible_holders)
                self.contestant_speaks(npc, f"I'm pretty sure {fake_holder.name} found a hidden immunity idol.")
                
                false_info = {
                    'type': 'has_idol',
                    'subject': fake_holder,
                    'day': self.day
                }
                if selected_target.is_player:
                    self.player.information_bank.append(false_info)
                else:
                    selected_target.information_bank.append(false_info)
        
        elif bluff_choice == "4":
            # Fake Final 2 deal bluff
            possible_subjects = [c for c in player_tribe if c != npc and c != selected_target and not c.eliminated]
            if len(possible_subjects) >= 2:
                final2_members = random.sample(possible_subjects, 2)
                self.contestant_speaks(npc, f"I heard that {final2_members[0].name} and {final2_members[1].name} have a Final 2 deal together.")
                
                false_info = {
                    'type': 'final_2',
                    'subject': final2_members[0],
                    'target': final2_members[1],
                    'day': self.day
                }
                if selected_target.is_player:
                    self.player.information_bank.append(false_info)
                else:
                    selected_target.information_bank.append(false_info)
        
        self.record_npc_action(npc, f"Bluff to {selected_target.name}", "Success")
        print(f"\nBluff completed successfully!")
    
    def controlled_npc_work_around_camp(self, npc: Contestant) -> None:
        """Allow player to control NPC work around camp action."""
        print(f"\nControl {npc.name}'s Work Around Camp Action")
        print("-" * 40)
        
        work_types = [
            "gathering firewood",
            "collecting water", 
            "fishing",
            "maintaining the shelter",
            "organizing camp supplies"
        ]
        
        print(f"\nWhat type of work should {npc.name} do?")
        for i, work_type in enumerate(work_types, 1):
            print(f"{i}. {work_type.title()}")
        print(f"{len(work_types) + 1}. Cancel")
        
        while True:
            try:
                choice = input(f"\nSelect work type (1-{len(work_types) + 1}): ").strip()
                choice_num = int(choice)
                
                if choice_num == len(work_types) + 1:
                    return
                    
                if 1 <= choice_num <= len(work_types):
                    selected_work = work_types[choice_num - 1]
                    break
                else:
                    print(f"Invalid choice. Please enter 1-{len(work_types) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        print(f"\n{npc.name} works around camp:")
        print("-" * 30)
        
        self.narration(f"{npc.name} spends time {selected_work}, contributing to the tribe's well-being.")
        
        # Update work streaks
        npc.consecutive_work_days += 1
        npc.consecutive_no_work_days = 0
        npc.worked_today = True
        
        # Determine survival bonus based on hero/villain status
        survival_bonus = 2 if npc.hero_or_villain == "Hero" else 1
        
        # Apply survival bonus to all tribemates for tomorrow
        player_tribe = self.get_player_tribe()
        bonus_count = 0
        if player_tribe:
            for teammate in player_tribe:
                if teammate != npc and not teammate.eliminated:
                    teammate.work_bonus_tomorrow = survival_bonus
                    bonus_count += 1
                    # Keep the relationship bonus for controlled NPCs
                    npc.modify_relationship(teammate, 1)
                    teammate.modify_relationship(npc, 1)
        
        hero_text = " (Hero bonus)" if survival_bonus == 2 else ""
        self.record_npc_action(npc, f"Work around camp ({selected_work})", f"Provided +{survival_bonus} survival bonus{hero_text} to {bonus_count} tribemates, improved relationships")
        print(f"\nWork completed successfully!")
    
    def controlled_npc_focus_on_survival(self, npc: Contestant) -> None:
        """Allow player to control NPC focus on survival action."""
        print(f"\nControl {npc.name}'s Focus on Survival Action")
        print("-" * 40)
        
        # Show survival activities
        survival_activities = [
            ("cooking rice", "You decide to start cooking a pot of rice. After several minutes the rice is finished. You take a serving for yourself and quickly eat your portion. You feel better now that you have some food in your belly."),
            ("gathering coconuts", "You make your way to a coconut tree in the jungle and bring back several coconuts to your tribemates. The coconut water is refreshing and quenches your thirst."),
            ("improving shelter", "You notice that the shelter has been uncomfortable lately. You take some time to secure the foundation and repair the roof. You take a moment to relax in your newly comfortable shelter.")
        ]
        
        print(f"\nWhat type of survival activity should {npc.name} focus on?")
        for i, (activity_name, _) in enumerate(survival_activities, 1):
            print(f"{i}. {activity_name.title()}")
        print(f"{len(survival_activities) + 1}. Cancel")
        
        while True:
            try:
                choice = input(f"\nSelect activity (1-{len(survival_activities) + 1}): ").strip()
                choice_num = int(choice)
                
                if choice_num == len(survival_activities) + 1:
                    return
                    
                if 1 <= choice_num <= len(survival_activities):
                    selected_activity, activity_description = survival_activities[choice_num - 1]
                    break
                else:
                    print(f"Invalid choice. Please enter 1-{len(survival_activities) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        print(f"\n{npc.name} focuses on survival:")
        print("-" * 30)
        
        self.narration(f"{npc.name} {activity_description.lower().replace('you', npc.get_pronoun('subject')).replace('your', npc.get_pronoun('possessive'))}")
        
        # Improve survival status by 1 (clamped between -1 and 3)
        old_status = npc.survival_status
        npc.survival_status = min(3, npc.survival_status + 1)
        new_status = npc.survival_status
        
        # Track that NPC focused on survival today
        npc.focused_on_survival_today = True
        
        status_text = f" (survival status: {old_status} → {new_status})" if new_status > old_status else f" (survival status: {old_status})"
        self.record_npc_action(npc, f"Focus on survival ({selected_activity})", f"Improved personal well-being{status_text}")
        print(f"\nSurvival focus completed successfully!")
    
    def controlled_npc_probe(self, npc: Contestant) -> None:
        """Allow player to control who an NPC probes for information."""
        print(f"\nControl {npc.name}'s Probe Action")
        print("-" * 40)
        
        player_tribe = self.get_player_tribe()
        if not player_tribe:
            print("No potential targets available.")
            return
        
        potential_targets = [c for c in player_tribe if c != npc and not c.eliminated]
        if not potential_targets:
            print("No valid targets to probe.")
            return
        
        print(f"\nWho should {npc.name} probe for information?")
        for i, target in enumerate(potential_targets, 1):
            player_marker = " (YOU)" if target.is_player else ""
            print(f"{i:2}. {target.name}{player_marker}")
        print(f"{len(potential_targets) + 1}. Cancel")
        
        while True:
            try:
                choice = input(f"\nSelect target (1-{len(potential_targets) + 1}): ").strip()
                choice_num = int(choice)
                
                if choice_num == len(potential_targets) + 1:
                    return
                    
                if 1 <= choice_num <= len(potential_targets):
                    selected_target = potential_targets[choice_num - 1]
                    break
                else:
                    print(f"Invalid choice. Please enter 1-{len(potential_targets) + 1}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        print(f"\n{npc.name} probes {selected_target.name} for information:")
        print("-" * 30)
        
        if selected_target.is_player:
            self.npc_probe_player(npc)
        else:
            self.contestant_speaks(npc, f"Hey {selected_target.name}, what's your take on how things are going?")
            
            roll = random.randint(1, 20)
            perception_bonus = npc.perception_skill
            relationship_bonus = max(0, npc.get_relationship(selected_target))
            target_resistance = selected_target.resistance_to_persuasion
            
            total_roll = roll + perception_bonus + relationship_bonus - target_resistance
            
            if total_roll >= 11:
                if selected_target.information_bank:
                    shared_info = random.choice(selected_target.information_bank)
                    info_text = selected_target.get_information_text_for_speaking(shared_info, listener=npc)
                    self.contestant_speaks(selected_target, f"{info_text}")
                    
                    probe_info = shared_info.copy()
                    probe_info['day'] = self.day
                    npc.information_bank.append(probe_info)
                    
                    if shared_info.get('type') == 'final_2' and shared_info.get('subject') and shared_info.get('target'):
                        if self.player in [shared_info.get('subject'), shared_info['target']]:
                            if npc.believes_has_final_2_with(self.player):
                                if npc not in self.npcs_needing_betrayal_confrontation:
                                    self.npcs_needing_betrayal_confrontation.append(npc)
                                    # Handle this confrontation immediately instead of waiting
                                    # Figure out which contestant they learned about
                                    other_contestant = shared_info['target'] if shared_info.get('subject') == self.player else shared_info.get('subject')
                                    self.handle_immediate_confrontation(npc, other_contestant)
                    
                    self.record_npc_action(npc, f"Probe {selected_target.name}", f"Success (Roll: {roll}, Total: {total_roll})")
                else:
                    self.contestant_speaks(selected_target, f"Things are going okay, I guess.")
                    self.record_npc_action(npc, f"Probe {selected_target.name}", f"Success but no info (Roll: {roll}, Total: {total_roll})")
            else:
                self.contestant_speaks(selected_target, f"Everything's fine. Just trying to survive out here.")
                self.record_npc_action(npc, f"Probe {selected_target.name}", f"Failure (Roll: {roll}, Total: {total_roll})")
        
        print(f"\nProbe completed!")
    
    def handle_day_1(self) -> None:
        """Handle Day 1 events."""
        # Apply start-of-day processing
        self.apply_start_of_day_processing()
        
        # Initialize daily tracking (like day_intro does for other days)
        self.today_npc_actions = {}
        self.today_idol_searches = {}
        self.contestants_who_interacted_with_player = []
        
        # Reset daily action tracking
        self.actions_taken_today = 0
        
        # Reset controlled actions tracking
        self.npcs_who_performed_controlled_actions = set()
        
        self.narration("A sailboat delivers twenty Survivor contestants, including you, to a pristine beach where two tribe mats await. You step onto the sand and take your place on your tribe's mat. Jeff Probst stands before you.")
        
        self.display_tribes_introduction()
        
        self.jeff_speaks(f"Welcome to Survivor! For the next 39 days, this will be your home. You've been divided into two tribes: {self.tribe1_name} and {self.tribe2_name}. You'll have to build shelter, find food, and compete in challenges. Every few days, one of you will be voted out of the game. In the end, only one of you will remain to claim the title of Sole Survivor and the million-dollar prize.")
        
        self.narration(f"You and your tribemates journey to the {self.get_player_tribe_name()} beach. After brief introductions the game is on. You look around at your new tribemates, wondering who you can trust and who will be the first to go.")
        
        # No tribal council on day 1
        self.player_tribe_has_tribal = False
        
        # NPCs decide whether to search for idols today
        self.npc_decide_idol_search()
        
        # Day 1 player actions
        self.player_actions()
        
        # Assign initial vote targets to opposing tribe on day 1
        self.assign_opposing_tribe_vote_targets()
        
        # Opposing tribe NPCs perform their actions (2 per day)
        self.perform_opposing_tribe_npc_actions()
    
    def handle_normal_day(self) -> None:
        """Handle a normal day in the game."""
        self.day_intro()
        
        self.narration("Another day in Survivor begins. The sun rises over camp as everyone begins their daily routines.")
        
        # Add survival status narration based on player's current status
        survival_narrations = {
            -1: "You wake up feeling exhausted and hungry. You want to lay in the shelter, but the game isn't slowing down for anyone else.",
            0: "You linger in the shelter for a few minutes before getting up and starting your day. Time to put hunger out of your mind and focus on the game.",
            1: "You pull yourself out of the shelter and look around camp taking mental notes of what needs to be done.",
            2: "You're eager to get back to the game. You have your plan for the day and it's time to get started.",
            3: "You wake up feeling energized and ready to take on the game! Nothing can slow you down!"
        }
        
        if self.player.survival_status in survival_narrations:
            self.narration(survival_narrations[self.player.survival_status])
        
        # Handle work penalty warning after survival status narration
        self.handle_work_penalty_warning()
        
        # Validate all vote targets to ensure no cross-tribe targeting
        self.validate_all_vote_targets()
        
        # Validate all vote targets to ensure no cross-tribe targeting
        self.validate_all_vote_targets()
        
        # No tribal council on normal days
        self.player_tribe_has_tribal = False
        
        # Update threat levels periodically (relationships may have changed)
        self.update_all_threat_levels()
        
        # NPCs decide whether to search for idols today
        self.npc_decide_idol_search()
        
        # Player actions
        self.player_actions()
        
        # If player didn't search for idol, let NPCs search at end of day
        if not self.player_searched_today and self.npcs_wanting_to_search:
            self.conduct_npc_only_idol_search()
        
        # Opposing tribe NPCs perform their actions (2 per day)
        self.perform_opposing_tribe_npc_actions()
        
        # At end of day 2, assign fallback vote targets for NPCs without targets
        if self.day == 2:
            self.assign_fallback_vote_targets_day_2()
            # Also assign vote targets to opposing tribe
            self.assign_opposing_tribe_vote_targets()
    
    def npc_decide_idol_search(self) -> None:
        """NPCs decide whether to search for idols today."""
        self.npcs_wanting_to_search = []
        self.player_searched_today = False
        
        # Get NPCs from player's tribe for decision making
        player_tribe = self.get_player_tribe()
        npcs = [c for c in player_tribe if not c.is_player and not c.eliminated]
        
        for npc in npcs:
            if npc.should_search_for_idol(self):
                self.npcs_wanting_to_search.append(npc)
    
    def conduct_npc_only_idol_search(self) -> None:
        """Conduct idol search when only NPCs are searching (player didn't search)."""
        if not self.npcs_wanting_to_search:
            return
            
        # Conduct the search with only NPCs (behind the scenes)
        self.process_idol_search(self.npcs_wanting_to_search, player_participates=False)
    
    def handle_pre_merge_immunity_day(self) -> None:
        """Handle a pre-merge immunity challenge and tribal council day."""
        self.day_intro()
        
        self.narration("Another day in Survivor begins. The sun rises over camp as everyone begins their daily routines.")
        
        # Add survival status narration based on player's current status
        survival_narrations = {
            -1: "You wake up feeling exhausted and hungry. You want to lay in the shelter, but the game isn't slowing down for anyone else.",
            0: "You linger in the shelter for a few minutes before getting up and starting your day. Time to put hunger out of your mind and focus on the game.",
            1: "You pull yourself out of the shelter and look around camp taking mental notes of what needs to be done.",
            2: "You're eager to get back to the game. You have your plan for the day and it's time to get started.",
            3: "You wake up feeling energized and ready to take on the game! Nothing can slow you down!"
        }
        
        if self.player.survival_status in survival_narrations:
            self.narration(survival_narrations[self.player.survival_status])
        
        # Handle work penalty warning after survival status narration
        self.handle_work_penalty_warning()
        
        # Validate all vote targets to ensure no cross-tribe targeting
        self.validate_all_vote_targets()
        
        # Immunity challenge
        player_tribe_wins = self.immunity_challenge()
        
        if player_tribe_wins:
            self.player_tribe_has_tribal = False
            self.narration(f"The {self.get_player_tribe_name()} tribe returns to camp, celebrating their victory.")
            # NPCs decide whether to search for idols today
            self.npc_decide_idol_search()
            # Player actions
            self.player_actions()
            
            # If player didn't search for idol, let NPCs search at end of day
            if not self.player_searched_today and self.npcs_wanting_to_search:
                self.conduct_npc_only_idol_search()
            
            # Opposing tribe NPCs perform their actions (2 per day)
            self.perform_opposing_tribe_npc_actions()
            
            # Handle tribal council for the other tribe
            other_tribe = self.get_other_tribe()
            if other_tribe:
                self.narration("Meanwhile at tribal council...")
                self.narration(f"The {self.get_other_tribe_name()} tribe voted someone out.")
                self.eliminate_contestant_from_other_tribe_via_voting()
        else:
            self.player_tribe_has_tribal = True
            self.narration(f"The {self.get_player_tribe_name()} tribe returns to camp, dejected from their loss.")
            # NPCs decide whether to search for idols today
            self.npc_decide_idol_search()
            # Player actions
            self.player_actions()
            
            # If player didn't search for idol, let NPCs search at end of day
            if not self.player_searched_today and self.npcs_wanting_to_search:
                self.conduct_npc_only_idol_search()
            
            # Opposing tribe NPCs perform their actions (2 per day)
            self.perform_opposing_tribe_npc_actions()
            
            # Tribal council for player's tribe
            self.tribal_council()
    
    def eliminate_contestant_from_other_tribe_via_voting(self) -> None:
        """Eliminate a contestant from the other tribe based on NPC vote targets."""
        other_tribe = self.get_other_tribe()
        if not other_tribe:
            return
            
        # Count votes for each contestant
        vote_counts = {}
        voters = [c for c in other_tribe if not c.eliminated]
        
        # Initialize vote counts
        for contestant in voters:
            vote_counts[contestant] = 0
            
        # Count votes based on NPCs' vote targets
        for voter in voters:
            if voter.vote_target and voter.vote_target in voters:
                vote_counts[voter.vote_target] += 1
            else:
                # Fallback: assign a vote target if they don't have one
                self.assign_random_vote_target(voter)
                if voter.vote_target and voter.vote_target in voters:
                    vote_counts[voter.vote_target] += 1
        
        # Find contestant(s) with most votes
        if vote_counts:
            max_votes = max(vote_counts.values())
            most_voted = [contestant for contestant, votes in vote_counts.items() if votes == max_votes]
            
            # Break ties randomly
            eliminated = random.choice(most_voted)
        else:
            # Ultimate fallback: random elimination
            eliminated = random.choice(voters)
            
        eliminated.eliminated = True
        self.eliminated_contestants.append(eliminated)
        
        # Clean up final 2 deals involving the eliminated contestant
        if eliminated.final_2_deal:
            # Their final 2 partner loses their deal
            eliminated.final_2_deal.final_2_deal = None
            eliminated.final_2_deal = None
        
        # Remove eliminated contestant from fake final 2 deals
        for contestant in self.contestants:
            if eliminated in contestant.fake_final_2_deals:
                contestant.fake_final_2_deals.remove(eliminated)
        
        # Lock relationships for the eliminated contestant
        self.lock_relationships_for_elimination(eliminated)
        
        # Update target rosters after elimination
        self.update_target_roster_after_elimination(eliminated)
        
        # Clean up outdated information from all info banks including alliance info
        self.clean_info_banks_after_tribal(eliminated)
    
    def handle_merge_day(self) -> None:
        """Handle the merge day."""
        self.day_intro()
        
        self.narration("Both tribes arrive at the challenge beach, where Jeff Probst awaits with a smile.")
        self.jeff_speaks("Drop your buffs. We are merged!")
        
        # Before merging, check if vote targets need updating
        for contestant in self.get_active_contestants():
            if not contestant.is_player and contestant.vote_target:
                # Check if current vote target was from the other tribe
                if contestant.tribe != contestant.vote_target.tribe:
                    # Will need new vote target since couldn't vote cross-tribe pre-merge
                    contestant.vote_target = None
        
        # Store original tribes before merge
        original_tribes = {}
        for contestant in self.get_active_contestants():
            original_tribes[contestant] = contestant.tribe
        
        # Merge the tribes
        self.merged = True
        for contestant in self.get_active_contestants():
            contestant.tribe = self.merge_tribe_name
        
        # Check and remove "good jury relationships" move for pre-merge violations
        self.check_jury_relationships_at_merge()
        
        # Update vote targets and target rosters for the merged game
        self.reset_targets_at_merge(original_tribes)
        
        # Clean up vote pitch information since all cross-tribe info is now irrelevant
        self.clean_cross_tribe_vote_pitches()
        
        # Update threat levels for merge
        self.update_threat_levels_at_merge()
        
        self.narration("Jeff hands out new buffs to everyone. The two tribes are now one.")
        self.jeff_speaks("Congratulations, you've made the merge. From now on, challenges will be individual. Head back to camp and enjoy your merge feast.")
        
        # Reset idols at merge (hide new merge-specific idols)
        # Pre-merge idols are no longer relevant, post-merge uses merge idols
        self.idol_found_merge = False
        
        # Give someone a chance to find an idol right away during merge feast
        active_contestants = [c for c in self.get_active_contestants() if not c.has_idol]
        
        if active_contestants:
            lucky_contestant = random.choice(active_contestants)
            roll = random.randint(1, 20)
            if roll >= 18:
                lucky_contestant.has_idol = True
                self.idol_finder_history[lucky_contestant.name] = f"Day {self.day}"
                # Add to contestant's info bank
                lucky_contestant.add_information('has_idol', lucky_contestant)
                if lucky_contestant == self.player:
                    self.narration("While exploring the merge feast area, you find something hidden in the decorations. It's a hidden immunity idol!")
                self.idol_found_merge = True  # Mark merge idol as found
        
        self.narration("The newly merged tribe returns to camp to enjoy a feast and strategize for the individual phase of the game.")
        
        # Merge feast reinvigorates everyone - set all survival status to 3
        for contestant in self.get_active_contestants():
            contestant.survival_status = 3
        
        self.narration("The feast reinvigorates everyone. After days of struggling with limited food and resources, the merge celebration gives everyone renewed energy!")
        
        # Reset work streaks for all contestants due to merge
        self.reset_work_streaks("")
        
        # No tribal council on merge day
        self.player_tribe_has_tribal = False
        
        # NPCs decide whether to search for idols today
        self.npc_decide_idol_search()
        
        # Player actions
        self.player_actions()
    
    def check_jury_relationships_at_merge(self) -> None:
        """Check pre-merge relationship violations and remove good jury relationships move if needed."""
        # Get all contestants who made it to merge (potential jury members)
        merge_survivors = self.get_active_contestants()
        
        # Check each contestant's pre-merge relationship violations
        for contestant in merge_survivors:
            # Check if they had -1 relationships with any other merge survivors
            for other_survivor in merge_survivors:
                if (other_survivor != contestant and 
                    other_survivor in contestant.relationships_dropped_to_minus_one):
                    # They had a -1 relationship with someone who made merge
                    contestant.remove_game_move('good_jury_relationships')
                    break  # Only need to remove once
    
    def handle_tribe_swap_day(self) -> None:
        """Handle Day 13 tribe swap with reward challenge."""
        self.day_intro()
        
        self.narration("Another day in Survivor begins. The sun rises over camp as everyone begins their daily routines.")
        
        # Add survival status narration
        survival_narrations = {
            -1: "You wake up feeling exhausted and hungry. You want to lay in the shelter, but the game isn't slowing down for anyone else.",
            0: "You linger in the shelter for a few minutes before getting up and starting your day. Time to put hunger out of your mind and focus on the game.",
            1: "You pull yourself out of the shelter and look around camp taking mental notes of what needs to be done.",
            2: "You're eager to get back to the game. You have your plan for the day and it's time to get started.",
            3: "You wake up feeling energized and ready to take on the game! Nothing can slow you down!"
        }
        
        if self.player.survival_status in survival_narrations:
            self.narration(survival_narrations[self.player.survival_status])
        
        # Handle work penalty warning after survival status narration
        self.handle_work_penalty_warning()
        
        # Validate all vote targets to ensure no cross-tribe targeting
        self.validate_all_vote_targets()
        
        self.jeff_speaks("Come on in guys!")
        self.narration("Both tribes enter the challenge arena for a reward challenge.")
        
        # Reveal any unrevealed eliminated contestants from the other tribe
        if self.day > 3 and len(self.eliminated_contestants) > 0:
            other_tribe_name = self.get_other_tribe_name()
            unrevealed_other_tribe = [c for c in self.eliminated_contestants 
                                    if c.tribe == other_tribe_name 
                                    and c not in self.revealed_eliminations]
            
            # Reveal the most recent unrevealed elimination
            if unrevealed_other_tribe:
                last_eliminated = unrevealed_other_tribe[-1]
                self.jeff_speaks(f"{self.get_player_tribe_name()}, getting your first look at the new {other_tribe_name} tribe. {last_eliminated.name} voted out at the last tribal council.")
                self.revealed_eliminations.append(last_eliminated)
        
        self.jeff_speaks("Before we get to today's challenge...")
        self.narration("Jeff smirks")
        self.jeff_speaks("Drop your buffs! We are switching things up!")
        
        self.narration("Jeff Probst brings each a basket of new buffs wrapped in cloth. One by one the players pick their new buffs.")
        
        # Store original tribes for vote target logic
        original_tribes = {}
        for contestant in self.get_active_contestants():
            original_tribes[contestant] = contestant.tribe
            
        # Perform the tribe swap
        self.perform_tribe_swap()
        
        # Adjust game security based on pre-swap levels
        for contestant in self.get_active_contestants():
            if not contestant.is_player:  # Only adjust NPCs
                # Get current security (after any other adjustments)
                current_security = contestant.get_game_security()
                
                # Apply tribe swap security adjustment
                if current_security >= 6:
                    contestant.modify_base_game_security(-1, "Tribe swap uncertainty (high security)", silent=True)
                elif current_security <= 5:
                    contestant.modify_base_game_security(1, "Tribe swap opportunity (low security)", silent=True)
        
        self.display_tribes_after_swap()
        
        
        # Pre-challenge dialogue
        self.jeff_speaks("Ready to get to today's reward challenge?")
        self.narration("The contestants enthusiastically say yes.")
        
        # Run reward challenge
        winning_tribe = self.tribe_swap_reward_challenge()
        
        # Apply survival status bonus to winning tribe
        winning_tribe_members = [c for c in self.get_active_contestants() if c.tribe == winning_tribe]
        for contestant in winning_tribe_members:
            contestant.survival_status = 3
            
        self.narration(f"The {winning_tribe} tribe celebrates their victory, feeling energized and ready to take on their new tribal dynamic!")
        
        # Reset vote targets using merge logic (appropriate for tribe swap)
        self.reset_targets_at_merge(original_tribes)
        
        # Handle cross-tribe vote targets after swap
        self.handle_cross_tribe_vote_targets_after_swap()
        
        # Check if player's vote target is no longer on their tribe after swap  
        if self.player.vote_target and self.player.vote_target.tribe != self.player.tribe:
            self.narration(f"Your current vote target, {self.player.vote_target.name}, is no longer on your tribe after the swap.")
            self.prompt_player_vote_target("Please select a new vote target:")
        
        # No tribal council on tribe swap day
        self.player_tribe_has_tribal = False
        
        # NPCs decide whether to search for idols today
        self.npc_decide_idol_search()
        
        # Player actions with new tribe
        self.player_actions()
        
        # Opposing tribe NPCs perform their actions (2 per day)
        self.perform_opposing_tribe_npc_actions()
        
        # If player didn't search for idol, let NPCs search at end of day
        if not self.player_searched_today and self.npcs_wanting_to_search:
            self.conduct_npc_only_idol_search()
    
    def perform_tribe_swap(self) -> None:
        """Randomly reassign all active contestants to new tribes."""
        active_contestants = self.get_active_contestants()
        
        # Shuffle contestants randomly
        random.shuffle(active_contestants)
        
        # Split evenly between the two tribes
        tribe_size = len(active_contestants) // 2
        
        # Assign first half to tribe1, second half to tribe2
        for i, contestant in enumerate(active_contestants):
            if i < tribe_size:
                contestant.tribe = self.tribe1_name
            else:
                contestant.tribe = self.tribe2_name
                
        # If odd number, randomly assign the last person
        if len(active_contestants) % 2 == 1:
            last_contestant = active_contestants[-1]
            last_contestant.tribe = random.choice([self.tribe1_name, self.tribe2_name])
        
        # Clear outdated targeting information since tribal dynamics have completely changed
        self.clear_targeting_info_after_swap()
        
        # Clean up vote pitch information from players who are now in different tribes
        self.clean_cross_tribe_vote_pitches()
        
        # Reset work streaks for all contestants due to tribe swap
        self.reset_work_streaks("tribe swap")
    
    def clear_targeting_info_after_swap(self) -> None:
        """Remove outdated targeting information after tribe swap.
        
        Consensus votes, vote targets, and target rosters from the pre-swap phase 
        are no longer relevant since tribal dynamics have completely changed and 
        contestants may not even be on the same tribe anymore.
        """
        active_contestants = self.get_active_contestants()
        
        for contestant in self.contestants:
            # Clear vote targets and target rosters for all contestants except the player
            if not contestant.is_player and not contestant.eliminated:
                # Clear current vote target
                contestant.vote_target = None
                
                # Clear target roster - they'll need to form new opinions about new tribemates
                contestant.target_roster = []
            
            # Clear targeting information from information banks for all contestants
            if contestant.information_bank:
                original_count = len(contestant.information_bank)
                contestant.information_bank = [
                    info for info in contestant.information_bank 
                    if info['type'] not in ['consensus_vote', 'vote_target', 'target_roster', 'vote_pitch']
                ]
                
                # Optional debug output
                removed_count = original_count - len(contestant.information_bank)
                if hasattr(self, 'debug_info_tracking') and self.debug_info_tracking and removed_count > 0:
                    print(f"  {contestant.name}: Removed {removed_count} outdated targeting info")
    
    def display_tribes_after_swap(self) -> None:
        """Display the new tribe compositions after the swap."""
        tribe1_members = [c for c in self.get_active_contestants() if c.tribe == self.tribe1_name]
        tribe2_members = [c for c in self.get_active_contestants() if c.tribe == self.tribe2_name]
        
        print("\n" + "-"*80)
        print("TRIBE SWAP RESULTS")
        print("-"*80)
        print()
        
        print(f"{self.tribe1_name} Tribe:")
        for contestant in tribe1_members:
            status = " (You)" if contestant.is_player else ""
            print(f"- {contestant.name}{status}")
            
        print(f"\n{self.tribe2_name} Tribe:")
        for contestant in tribe2_members:
            status = " (You)" if contestant.is_player else ""
            print(f"- {contestant.name}{status}")
        
        print("\nEliminated:")
        for contestant in self.revealed_eliminations:
            jury_status = " (Jury)" if contestant in self.jury else ""
            print(f"- {contestant.name}{jury_status}")
            
        print()
    
    def tribe_swap_reward_challenge(self) -> str:
        """Run a reward challenge after tribe swap. Returns winning tribe name."""
        # Get challenge description
        challenge_description = self.get_premerge_challenge_description("reward")
        self.jeff_speaks(challenge_description)
        self.narration("The tribes take their places.")
        self.jeff_speaks("Survivors ready... GO!")
        
        
        # Get tribe members
        tribe1_members = [c for c in self.get_active_contestants() if c.tribe == self.tribe1_name]
        tribe2_members = [c for c in self.get_active_contestants() if c.tribe == self.tribe2_name]
        
        # Calculate average challenge skills
        tribe1_avg_skill = sum(c.challenge_skill for c in tribe1_members) / len(tribe1_members)
        tribe2_avg_skill = sum(c.challenge_skill for c in tribe2_members) / len(tribe2_members)
        
        # Calculate elite bonuses
        tribe1_elite_bonus = sum(2 for c in tribe1_members if c.challenge_skill == 3)
        tribe2_elite_bonus = sum(2 for c in tribe2_members if c.challenge_skill == 3)
        
        # Calculate survival status modifiers (capped at ±4 for pre-merge)
        tribe1_survival_bonus = sum(c.get_survival_status_modifier("challenge") for c in tribe1_members)
        tribe2_survival_bonus = sum(c.get_survival_status_modifier("challenge") for c in tribe2_members)
        
        # Cap survival bonuses at ±4 for pre-merge challenges
        tribe1_survival_bonus = max(-4, min(4, tribe1_survival_bonus))
        tribe2_survival_bonus = max(-4, min(4, tribe2_survival_bonus))
        
        # Roll d20 for each tribe
        tribe1_base_roll = random.randint(1, 20)
        tribe2_base_roll = random.randint(1, 20)
        
        tribe1_total = tribe1_base_roll + tribe1_avg_skill + tribe1_elite_bonus + tribe1_survival_bonus
        tribe2_total = tribe2_base_roll + tribe2_avg_skill + tribe2_elite_bonus + tribe2_survival_bonus
        
        # Display challenge calculations
        tribe1_calc = f"{tribe1_base_roll} + {tribe1_avg_skill:.1f} skill"
        if tribe1_elite_bonus > 0:
            tribe1_calc += f" + {tribe1_elite_bonus} elite bonus"
        if tribe1_survival_bonus != 0:
            tribe1_calc += f" + {tribe1_survival_bonus} survival"
        tribe1_calc += f" = {tribe1_total:.1f}"
        
        tribe2_calc = f"{tribe2_base_roll} + {tribe2_avg_skill:.1f} skill"
        if tribe2_elite_bonus > 0:
            tribe2_calc += f" + {tribe2_elite_bonus} elite bonus"
        if tribe2_survival_bonus != 0:
            tribe2_calc += f" + {tribe2_survival_bonus} survival"
        tribe2_calc += f" = {tribe2_total:.1f}"
        
        
        # Determine winner
        if tribe1_total > tribe2_total:
            self.narration(f"{self.tribe1_name} wins the reward challenge!")
            return self.tribe1_name
        elif tribe2_total > tribe1_total:
            self.narration(f"{self.tribe2_name} wins the reward challenge!")
            return self.tribe2_name
        else:
            # Tie - randomly select winner
            winner = random.choice([self.tribe1_name, self.tribe2_name])
            self.narration(f"It's a tie! {winner} wins by a narrow margin!")
            return winner
    
    def handle_cross_tribe_vote_targets_after_swap(self) -> None:
        """Handle NPCs whose vote targets are now on different tribes after swap.
        Move cross-tribe vote targets to target roster and clear vote target."""
        for contestant in self.get_active_contestants():
            # Skip player - they handle their own targets
            if contestant.is_player:
                continue
                
            # Check if this NPC's vote target is now on a different tribe
            if (contestant.vote_target and 
                contestant.vote_target.tribe != contestant.tribe and
                not contestant.vote_target.eliminated):
                
                # Move vote target to target roster if not already there
                if contestant.vote_target not in contestant.target_roster:
                    contestant.target_roster.append(contestant.vote_target)
                
                # Clear the vote target since they can't vote cross-tribe
                contestant.vote_target = None
    
    def validate_all_vote_targets(self) -> None:
        """Validate all vote targets to ensure no cross-tribe targeting during pre-merge."""
        if self.merged:
            return  # Post-merge allows cross-tribe targeting
            
        for contestant in self.get_active_contestants():
            if contestant.is_player:
                continue  # Player manages their own targets
                
            # Check vote target
            if (contestant.vote_target and 
                contestant.vote_target.tribe != contestant.tribe):
                # Move to target roster if not already there
                if contestant.vote_target not in contestant.target_roster:
                    contestant.target_roster.append(contestant.vote_target)
                contestant.vote_target = None
                
            # Clean up target roster - remove cross-tribe targets during pre-merge
            contestant.target_roster = [
                target for target in contestant.target_roster 
                if target.tribe == contestant.tribe or target.eliminated
            ]
    
    def handle_post_merge_immunity_day(self) -> None:
        """Handle a post-merge immunity challenge and tribal council day."""
        self.day_intro()
        
        # Check for long-lasting alliances on day 34 (Level 3 game move)
        if self.day == 34:
            self.check_long_lasting_alliances()
        
        self.narration("Another day in Survivor begins. The sun rises over camp as everyone begins their daily routines.")
        
        # Add survival status narration based on player's current status
        survival_narrations = {
            -1: "You wake up feeling exhausted and hungry. You want to lay in the shelter, but the game isn't slowing down for anyone else.",
            0: "You linger in the shelter for a few minutes before getting up and starting your day. Time to put hunger out of your mind and focus on the game.",
            1: "You pull yourself out of the shelter and look around camp taking mental notes of what needs to be done.",
            2: "You're eager to get back to the game. You have your plan for the day and it's time to get started.",
            3: "You wake up feeling energized and ready to take on the game! Nothing can slow you down!"
        }
        
        if self.player.survival_status in survival_narrations:
            self.narration(survival_narrations[self.player.survival_status])
        
        # Handle work penalty warning after survival status narration
        self.handle_work_penalty_warning()
        
        # Validate all vote targets to ensure no cross-tribe targeting
        self.validate_all_vote_targets()
        
        # Immunity challenge
        self.immunity_challenge()
        
        self.narration("The tribe returns to camp after the challenge.")
        
        # Update threat levels after immunity challenge
        self.update_all_threat_levels()
        
        # Post-merge always has tribal council
        self.player_tribe_has_tribal = True
        
        # NPCs decide whether to search for idols today
        self.npc_decide_idol_search()
        
        # Player actions
        self.player_actions()
        
        # If player didn't search for idol, let NPCs search at end of day
        if not self.player_searched_today and self.npcs_wanting_to_search:
            self.conduct_npc_only_idol_search()
        
        # Tribal council
        self.tribal_council()
    
    def handle_final_three_day(self) -> None:
        """Handle the final three day."""
        self.day_intro()
        
        self.narration("The final three contestants arrive at the challenge area for the final immunity challenge.")
        
        # Final immunity challenge
        self.immunity_challenge()
        
        # Final three always has tribal council
        self.player_tribe_has_tribal = True
        
        # At final 3, need special handling to avoid ties
        # Force votes to different people to avoid ties
        active_contestants = self.get_active_contestants()
        if len(active_contestants) == 3:
            # Find the immunity winner
            immunity_winner = None
            for contestant in active_contestants:
                if contestant.immune:
                    immunity_winner = contestant
                    break
            
            if immunity_winner:
                # Add voting booth narration
                self.narration("" + "="*80)
                if immunity_winner == self.player:
                    self.narration("You walk to the voting booth to cast the final vote.")
                else:
                    self.narration(f"{immunity_winner.name} walks to the voting booth to cast the final vote.")
                self.narration("" + "="*80)
                
                self.jeff_speaks("I'll get the vote")
                
                self.narration("" + "="*80)
                self.narration("Jeff retrieves the urn and returns to face the tribe.")
                self.narration("" + "="*80)
                
                self.jeff_speaks("Once the vote is read, the decision if final. The person voted out will be asked to leave the tribal council area immediately. I'll read the vote.")
                
                self.narration("Jeff retrieves the sole vote from the urn.")
                
                if immunity_winner == self.player:
                    # Player chooses who to eliminate
                    eligible_to_vote_for = [c for c in active_contestants if not c.immune and c != self.player]
                    if eligible_to_vote_for:
                        print(f"\nYou must choose who to eliminate:")
                        for i, c in enumerate(eligible_to_vote_for, 1):
                            print(f"{i}. {c.name}")
                        
                        choice = None
                        while choice is None:
                            try:
                                user_input = input("Who do you choose to eliminate? ")
                                if self.check_for_cheat_code(user_input):
                                    continue  # Ask again after cheat menu
                                selection = int(user_input)
                                if 1 <= selection <= len(eligible_to_vote_for):
                                    choice = eligible_to_vote_for[selection - 1]
                                else:
                                    print("Invalid choice. Please try again.")
                            except ValueError:
                                print("Invalid input. Please enter a number.")
                            
                            # Eliminate chosen contestant
                            choice.eliminated = True
                            self.eliminated_contestants.append(choice)
                            
                            # Clean up final 2 deals involving the eliminated contestant
                            if choice.final_2_deal:
                                choice.final_2_deal.final_2_deal = None
                                choice.final_2_deal = None
                            for contestant in self.contestants:
                                if choice in contestant.fake_final_2_deals:
                                    contestant.fake_final_2_deals.remove(choice)
                            
                            # Lock relationships for the eliminated contestant
                            self.lock_relationships_for_elimination(choice)
                            
                            # Calculate elimination position and jury position
                            elimination_position = len(self.eliminated_contestants) + 1
                            position_str = self.get_position_string(elimination_position)
                            
                            jury_str = ""
                            if self.day >= self.merge_day:
                                self.jury.append(choice)
                                jury_position = len(self.jury)
                                if jury_position == 1:
                                    jury_str = " and the first member of our jury"
                                else:
                                    jury_str = f" and the {self.get_position_string(jury_position)} member of our jury"
                            
                            self.jeff_speaks(f"{position_str} person voted out of Survivor{jury_str}...")
                            self.narration(f"Jeff Probst flips over the final vote to reveal: {choice.name}")
                            self.narration(f"{choice.name} brings {choice.get_pronoun('possessive')} torch to Jeff")
                            self.jeff_speaks(f"{choice.name}, the tribe has spoken.")
                            self.narration("Jeff snuff out the torch")
                            self.narration("The final two contestants grab their torches and head back to camp.")
                            
                            # Clean up outdated information from all info banks including alliance info
                            self.clean_info_banks_after_tribal(choice)
                            return
                else:
                    # NPC chooses who to eliminate (if not the player)
                    eligible_to_eliminate = [c for c in active_contestants if not c.immune and c != immunity_winner]
                    if eligible_to_eliminate:
                        chosen = random.choice(eligible_to_eliminate)
                        chosen.eliminated = True
                        self.eliminated_contestants.append(chosen)
                        
                        # Clean up final 2 deals involving the eliminated contestant
                        if chosen.final_2_deal:
                            chosen.final_2_deal.final_2_deal = None
                            chosen.final_2_deal = None
                        for contestant in self.contestants:
                            if chosen in contestant.fake_final_2_deals:
                                contestant.fake_final_2_deals.remove(chosen)
                        
                        # Lock relationships for the eliminated contestant
                        self.lock_relationships_for_elimination(chosen)
                        
                        # Calculate elimination position and jury position
                        elimination_position = len(self.eliminated_contestants) + 1
                        position_str = self.get_position_string(elimination_position)
                        
                        jury_str = ""
                        if self.day >= self.merge_day:
                            self.jury.append(chosen)
                            jury_position = len(self.jury)
                            if jury_position == 1:
                                jury_str = " and the first member of our jury"
                            else:
                                jury_str = f" and the {self.get_position_string(jury_position)} member of our jury"
                        
                        self.jeff_speaks(f"{position_str} person voted out of Survivor{jury_str}...")
                        self.narration(f"Jeff Probst flips over the final vote to reveal: {chosen.name}")
                        self.narration(f"{chosen.name} brings {chosen.get_pronoun('possessive')} torch to Jeff")
                        self.jeff_speaks(f"{chosen.name}, the tribe has spoken.")
                        self.narration("Jeff snuff out the torch")
                        self.narration("The final two contestants grab their torches and head back to camp.")
                        
                        # Clean up outdated information from all info banks including alliance info
                        self.clean_info_banks_after_tribal(chosen)
                        return
        
        # If we didn't handle it above, just do a normal tribal council
        # (this code should not execute in a normal game, but is here as a fallback)
        self.tribal_council()
    
    def get_tribal_council_questions(self) -> List[Dict[str, any]]:
        """Get the list of tribal council questions and their answer types."""
        return [
            {
                'id': 1,
                'question': "What was your biggest strategic move that got you to the final two?",
                'answer_type': 'game_move',
                'required_move_level': 2  # Requires at least a level 2 move
            },
            {
                'id': 2,
                'question': "Tell me about a time you took a big risk that paid off.",
                'answer_type': 'game_move',
                'required_move_level': 2
            },
            {
                'id': 3,
                'question': "What did you do to prove you could stay strong until the end?",
                'answer_type': 'game_move',
                'required_move_level': 1
            },
            {
                'id': 4,
                'question': "Why did you play Survivor, and what did it mean to you?",
                'answer_type': 'predetermined',
                'answers': [
                    {
                        'short': "To challenge myself",
                        'full': "I came out here to challenge myself and grow as a person"
                    },
                    {
                        'short': "For my family",
                        'full': "I played this game with one goal in mind. To win the million dollars and secure my family's future"
                    },
                    {
                        'short': "To prove I'm the best",
                        'full': "I wanted to prove I'm the best at this game"
                    }
                ]
            },
            {
                'id': 5,
                'question': "Did you play an honest game, or did you rely on deception?",
                'answer_type': 'predetermined',
                'answers': [
                    {
                        'short': "Played honestly",
                        'full': "I played honestly. I built trust with integrity and used that to get myself to the end of the game"
                    },
                    {
                        'short': "Balanced both",
                        'full': "I tried to balance honesty and deception. I was honest, but I lied if I needed to"
                    },
                    {
                        'short': "Used deception strategically",
                        'full': "I used every tool at my disposal. I used deception strategically to outwit everyone else"
                    }
                ]
            },
            {
                'id': 6,
                'question': "What was the hardest moment for you in the game, and how did you overcome it?",
                'answer_type': 'predetermined',
                'answers': [
                    {
                        'short': "Losing alliance members",
                        'full': "Watching my alliance members get voted out was the hardest part of the game for me"
                    },
                    {
                        'short': "The physical challenges",
                        'full': "Definitely the element. This game tested me physically, but I maintained focus the whole time."
                    },
                    {
                        'short': "Never felt tested",
                        'full': "I don't think I ever felt truly tested. I stayed in focused and in control"
                    }
                ]
            },
            {
                'id': 7,
                'question': "How did you respect the jury's game while playing your own?",
                'answer_type': 'predetermined',
                'answers': [
                    {
                        'short': "Learned from them",
                        'full': "I was always aware of the game you all were playing. I learned from you and that's how I made it this far"
                    },
                    {
                        'short': "Did what was necessary",
                        'full': "I did what I needed to in the game and I got help from the jurors while I could, but ultimately you all had to be voted out."
                    },
                    {
                        'short': "Focused on my strategy",
                        'full': "Honestly, I focused on my own strategy. I was only interested in how the jury could help me achieve my goals"
                    }
                ]
            },
            {
                'id': 8,
                'question': "What move are you most proud of, and why does it show you deserve to win?",
                'answer_type': 'game_move',
                'required_move_level': 2
            },
            {
                'id': 9,
                'question': "How did you stay true to yourself while playing this cutthroat game?",
                'answer_type': 'predetermined',
                'answers': [
                    {
                        'short': "Stayed true to myself",
                        'full': "I made sure that I didn't compromise who I am at my core. I stayed true to myself the entire game."
                    },
                    {
                        'short': "Had to compromise",
                        'full': "I had to compromise on some of my values out here. I'm not proud of everything I had to do, but it was necessary to get this far."
                    },
                    {
                        'short': "Left values at home",
                        'full': "I left my values at home. There's a time and place for that, and it's not Survivor."
                    }
                ]
            }
        ]

    def handle_jury_questioning(self, finalists: List[Contestant], 
                                   speech_modifiers: Dict[Contestant, float]) -> Dict[Contestant, Dict[Contestant, float]]:
        """Handle the jury questioning phase of final tribal council.
        
        Args:
            finalists: List of contestants in the final tribal council
            speech_modifiers: Dictionary mapping each finalist to their opening speech modifier
        
        Returns:
            Dictionary mapping each finalist to their question roll modifiers for each juror
        """
        self.jeff_speaks("Jury, you now have a chance to address the final two.")
        self.narration("The jury members will each ask a question to better understand the finalists' games.")
        
        # Initialize question roll tracking
        question_roll_modifiers = {finalist: {juror: 0.0 for juror in self.jury} for finalist in finalists}
        
        # Get all available questions
        all_questions = self.get_tribal_council_questions()
        available_questions = all_questions.copy()
        random.shuffle(available_questions)
        
        # Each juror asks a question
        for juror in self.jury:
            if not available_questions:
                # This shouldn't happen with 9 questions and typical jury size, but just in case
                break
                
            # Check if this is the player as a jury spectator
            if hasattr(self, 'player_is_jury_spectator') and self.player_is_jury_spectator and juror.is_player:
                # Allow player to choose their question
                self.narration(f"\nIt's your turn to ask a question as a jury member.")
                
                # Show available questions
                print("\nChoose a question to ask the finalists:")
                for i, q in enumerate(available_questions, 1):
                    print(f"{i}. {q['question']}")
                
                while True:
                    try:
                        choice = input(f"\nSelect your question (1-{len(available_questions)}): ").strip()
                        choice_num = int(choice)
                        if 1 <= choice_num <= len(available_questions):
                            question_data = available_questions.pop(choice_num - 1)
                            break
                        else:
                            print(f"Please enter a number between 1 and {len(available_questions)}")
                    except ValueError:
                        print("Invalid input. Please enter a number.")
                
                self.narration(f"\n{juror.name} stands to address the finalists.")
                self.contestant_speaks(juror, question_data['question'])
            else:
                # Select and remove a question from available pool for NPCs
                question_data = available_questions.pop(0)
                
                self.narration(f"\n{juror.name} stands to address the finalists.")
                self.contestant_speaks(juror, question_data['question'])
            
            # Each finalist answers the question
            for finalist in finalists:
                if question_data['answer_type'] == 'game_move':
                    answer_quality = self.handle_game_move_answer(finalist, question_data)
                else:  # predetermined answer
                    answer_quality = self.handle_predetermined_answer(finalist, question_data)
                
                # Calculate question roll modifier based on answer quality and speech performance
                speech_modifier = speech_modifiers.get(finalist, 0.0)
                modifier = self.calculate_question_roll_modifier(answer_quality, juror, finalist, speech_modifier)
                question_roll_modifiers[finalist][juror] += modifier
        
        self.jeff_speaks("Thank you jury. You've heard from the finalists. It's now time to vote.")
        return question_roll_modifiers
    
    def handle_game_move_answer(self, finalist: Contestant, question_data: Dict) -> str:
        """Handle a finalist's answer to a game move question.
        
        Returns:
            Answer quality: 'critical_failure', 'failure', 'neutral', 'success', or 'critical_success'
        """
        required_level = question_data.get('required_move_level', 1)
        
        # Get qualifying moves from the finalist's game move bank
        # For player, show all moves regardless of level requirement
        if finalist.is_player:
            qualifying_moves = finalist.game_move_bank
        else:
            qualifying_moves = [move for move in finalist.game_move_bank 
                              if move['level'] >= required_level]
        
        if not qualifying_moves:
            # Finalist has no qualifying moves
            self.narration(f"{finalist.name} struggles to come up with a concrete example.")
            self.contestant_speaks(finalist, "Well, uh... I played a strong social game throughout... "
                                 "I made connections and... uh... kept myself safe...")
            return 'critical_failure'
        
        if finalist.is_player:
            # Let player choose from their game moves
            print(f"\nChoose a game move to highlight:")
            for i, move in enumerate(qualifying_moves, 1):
                print(f"{i}. Day {move['day']}: {move['description']}")
            
            while True:
                try:
                    choice = input(f"Select your answer (1-{len(qualifying_moves)}): ").strip()
                    choice_num = int(choice)
                    if 1 <= choice_num <= len(qualifying_moves):
                        selected_move = qualifying_moves[choice_num - 1]
                        break
                    else:
                        print(f"Please enter a number between 1 and {len(qualifying_moves)}")
                except ValueError:
                    print("Invalid input. Please enter a number.")
        else:
            # NPC selects their best move (highest level, most recent)
            selected_move = max(qualifying_moves, key=lambda m: (m['level'], m['day']))
        
        # Finalist describes their move
        self.contestant_speaks(finalist, f"I {selected_move['description']}. "
                             f"This move showed my ability to {self.get_move_significance(selected_move['move_type'])}.")
        
        # Determine answer quality based on move level and how well it fits the question
        if selected_move['level'] == 3:
            return 'critical_success'
        elif selected_move['level'] == 2:
            return 'success'
        else:
            return 'neutral'
    
    def handle_predetermined_answer(self, finalist: Contestant, question_data: Dict) -> str:
        """Handle a finalist's answer to a predetermined answer question.
        
        Returns:
            Answer quality: 'critical_failure', 'failure', 'neutral', 'success', or 'critical_success'
        """
        answers = question_data['answers']
        
        if finalist.is_player:
            # Let player choose their answer
            print(f"\nHow do you want to answer?")
            for i, answer in enumerate(answers, 1):
                print(f"{i}. {answer['short']}")
            
            while True:
                try:
                    choice = input(f"Select your answer (1-{len(answers)}): ").strip()
                    choice_num = int(choice)
                    if 1 <= choice_num <= len(answers):
                        selected_answer = answers[choice_num - 1]
                        break
                    else:
                        print(f"Please enter a number between 1 and {len(answers)}")
                except ValueError:
                    print("Invalid input. Please enter a number.")
        else:
            # NPC selects answer based on their attributes
            # Strategic NPCs tend toward answer 3, Heroes toward 1, others vary
            if finalist.strategic_skill >= 2:
                selected_answer = answers[-1]  # Usually the most cutthroat option
            elif finalist.hero_or_villain == "Hero":
                selected_answer = answers[0]  # Usually the most noble option
            else:
                selected_answer = random.choice(answers)
        
        # Finalist gives their answer
        self.contestant_speaks(finalist, selected_answer['full'])
        
        # Evaluate answer quality - this is simplified for now
        # Could be enhanced to consider juror preferences
        return 'neutral'
    
    def get_move_significance(self, move_type: str) -> str:
        """Get a description of what a move type demonstrates."""
        significance_map = {
            'alliance_formed': 'build strong social connections',
            'elimination_orchestrated': 'take control of the game',
            'major_threat_elimination': 'identify and remove the biggest threats',
            'immunity_win': 'compete when it mattered most',
            'final_immunity_win': 'secure my spot in the finals',
            'multiple_immunity_wins': 'dominate in challenges',
            'idol_play': 'read the game and protect myself',
            'alliance_betrayal': 'make tough strategic decisions',
            'vote_flip': 'adapt my strategy when needed'
        }
        return significance_map.get(move_type, 'play strategically')
    
    def get_opening_speech_templates(self) -> Dict[int, Dict[str, str]]:
        """Get the opening speech templates for final tribal council."""
        return {
            1: {
                'title': 'Calculated Player',
                'template': "I'm here because I played a game of strategy, heart, and grit. Early on, I <move 1>, proving I could shape the game's direction. When challenges came, I <move 2>, showing my strength and resolve. And to secure my place here, I <move 3>, a move that defined my journey. I outwitted, outplayed, and outlasted. I humbly ask for your vote"
            },
            2: {
                'title': 'Resilience and Perseverance',
                'template': "After 39 days of battles, I'm here because I never gave up. I started strong when I <move 1>, building a foundation for my game. In the toughest moments, I <move 2>, proving I could face my challenges. And when it mattered most, I <move 3> which carried me to this final two. My journey was about survival. I think I've earned your vote to become your Sole Survivor."
            },
            3: {
                'title': 'Social Strategy',
                'template': "My game was built on bonds and bold moves. From the start, I <move 1>, forging connections that shaped our path. I faced challenges head-on when I <move 2>, earning my place among you. And when I <move 3>, I secured my spot here tonight. I played with heart and strategy. I hope you'll consider voting for me."
            },
            4: {
                'title': 'Big Moves',
                'template': "Tonight, I ask for your vote because I changed the game. I took control early when I <move 1>, setting the stage for my journey. When the stakes were high, I <move 2>, proving I could adapt and thrive. And I <move 3>, proving I could make it to this final moment. I played a game worthy of the title of Sole Survivor."
            },
            5: {
                'title': 'Balanced Game',
                'template': "I'm here because I played every angle of this game. In the early days I <move 1>, proving I could navigate the game. I pushed through adversity when I <move 2>, proving my strength. And I sealed my place when I <move 3>, a testament to my will to win. I outwitted, outplayed, outlasted."
            },
            6: {
                'title': 'No Moves 1',
                'template': "I stand before you after 39 grueling days, not with a list of flashy moves, but with a story of heart and survival. When I had the chance, I fought to stay in the game, showing my determination to keep pushing forward. Through every challenge, I held on with grit and resolve, proving I wouldn't break. And to earn my place here, I never stopped battling for this moment. My game wasn't loud, but it was mine"
            },
            7: {
                'title': 'No Moves 2',
                'template': "After 39 days of relentless struggle, I'm here because I never stopped fighting. I seized my moment with sheer willpower to survive, proving I could hold my own. In the face of chaos, I clung to every chance I got, showing my unbreakable spirit. And to stand before you now, I pushed through every obstacle to earn this spot. My game was about staying alive and I'm asking you to make me your Sole Survivor."
            }
        }
    
    def calculate_question_roll_modifier(self, answer_quality: str, juror: Contestant, finalist: Contestant, 
                                        speech_modifier: float = 0.0) -> float:
        """Calculate the question roll modifier based on answer quality and speech performance.
        
        Args:
            answer_quality: Quality of the answer ('critical_failure' to 'critical_success')
            juror: The juror who asked the question
            finalist: The finalist who answered
            speech_modifier: Modifier from the opening speech roll
            
        Returns:
            Modifier for the final jury roll
        """
        quality_modifiers = {
            'critical_failure': -2.0,
            'failure': -1.0,
            'neutral': 0.0,
            'success': 1.0,
            'critical_success': 2.0
        }
        
        answer_modifier = quality_modifiers.get(answer_quality, 0.0)
        total_modifier = answer_modifier + speech_modifier
        
        # Optional: Add debug output
        if hasattr(self, 'debug_jury_voting') and self.debug_jury_voting:
            print(f"    Question Roll: {answer_quality} = {answer_modifier:+.1f}, Speech = {speech_modifier:+.1f}, Total = {total_modifier:+.1f}")
        
        return total_modifier
    
    def calculate_game_move_bonus(self, finalist: Contestant) -> float:
        """Calculate the game move bonus for a finalist's final jury roll.
        
        Returns:
            Total bonus from game moves
        """
        bonus = 0.0
        
        # Count moves by level
        level_counts = {1: 0, 2: 0, 3: 0}
        for move in finalist.game_move_bank:
            level = move.get('level', 1)
            if level in level_counts:
                level_counts[level] += 1
        
        # Apply bonuses
        bonus += level_counts[3] * 1.0    # +1 for each Level 3 move
        bonus += level_counts[2] * 0.5    # +0.5 for each Level 2 move
        bonus += level_counts[1] * 0.25   # +0.25 for each Level 1 move
        
        # Penalty for no moves
        if not finalist.game_move_bank:
            bonus -= 2.0
        
        return bonus
    
    def determine_final_jury_vote(self, juror: Contestant, finalists: List[Contestant], 
                                 leaning_vote: Contestant, question_modifiers: Dict[Contestant, float]) -> Contestant:
        """Determine a juror's final vote after considering question responses.
        
        Args:
            juror: The juror casting the vote
            finalists: List of finalists
            leaning_vote: The juror's initial leaning vote
            question_modifiers: Dict mapping each finalist to their question roll modifiers
            
        Returns:
            The finalist the juror votes for
        """
        # Get the other finalist
        other_finalist = next(f for f in finalists if f != leaning_vote)
        
        # Calculate final jury roll modifiers for the leaning vote
        base_roll = random.randint(1, 20)
        game_move_bonus = self.calculate_game_move_bonus(leaning_vote)
        question_modifier = question_modifiers.get(leaning_vote, {}).get(juror, 0.0)
        
        total_roll = base_roll + game_move_bonus + question_modifier
        
        if hasattr(self, 'debug_jury_voting') and self.debug_jury_voting:
            print(f"\n{juror.name}'s Final Jury Roll for {leaning_vote.name}:")
            print(f"  Base roll: {base_roll}")
            print(f"  Game move bonus: {game_move_bonus:+.2f}")
            print(f"  Question modifiers: {question_modifier:+.2f}")
            print(f"  Total: {total_roll:.2f}")
        
        # Check if vote flips (16-20 range)
        if total_roll >= 16:
            if hasattr(self, 'debug_jury_voting') and self.debug_jury_voting:
                print(f"  Result: VOTE FLIPPED to {other_finalist.name}!")
            return other_finalist
        else:
            if hasattr(self, 'debug_jury_voting') and self.debug_jury_voting:
                print(f"  Result: Vote stays with {leaning_vote.name}")
            return leaning_vote
    
    def handle_opening_speeches(self, finalists: List[Contestant]) -> Dict[Contestant, float]:
        """Handle the opening speeches phase of final tribal council.
        
        Returns:
            Dictionary mapping each finalist to their opening speech roll modifier
        """
        self.narration("The finalists will each give their opening speech to the jury.")
        
        # Keep track of used speech types to ensure NPCs get different speeches
        used_speech_types = []
        speech_modifiers = {}
        
        for finalist in finalists:
            self.narration(f"\n{finalist.name} addresses the jury.")
            speech, speech_type, referenced_moves = self.generate_opening_speech(finalist, used_speech_types)
            self.contestant_speaks(finalist, speech)
            
            # Evaluate the speech quality and get modifier
            speech_quality = self.evaluate_opening_speech_quality(finalist, speech_type, referenced_moves)
            modifier = self.get_speech_quality_modifier(speech_quality)
            speech_modifiers[finalist] = modifier
            
            # Optional debug output
            if hasattr(self, 'debug_jury_voting') and self.debug_jury_voting:
                print(f"    Opening Speech: {speech_quality} = {modifier:+.1f} modifier for all questions")
            
        self.narration("The opening statements are complete.")
        return speech_modifiers
    
    def generate_opening_speech(self, contestant: Contestant, used_speech_types: List[int]) -> Tuple[str, int, List[Dict]]:
        """Generate an opening speech for a contestant.
        
        Args:
            contestant: The contestant giving the speech
            used_speech_types: List of speech types already used by other finalists
            
        Returns:
            Tuple of (complete speech text, speech type number, list of moves referenced in speech)
        """
        templates = self.get_opening_speech_templates()
        has_sufficient_moves = len(contestant.game_move_bank) >= 3
        
        # Determine speech type
        if contestant.is_player and has_sufficient_moves:
            speech_type = self.get_player_speech_choice()
        else:
            speech_type = self.get_npc_speech_choice(has_sufficient_moves, used_speech_types)
        
        used_speech_types.append(speech_type)
        
        # Get the speech template
        speech_template = templates[speech_type]['template']
        
        # Insert moves into template if needed (speeches 1-5)
        referenced_moves = []
        if speech_type <= 5:
            moves = self.select_moves_for_speech(contestant)
            speech = self.insert_moves_into_speech(speech_template, moves)
            referenced_moves = moves
        else:
            # Speeches 6-7 don't need move insertion
            speech = speech_template
            referenced_moves = []  # No moves referenced
        
        return speech, speech_type, referenced_moves
    
    def get_player_speech_choice(self) -> int:
        """Let the player choose their opening speech type."""
        print("\nWhich type of speech would you like to give?")
        print("1. A speech that frames me as a calculated player")
        print("2. A speech that focuses on my resilience and perseverance")
        print("3. A speech that highlights my social strategy")
        print("4. A speech that emphasizes my big moves")
        print("5. A speech that showcases my balanced game")
        
        while True:
            try:
                choice = input("Select your speech type (1-5): ").strip()
                choice_num = int(choice)
                if 1 <= choice_num <= 5:
                    return choice_num
                else:
                    print("Please enter a number between 1 and 5.")
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    def get_npc_speech_choice(self, has_sufficient_moves: bool, used_speech_types: List[int]) -> int:
        """Select a speech type for an NPC contestant.
        
        Args:
            has_sufficient_moves: Whether the NPC has 3+ moves in their game move bank
            used_speech_types: Speech types already used by other finalists
            
        Returns:
            The selected speech type number
        """
        if not has_sufficient_moves:
            # Must use speech 6 or 7
            available_options = [6, 7]
            available_options = [opt for opt in available_options if opt not in used_speech_types]
            
            if not available_options:
                # If both are taken, just pick randomly
                return random.choice([6, 7])
            else:
                return random.choice(available_options)
        else:
            # Can use speeches 1-5, but avoid already used ones
            available_options = [1, 2, 3, 4, 5]
            available_options = [opt for opt in available_options if opt not in used_speech_types]
            
            if not available_options:
                # If all are taken (shouldn't happen with 2 finalists), just pick randomly
                return random.choice([1, 2, 3, 4, 5])
            else:
                return random.choice(available_options)
    
    def select_moves_for_speech(self, contestant: Contestant) -> List[Dict]:
        """Select moves for a contestant's speech.
        
        Args:
            contestant: The contestant giving the speech
            
        Returns:
            List of 3 selected moves
        """
        available_moves = contestant.game_move_bank.copy()
        
        if len(available_moves) < 3:
            # This shouldn't happen if we're calling this method, but just in case
            # Pad with generic moves
            while len(available_moves) < 3:
                available_moves.append({
                    'day': 1,
                    'description': 'stayed strong in the game',
                    'level': 1
                })
        
        if contestant.is_player:
            return self.get_player_move_choices(available_moves)
        else:
            # For NPCs, select moves strategically
            return self.get_npc_move_choices(available_moves)
    
    def get_player_move_choices(self, available_moves: List[Dict]) -> List[Dict]:
        """Let the player choose 3 moves for their speech."""
        print(f"\nSelect 3 moves to highlight in your speech:")
        for i, move in enumerate(available_moves, 1):
            print(f"{i}. Day {move['day']}: {move['description']} (Level {move['level']})")
        
        selected_moves = []
        for move_num in range(1, 4):
            while True:
                try:
                    choice = input(f"Select move {move_num} (1-{len(available_moves)}): ").strip()
                    choice_idx = int(choice) - 1
                    
                    if 0 <= choice_idx < len(available_moves):
                        selected_move = available_moves[choice_idx]
                        if selected_move not in selected_moves:
                            selected_moves.append(selected_move)
                            break
                        else:
                            print("You've already selected that move. Please choose a different one.")
                    else:
                        print(f"Please enter a number between 1 and {len(available_moves)}")
                except ValueError:
                    print("Invalid input. Please enter a number.")
        
        return selected_moves
    
    def get_npc_move_choices(self, available_moves: List[Dict]) -> List[Dict]:
        """Select 3 moves for an NPC's speech, prioritizing higher level moves."""
        # Sort moves by level (highest first), then by day (most recent first)
        sorted_moves = sorted(available_moves, key=lambda m: (m['level'], m['day']), reverse=True)
        
        # Take the top 3 moves, but add some randomness
        if len(sorted_moves) >= 6:
            # If we have many moves, pick from the top half
            top_moves = sorted_moves[:len(sorted_moves)//2]
            return random.sample(top_moves, 3)
        else:
            # If we have fewer moves, just take the top 3
            return sorted_moves[:3]
    
    def insert_moves_into_speech(self, template: str, moves: List[Dict]) -> str:
        """Insert selected moves into the speech template.
        
        Args:
            template: The speech template with <move 1>, <move 2>, <move 3> placeholders
            moves: List of 3 selected moves
            
        Returns:
            The speech with moves inserted
        """
        speech = template
        
        for i, move in enumerate(moves, 1):
            placeholder = f"<move {i}>"
            move_text = move['description'].lower()
            
            # Capitalize names properly - look for contestant names in the text
            for contestant in self.contestants:
                # Replace lowercase name with properly capitalized name
                move_text = move_text.replace(contestant.name.lower(), contestant.name)
            
            speech = speech.replace(placeholder, move_text)
        
        return speech
    
    def evaluate_opening_speech_quality(self, contestant: Contestant, speech_type: int, referenced_moves: List[Dict]) -> str:
        """Evaluate the quality of a contestant's opening speech.
        
        Args:
            contestant: The contestant who gave the speech
            speech_type: The type of speech given (1-7)
            referenced_moves: List of moves referenced in the speech
            
        Returns:
            Speech quality: 'critical_failure', 'failure', 'neutral', 'success', or 'critical_success'
        """
        # Base roll for speech evaluation
        base_roll = random.randint(1, 20)
        
        # Speech modifiers based on referenced moves
        speech_modifiers = 0
        
        # Apply new modifier system based on referenced moves
        if speech_type >= 6:
            # Speeches 6-7: Not enough moves to fill out the speech
            speech_modifiers -= 3
        else:
            # Speeches 1-5: Calculate modifiers based on referenced moves
            for move in referenced_moves:
                move_level = move.get('level', 1)
                if move_level == 3:
                    speech_modifiers += 2  # +2 for each Level 3 move referenced
                elif move_level == 2:
                    speech_modifiers += 1  # +1 for each Level 2 move referenced
                elif move_level == 1:
                    speech_modifiers += 0.5  # +0.5 for each Level 1 move referenced
        
        # Contestant attributes that affect speech delivery (keeping these)
        if contestant.social_skill >= 2:
            speech_modifiers += 1  # Good social skills help with speech delivery
        
        if contestant.strategic_skill >= 2:
            speech_modifiers += 1  # Strategic players can frame their game better
        
        # Calculate total
        total_roll = base_roll + speech_modifiers
        
        # Determine quality based on total
        if total_roll <= 5:
            quality = 'critical_failure'
        elif total_roll <= 10:
            quality = 'failure'
        elif total_roll <= 15:
            quality = 'neutral'
        elif total_roll <= 19:
            quality = 'success'
        else:  # 20+
            quality = 'critical_success'
        
        # Optional debug output
        if hasattr(self, 'debug_jury_voting') and self.debug_jury_voting:
            if referenced_moves:
                move_details = [f"Level {move.get('level', 1)}" for move in referenced_moves]
                print(f"    Speech Evaluation: Roll={base_roll}, Moves=[{', '.join(move_details)}], Modifiers={speech_modifiers:+.1f}, Total={total_roll:.1f}, Quality={quality}")
            else:
                print(f"    Speech Evaluation: Roll={base_roll}, No moves referenced, Modifiers={speech_modifiers:+.1f}, Total={total_roll:.1f}, Quality={quality}")
        
        return quality
    
    def get_speech_quality_modifier(self, speech_quality: str) -> float:
        """Get the modifier value for a speech quality.
        
        Args:
            speech_quality: The quality of the speech
            
        Returns:
            Modifier value for all question rolls
        """
        quality_modifiers = {
            'critical_failure': -2.0,
            'failure': -1.0,
            'neutral': 0.0,
            'success': 1.0,
            'critical_success': 2.0
        }
        
        return quality_modifiers.get(speech_quality, 0.0)
    
    def handle_final_day(self) -> None:
        """Handle the final day with jury voting."""
        # Skip day intro if player is jury spectator
        if not self.player_is_jury_spectator:
            self.day_intro()
        
        final_two = self.get_active_contestants()
        
        # Handle edge case where there's only 1 finalist
        if len(final_two) == 1:
            self.narration(f"Due to an unusual game circumstance, {final_two[0].name} is the sole remaining contestant.")
            self.jeff_speaks(f"Congratulations {final_two[0].name}, you are the Sole Survivor!")
            if final_two[0].is_player:
                self.narration("Congratulations! You are the Sole Survivor!")
            else:
                self.narration(f"Congratulations to {final_two[0].name}, the Sole Survivor!")
            return
        elif len(final_two) != 2:
            self.narration(f"Error: Expected 2 finalists but found {len(final_two)}. Ending game.")
            return
        
        self.narration("The final two contestants arrive at tribal council for the last time.")
        self.jeff_speaks("Welcome to your final tribal council. Tonight, the power shifts to the jury. Before we begin with questions, each finalist will have a chance to make an opening statement.")
        
        # Opening speeches
        speech_modifiers = self.handle_opening_speeches(final_two)
        
        # Determine initial jury leaning votes
        leaning_votes = self.calculate_all_jury_leaning_votes(final_two)
        
        # Jury questioning phase
        question_modifiers = self.handle_jury_questioning(final_two, speech_modifiers)
        
        # Jury voting with final roll mechanics
        self.narration("The jury members each come up to vote for who they think should be the Sole Survivor.")
        
        votes = {contestant: 0 for contestant in final_two}
        for juror in self.jury:
            # Check if this is the player as a jury spectator
            if hasattr(self, 'player_is_jury_spectator') and self.player_is_jury_spectator and juror.is_player:
                # Allow player to choose their vote
                self.narration(f"\nIt's time for you to cast your jury vote.")
                print("\nWho do you want to vote for as the Sole Survivor?")
                for i, finalist in enumerate(final_two, 1):
                    print(f"{i}. {finalist.name}")
                
                while True:
                    try:
                        choice = input(f"\nCast your vote (1-{len(final_two)}): ").strip()
                        choice_num = int(choice)
                        if 1 <= choice_num <= len(final_two):
                            vote = final_two[choice_num - 1]
                            break
                        else:
                            print(f"Please enter a number between 1 and {len(final_two)}")
                    except ValueError:
                        print("Invalid input. Please enter a number.")
                
                votes[vote] += 1
                self.narration(f"{juror.name} casts {juror.get_pronoun('possessive')} vote.")
            else:
                # Get this juror's leaning vote
                leaning_vote = None
                for finalist, supporters in leaning_votes.items():
                    if juror in supporters:
                        leaning_vote = finalist
                        break
                
                if leaning_vote is None:
                    # Fallback if something went wrong
                    vote = random.choice(final_two)
                else:
                    # Determine final vote with rolling mechanics
                    vote = self.determine_final_jury_vote(juror, final_two, leaning_vote, question_modifiers)
                
                votes[vote] += 1
                self.narration(f"{juror.name} casts {juror.get_pronoun('possessive')} vote.")
        
        self.jeff_speaks("I'll go tally the votes.")
        self.narration("Jeff retrieves the voting urn.")
        
        # For dramatic effect, make it close
        winner = max(votes.items(), key=lambda x: x[1])[0]
        votes_for_winner = votes[winner]
        votes_for_runner_up = len(self.jury) - votes_for_winner
        
        self.jeff_speaks("I know you'd like for me to read these votes now, but unfortunately you'll have to wait a bit longer. Thank you for a great season of Survivor. I'll see you back in the United States for the reading of the votes.")
        
        # Fast forward to reunion
        self.narration("Several months later at the reunion show...")
        self.narration("Jeff enters the live studio carrying the voting urn. The final two waits eagerly.")
        
        # Start fresh vote count for reunion show
        vote_count = {"winner": 0, "runner_up": 0}
        # Handle case where there might be only 1 finalist
        other_finalists = [c for c in final_two if c != winner]
        if other_finalists:
            loser = other_finalists[0]
        else:
            # Only 1 finalist case - no runner up
            loser = None
        
        # Read all votes at reunion show
        self.jeff_speaks("Alright, let's get to the reading of the votes.")
        
        # Helper function to get ordinal numbers
        def get_ordinal(n):
            ordinals = ["First", "Second", "Third", "Fourth", "Fifth", "Sixth", "Seventh", "Eighth", "Ninth", "Tenth"]
            if n < len(ordinals):
                return ordinals[n]
            else:
                return f"{n+1}th"
        
        # Read all votes except the last one
        votes_read = 0
        winner_votes_read = 0
        loser_votes_read = 0
        
        for i in range(len(self.jury) - 1):  # Read all but the last vote
            if winner_votes_read < votes_for_winner - 1:  # Save one winner vote for last
                winner_votes_read += 1
                self.jeff_speaks(f"{get_ordinal(votes_read)} vote, {winner.name}")
            elif loser and loser_votes_read < votes_for_runner_up:
                loser_votes_read += 1
                self.jeff_speaks(f"{get_ordinal(votes_read)} vote, {loser.name}")
            votes_read += 1
        
        # Read the final vote (always for the winner)
        self.jeff_speaks("The winner of Survivor...")
        
        self.narration(f"Jeff flips over the final vote to reveal: {winner.name}")
        
        self.jeff_speaks(f"{winner.name}")
        
        if winner.is_player:
            self.narration("Congratulations! You are the Sole Survivor!")
        else:
            self.narration(f"Congratulations to {winner.name}, the Sole Survivor!")
    
    def is_player_eliminated(self) -> bool:
        """Check if the player has been eliminated."""
        return self.player.eliminated
    
    def offer_jury_spectator_mode(self) -> bool:
        """Offer the eliminated player the option to continue as a jury spectator.
        Returns True if player chooses to continue, False otherwise."""
        print("\nYou have been voted out of the game. Would you like to continue as a juror?")
        print("1. Yes")
        print("2. No")
        
        while True:
            try:
                choice = int(input("Enter your choice (1-2): "))
                if choice == 1:
                    return True
                elif choice == 2:
                    return False
                else:
                    print("Invalid choice. Please enter 1 or 2.")
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    def jury_spectator_actions(self) -> None:
        """Handle jury spectator mode - allow watching and limited interactions."""
        print("\n" + "="*50)
        print("🏛️  JURY SPECTATOR MODE  🏛️")
        print("="*50)
        print("You are now observing the remaining contestants as a jury member.")
        
        while True:
            print("\nWhat would you like to do?")
            print("1. Observe Contestants")
            print("2. Check Jury Information")
            print("3. End Day")
            
            try:
                choice = int(input("Enter your choice (1-3): "))
                if choice == 1:
                    self.observe_remaining_contestants()
                elif choice == 2:
                    self.check_jury_info()
                elif choice == 3:
                    self.narration("You retire to the jury area for the evening.")
                    break
                else:
                    print("Invalid choice. Please enter 1, 2, or 3.")
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    def observe_remaining_contestants(self) -> None:
        """Allow jury spectator to observe remaining contestants."""
        active_contestants = [c for c in self.contestants if not c.eliminated and not c.is_player]
        
        if not active_contestants:
            print("No remaining contestants to observe.")
            return
            
        print("\nRemaining Contestants:")
        for i, contestant in enumerate(active_contestants, 1):
            status_text = " (IMMUNE)" if contestant.immune else ""
            print(f"{i}. {contestant.name}{status_text}")
        
        print("You take mental notes for your eventual jury vote...")
    
    def handle_jury_spectator_day(self) -> None:
        """Handle a day when the player is a jury spectator - skip to tribal council."""
        # Skip all daily activities for jury spectators
        
        # Check if there are active contestants left
        active_contestants = [c for c in self.contestants if not c.eliminated]
        if len(active_contestants) <= 2:
            # Final 2 - skip straight to final tribal council
            self.narration(f"Day {self.day}")
            self.narration("Tonight is the final tribal council where you'll cast your jury vote.")
            # Call the final tribal council
            self.handle_final_day()
            return
        
        # Check if today is supposed to have a tribal council
        tribal_day = False
        
        # Post-merge: tribal council every day except challenges/rewards
        if self.merged:
            # Check if it's a special day (challenge day, etc.)
            if self.day % 3 == 1:  # Challenge days
                tribal_day = False
            else:
                tribal_day = True
        else:
            # Pre-merge: tribal council every 3 days
            if self.day % 3 == 0:
                tribal_day = True
        
        if tribal_day:
            # Jump to tribal council for jury spectator
            self.narration(f"Day {self.day}")
            
            # Display contestant status for jury members
            self.display_contestant_status_for_jury()
            
            # Check if there are other jury members
            jury_count = len(self.jury)
            if jury_count > 1:
                self.narration("You and the rest of the jury enter tribal council.")
            else:
                self.narration("You enter tribal council.")
            
            # Show who has immunity if there was a challenge
            active_contestants = [c for c in self.contestants if not c.eliminated]
            immunity_winner = None
            
            # Simulate immunity challenge results (for display purposes)
            if len(active_contestants) > 2:
                immunity_winner = random.choice(active_contestants)
                immunity_winner.immune = True
                self.narration(f"{immunity_winner.name} is wearing the immunity necklace")
                self.narration("From your seat in the jury area, you watch tribal council unfold.")
                self.narration("" + "="*80)
            
            # Handle the tribal council with the jury spectator observing
            self.tribal_council()
        else:
            # Skip day - no tribal council
            self.narration("The remaining contestants continue their game...")
            
            # Simulate the day for NPCs (they need to continue their game)
            # This happens "behind the scenes" - jury doesn't see it
            self.simulate_day_for_npcs()
    
    def simulate_day_for_npcs(self) -> None:
        """Simulate a day for NPCs when jury spectator is not watching."""
        # Run NPC actions silently
        active_npcs = [c for c in self.contestants if not c.eliminated and not c.is_player]
        
        # Simulate basic game progression without showing to jury
        for npc in active_npcs:
            # Basic relationship and strategy updates
            npc.npc_actions_taken_today = 0
            
        # Run NPC actions for the day (silently)
        self.perform_npc_actions(action_round=1)
        self.perform_npc_actions(action_round=2)
        
        # Apply end-of-day processing
        self.apply_daily_game_security_checks()
    
    def check_jury_info(self) -> None:
        """Show jury-specific information."""
        print("\n" + "="*40)
        print("JURY INFORMATION")
        print("="*40)
        
        # Show current jury members
        if self.jury:
            print(f"\nJury Members ({len(self.jury)}):")
            for juror in self.jury:
                print(f"  - {juror.name}")
        
        # Show remaining contestants
        active_contestants = [c for c in self.contestants if not c.eliminated and not c.is_player]
        print(f"\nRemaining Contestants ({len(active_contestants)}):")
        for contestant in active_contestants:
            immunity_text = " (Has Immunity)" if contestant.immune else ""
            print(f"  - {contestant.name}{immunity_text}")
        
        print(f"\nCurrent Day: {self.day}")
        if len(active_contestants) == 2:
            print("The final tribal council is approaching!")
    
    def calculate_all_jury_leaning_votes(self, finalists: List[Contestant]) -> Dict[Contestant, List[Contestant]]:
        """Calculate jury leaning votes for all jury members.
        
        Args:
            finalists: List of final contestants
            
        Returns:
            Dictionary mapping each finalist to list of jury members leaning towards voting for them
        """
        leaning_votes = {finalist: [] for finalist in finalists}
        
        for jury_member in self.jury:
            leaning_choice = jury_member.determine_leaning_jury_vote(finalists, self)
            if leaning_choice:
                leaning_votes[leaning_choice].append(jury_member)
        
        return leaning_votes
    
    def run_game(self) -> None:
        """Run the main game loop."""
        self.initialize_game()
        
        day_schedule = {
            1: self.handle_day_1,
            2: self.handle_normal_day,
            3: self.handle_pre_merge_immunity_day,
            4: self.handle_normal_day,
            5: self.handle_normal_day,
            6: self.handle_pre_merge_immunity_day,
            7: self.handle_normal_day,
            8: self.handle_normal_day,
            9: self.handle_pre_merge_immunity_day,
            10: self.handle_normal_day,
            11: self.handle_normal_day,
            12: self.handle_pre_merge_immunity_day,
            13: self.handle_tribe_swap_day,
            14: self.handle_pre_merge_immunity_day,
            15: self.handle_normal_day,
            16: self.handle_pre_merge_immunity_day,
            17: self.handle_normal_day,
            18: self.handle_pre_merge_immunity_day,
            19: self.handle_normal_day,
            20: self.handle_pre_merge_immunity_day,
            21: self.handle_normal_day,
            22: self.handle_pre_merge_immunity_day,
            23: self.handle_merge_day,
            24: self.handle_post_merge_immunity_day,
            25: self.handle_normal_day,
            26: self.handle_post_merge_immunity_day,
            27: self.handle_normal_day,
            28: self.handle_post_merge_immunity_day,
            29: self.handle_normal_day,
            30: self.handle_post_merge_immunity_day,
            31: self.handle_normal_day,
            32: self.handle_post_merge_immunity_day,
            33: self.handle_normal_day,
            34: self.handle_post_merge_immunity_day,
            35: self.handle_normal_day,
            36: self.handle_post_merge_immunity_day,
            37: self.handle_post_merge_immunity_day,
            38: self.handle_final_three_day,
            39: self.handle_final_day
        }
        
        try:
            while self.day <= self.final_day:
                # Handle jury spectator mode differently
                if self.player_is_jury_spectator:
                    self.handle_jury_spectator_day()
                else:
                    # Run normal day handler for active players
                    if self.day in day_schedule:
                        day_schedule[self.day]()
                    else:
                        self.handle_normal_day()
                
                # Check if player is eliminated
                if self.is_player_eliminated() and not self.player_is_jury_spectator:
                    elimination_order = len(self.eliminated_contestants)
                    position = 20 - elimination_order + 1  # Convert elimination order to placement (20th, 19th, 18th, etc.)
                    self.narration(f"You have been voted out of the game. You placed {position}th out of 20 contestants.")
                    
                    # Offer jury spectator mode if eliminated after merge
                    if self.merged and self.day >= self.merge_day:
                        if self.offer_jury_spectator_mode():
                            self.player_is_jury_spectator = True
                            # Add player to jury if not already there
                            if self.player not in self.jury:
                                self.jury.append(self.player)
                            
                            # Add Ponderosa transition
                            self.narration("You board the boat to Ponderosa, where you'll rest and wait to cast your jury vote. You will now observe the remaining contestants compete.")
                            
                            # IMPORTANT: Increment day before continuing to avoid repeating the same day
                            self.day += 1
                            continue  # Continue the game loop as a spectator
                    
                    break
                
                # Apply daily game security checks at end of day
                self.apply_daily_game_security_checks()
                
                # Increment day
                self.day += 1
                
            if self.day > self.final_day and not self.is_player_eliminated():
                self.narration("Congratulations on making it to the end of Survivor!")
                
        except KeyboardInterrupt:
            print("\nGame exited.")
        except EOFError:
            print("\nInput stream ended unexpectedly. Game exited.")
        except Exception as e:
            print(f"\nAn unexpected error occurred: {e}")
            print("Game exited due to error.")
        
        # Wait for user input before exiting
        print("\n" + "="*50)
        input("Press Enter to exit...")
        print("Thanks for playing Survivor!")

if __name__ == "__main__":
    print("="*80)
    print("WELCOME TO SURVIVOR")
    print("="*80)
    print("\nCan you outwit, outplay, and outlast to become the Sole Survivor?")
    print("="*80)
    
    game = Game()
    game.run_game()